/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz8xNmRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwgc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzP2U1MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popper);\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQXdEOztBQUU5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaURBQWlELHVDQUF1QyxrREFBa0Q7QUFDMUksS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7O0FBR0EseURBQXlELHFCQUFNO0FBQy9EO0FBQ0E7O0FBRUEsK0RBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzP2E1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNi4xXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciB0aW1lb3V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59KCk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBub2RlIG9mIHRoZSByZWZlcmVuY2Ugb2JqZWN0LCBvciB0aGUgcmVmZXJlbmNlIG9iamVjdCBpdHNlbGYuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10pICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuaGVpZ2h0O1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICB2YXIgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gIH07XG59XG5cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20gfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NUb3ApO1xuXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgfHwgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudDtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHZhciBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICB2YXIgdG9wID0gcG9wcGVyU3R5bGVzLnRvcCxcbiAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcblxuICBwb3BwZXJTdHlsZXMudG9wID0gJyc7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9ICcnO1xuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/popper.js/dist/esm/popper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBVzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9jZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9HQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDL0QsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFrQjs7QUFFL0M7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/NWQ3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdEQsRUFBRSxLQUFLLEVBSU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/MGE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2E2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcz8zZjU5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/es/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-floater/es/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ReactFloater; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! popper.js */ \"(app-pages-browser)/./node_modules/popper.js/dist/esm/popper.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! is-lite */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/is-lite/esm/index.js\");\n/* harmony import */ var tree_changes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tree-changes */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\n\n\n\n\n\n\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar DEFAULTS = {flip:{padding:20},preventOverflow:{padding:10}};\n\nvar VALIDATOR_ARG_ERROR_MESSAGE='The typeValidator argument must be a function '+'with the signature function(props, propName, componentName).';var MESSAGE_ARG_ERROR_MESSAGE='The error message is optional, but must be a string if provided.';function propIsRequired(condition,props,propName,componentName){if(typeof condition==='boolean'){return condition;}if(typeof condition==='function'){return condition(props,propName,componentName);}if(Boolean(condition)===true){return Boolean(condition);}return false;}function propExists(props,propName){return Object.hasOwnProperty.call(props,propName);}function missingPropError(props,propName,componentName,message){if(message){return new Error(message);}return new Error(\"Required \".concat(props[propName],\" `\").concat(propName,\"` was not specified in `\").concat(componentName,\"`.\"));}function guardAgainstInvalidArgTypes(typeValidator,message){if(typeof typeValidator!=='function'){throw new TypeError(VALIDATOR_ARG_ERROR_MESSAGE);}if(Boolean(message)&&typeof message!=='string'){throw new TypeError(MESSAGE_ARG_ERROR_MESSAGE);}}function isRequiredIf(typeValidator,condition,message){guardAgainstInvalidArgTypes(typeValidator,message);return function(props,propName,componentName){for(var _len=arguments.length,rest=new Array(_len>3?_len-3:0),_key=3;_key<_len;_key++){rest[_key-3]=arguments[_key];}if(propIsRequired(condition,props,propName,componentName)){if(propExists(props,propName)){return typeValidator.apply(void 0,[props,propName,componentName].concat(rest));}return missingPropError(props,propName,componentName,message);}// Is not required, so just run typeValidator.\nreturn typeValidator.apply(void 0,[props,propName,componentName].concat(rest));};}\n\nvar STATUS = {INIT:'init',IDLE:'idle',OPENING:'opening',OPEN:'open',CLOSING:'closing',ERROR:'error'};\n\nvar isReact16=react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal!==undefined;function canUseDOM(){return !!(typeof window!=='undefined'&&window.document&&window.document.createElement);}function isMobile(){return 'ontouchstart'in window&&/Mobi/.test(navigator.userAgent);}/**\n * Log method calls if debug is enabled\n *\n * @private\n * @param {Object}       arg\n * @param {string}       arg.title    - The title the logger was called from\n * @param {Object|Array} [arg.data]   - The data to be logged\n * @param {boolean}      [arg.warn]  - If true, the message will be a warning\n * @param {boolean}      [arg.debug] - Nothing will be logged unless debug is true\n */function log(_ref){var title=_ref.title,data=_ref.data,_ref$warn=_ref.warn,warn=_ref$warn===void 0?false:_ref$warn,_ref$debug=_ref.debug,debug=_ref$debug===void 0?false:_ref$debug;/* eslint-disable no-console */var logFn=warn?console.warn||console.error:console.log;if(debug&&title&&data){console.groupCollapsed(\"%creact-floater: \".concat(title),'color: #9b00ff; font-weight: bold; font-size: 12px;');if(Array.isArray(data)){data.forEach(function(d){if(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"].plainObject(d)&&d.key){logFn.apply(console,[d.key,d.value]);}else {logFn.apply(console,[d]);}});}else {logFn.apply(console,[data]);}console.groupEnd();}/* eslint-enable */}function on(element,event,cb){var capture=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;element.addEventListener(event,cb,capture);}function off(element,event,cb){var capture=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;element.removeEventListener(event,cb,capture);}function once(element,event,cb){var capture=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var _nextCB;// eslint-disable-next-line prefer-const\n_nextCB=function nextCB(e){cb(e);off(element,event,_nextCB);};on(element,event,_nextCB,capture);}function noop(){}\n\nvar ReactFloaterPortal=/*#__PURE__*/function(_React$Component){_inherits(ReactFloaterPortal,_React$Component);var _super=_createSuper(ReactFloaterPortal);function ReactFloaterPortal(){_classCallCheck(this,ReactFloaterPortal);return _super.apply(this,arguments);}_createClass(ReactFloaterPortal,[{key:\"componentDidMount\",value:function componentDidMount(){if(!canUseDOM())return;if(!this.node){this.appendNode();}if(!isReact16){this.renderPortal();}}},{key:\"componentDidUpdate\",value:function componentDidUpdate(){if(!canUseDOM())return;if(!isReact16){this.renderPortal();}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){if(!canUseDOM()||!this.node)return;if(!isReact16){react_dom__WEBPACK_IMPORTED_MODULE_2__.unmountComponentAtNode(this.node);}if(this.node&&this.node.parentNode===document.body){document.body.removeChild(this.node);this.node=undefined;}}},{key:\"appendNode\",value:function appendNode(){var _this$props=this.props,id=_this$props.id,zIndex=_this$props.zIndex;if(!this.node){this.node=document.createElement('div');/* istanbul ignore else */if(id){this.node.id=id;}if(zIndex){this.node.style.zIndex=zIndex;}document.body.appendChild(this.node);}}},{key:\"renderPortal\",value:function renderPortal(){if(!canUseDOM())return null;var _this$props2=this.props,children=_this$props2.children,setRef=_this$props2.setRef;if(!this.node){this.appendNode();}/* istanbul ignore else */if(isReact16){return/*#__PURE__*/react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(children,this.node);}var portal=react_dom__WEBPACK_IMPORTED_MODULE_2__.unstable_renderSubtreeIntoContainer(this,children.length>1?/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",null,children):children[0],this.node);setRef(portal);return null;}},{key:\"renderReact16\",value:function renderReact16(){var _this$props3=this.props,hasChildren=_this$props3.hasChildren,placement=_this$props3.placement,target=_this$props3.target;if(!hasChildren){if(target||placement==='center'){return this.renderPortal();}return null;}return this.renderPortal();}},{key:\"render\",value:function render(){if(!isReact16){return null;}return this.renderReact16();}}]);return ReactFloaterPortal;}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));_defineProperty(ReactFloaterPortal,\"propTypes\",{children:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().element),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().array)]),hasChildren:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),id:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number)]),placement:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),setRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,target:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string)]),zIndex:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number)});\n\nvar FloaterArrow=/*#__PURE__*/function(_React$Component){_inherits(FloaterArrow,_React$Component);var _super=_createSuper(FloaterArrow);function FloaterArrow(){_classCallCheck(this,FloaterArrow);return _super.apply(this,arguments);}_createClass(FloaterArrow,[{key:\"parentStyle\",get:function get(){var _this$props=this.props,placement=_this$props.placement,styles=_this$props.styles;var length=styles.arrow.length;var arrow={pointerEvents:'none',position:'absolute',width:'100%'};/* istanbul ignore else */if(placement.startsWith('top')){arrow.bottom=0;arrow.left=0;arrow.right=0;arrow.height=length;}else if(placement.startsWith('bottom')){arrow.left=0;arrow.right=0;arrow.top=0;arrow.height=length;}else if(placement.startsWith('left')){arrow.right=0;arrow.top=0;arrow.bottom=0;}else if(placement.startsWith('right')){arrow.left=0;arrow.top=0;}return arrow;}},{key:\"render\",value:function render(){var _this$props2=this.props,placement=_this$props2.placement,setArrowRef=_this$props2.setArrowRef,styles=_this$props2.styles;var _styles$arrow=styles.arrow,color=_styles$arrow.color,display=_styles$arrow.display,length=_styles$arrow.length,margin=_styles$arrow.margin,position=_styles$arrow.position,spread=_styles$arrow.spread;var arrowStyles={display:display,position:position};var points;var x=spread;var y=length;/* istanbul ignore else */if(placement.startsWith('top')){points=\"0,0 \".concat(x/2,\",\").concat(y,\" \").concat(x,\",0\");arrowStyles.bottom=0;arrowStyles.marginLeft=margin;arrowStyles.marginRight=margin;}else if(placement.startsWith('bottom')){points=\"\".concat(x,\",\").concat(y,\" \").concat(x/2,\",0 0,\").concat(y);arrowStyles.top=0;arrowStyles.marginLeft=margin;arrowStyles.marginRight=margin;}else if(placement.startsWith('left')){y=spread;x=length;points=\"0,0 \".concat(x,\",\").concat(y/2,\" 0,\").concat(y);arrowStyles.right=0;arrowStyles.marginTop=margin;arrowStyles.marginBottom=margin;}else if(placement.startsWith('right')){y=spread;x=length;points=\"\".concat(x,\",\").concat(y,\" \").concat(x,\",0 0,\").concat(y/2);arrowStyles.left=0;arrowStyles.marginTop=margin;arrowStyles.marginBottom=margin;}return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__arrow\",style:this.parentStyle},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\",{ref:setArrowRef,style:arrowStyles},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\",{width:x,height:y,version:\"1.1\",xmlns:\"http://www.w3.org/2000/svg\"},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"polygon\",{points:points,fill:color}))));}}]);return FloaterArrow;}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));_defineProperty(FloaterArrow,\"propTypes\",{placement:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,setArrowRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object).isRequired});\n\nvar _excluded$1=[\"color\",\"height\",\"width\"];function FloaterCloseBtn(_ref){var handleClick=_ref.handleClick,styles=_ref.styles;var color=styles.color,height=styles.height,width=styles.width,style=_objectWithoutProperties(styles,_excluded$1);return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\",{\"aria-label\":\"close\",onClick:handleClick,style:style,type:\"button\"},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\",{width:\"\".concat(width,\"px\"),height:\"\".concat(height,\"px\"),viewBox:\"0 0 18 18\",version:\"1.1\",xmlns:\"http://www.w3.org/2000/svg\",preserveAspectRatio:\"xMidYMid\"},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\",null,/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\",{d:\"M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z\",fill:color}))));}FloaterCloseBtn.propTypes={handleClick:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object).isRequired};\n\nfunction FloaterContainer(_ref){var content=_ref.content,footer=_ref.footer,handleClick=_ref.handleClick,open=_ref.open,positionWrapper=_ref.positionWrapper,showCloseButton=_ref.showCloseButton,title=_ref.title,styles=_ref.styles;var output={content:/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(content)?content:/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__content\",style:styles.content},content)};if(title){output.title=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(title)?title:/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__title\",style:styles.title},title);}if(footer){output.footer=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(footer)?footer:/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__footer\",style:styles.footer},footer);}if((showCloseButton||positionWrapper)&&!is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open)){output.close=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FloaterCloseBtn,{styles:styles.close,handleClick:handleClick});}return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__container\",style:styles.container},output.close,output.title,output.content,output.footer);}FloaterContainer.propTypes={content:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node).isRequired,footer:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),handleClick:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,open:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),positionWrapper:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool).isRequired,showCloseButton:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool).isRequired,styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object).isRequired,title:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node)};\n\nvar Floater=/*#__PURE__*/function(_React$Component){_inherits(Floater,_React$Component);var _super=_createSuper(Floater);function Floater(){_classCallCheck(this,Floater);return _super.apply(this,arguments);}_createClass(Floater,[{key:\"style\",get:function get(){var _this$props=this.props,disableAnimation=_this$props.disableAnimation,component=_this$props.component,placement=_this$props.placement,hideArrow=_this$props.hideArrow,status=_this$props.status,styles=_this$props.styles;var length=styles.arrow.length,floater=styles.floater,floaterCentered=styles.floaterCentered,floaterClosing=styles.floaterClosing,floaterOpening=styles.floaterOpening,floaterWithAnimation=styles.floaterWithAnimation,floaterWithComponent=styles.floaterWithComponent;var element={};if(!hideArrow){if(placement.startsWith('top')){element.padding=\"0 0 \".concat(length,\"px\");}else if(placement.startsWith('bottom')){element.padding=\"\".concat(length,\"px 0 0\");}else if(placement.startsWith('left')){element.padding=\"0 \".concat(length,\"px 0 0\");}else if(placement.startsWith('right')){element.padding=\"0 0 0 \".concat(length,\"px\");}}if([STATUS.OPENING,STATUS.OPEN].indexOf(status)!==-1){element=_objectSpread2(_objectSpread2({},element),floaterOpening);}if(status===STATUS.CLOSING){element=_objectSpread2(_objectSpread2({},element),floaterClosing);}if(status===STATUS.OPEN&&!disableAnimation){element=_objectSpread2(_objectSpread2({},element),floaterWithAnimation);}if(placement==='center'){element=_objectSpread2(_objectSpread2({},element),floaterCentered);}if(component){element=_objectSpread2(_objectSpread2({},element),floaterWithComponent);}return _objectSpread2(_objectSpread2({},floater),element);}},{key:\"render\",value:function render(){var _this$props2=this.props,component=_this$props2.component,closeFn=_this$props2.handleClick,hideArrow=_this$props2.hideArrow,setFloaterRef=_this$props2.setFloaterRef,status=_this$props2.status;var output={};var classes=['__floater'];if(component){if(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(component)){output.content=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(component,{closeFn:closeFn});}else {output.content=component({closeFn:closeFn});}}else {output.content=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FloaterContainer,this.props);}if(status===STATUS.OPEN){classes.push('__floater__open');}if(!hideArrow){output.arrow=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(FloaterArrow,this.props);}return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{ref:setFloaterRef,className:classes.join(' '),style:this.style},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\",{className:\"__floater__body\"},output.content,output.arrow));}}]);return Floater;}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));_defineProperty(Floater,\"propTypes\",{component:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().element)]),content:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),disableAnimation:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool).isRequired,footer:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),handleClick:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,hideArrow:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool).isRequired,open:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),placement:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,positionWrapper:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool).isRequired,setArrowRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,setFloaterRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,showCloseButton:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),status:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired,styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object).isRequired,title:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node)});\n\nvar ReactFloaterWrapper=/*#__PURE__*/function(_React$Component){_inherits(ReactFloaterWrapper,_React$Component);var _super=_createSuper(ReactFloaterWrapper);function ReactFloaterWrapper(){_classCallCheck(this,ReactFloaterWrapper);return _super.apply(this,arguments);}_createClass(ReactFloaterWrapper,[{key:\"render\",value:function render(){var _this$props=this.props,children=_this$props.children,handleClick=_this$props.handleClick,handleMouseEnter=_this$props.handleMouseEnter,handleMouseLeave=_this$props.handleMouseLeave,setChildRef=_this$props.setChildRef,setWrapperRef=_this$props.setWrapperRef,style=_this$props.style,styles=_this$props.styles;var element;/* istanbul ignore else */if(children){if(react__WEBPACK_IMPORTED_MODULE_0___default().Children.count(children)===1){if(!/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(children)){element=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\",null,children);}else {var refProp=is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"function\"](children.type)?'innerRef':'ref';element=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(react__WEBPACK_IMPORTED_MODULE_0___default().Children.only(children),_defineProperty({},refProp,setChildRef));}}else {element=children;}}if(!element){return null;}return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\",{ref:setWrapperRef,style:_objectSpread2(_objectSpread2({},styles),style),onClick:handleClick,onMouseEnter:handleMouseEnter,onMouseLeave:handleMouseLeave},element);}}]);return ReactFloaterWrapper;}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));_defineProperty(ReactFloaterWrapper,\"propTypes\",{children:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),handleClick:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,handleMouseEnter:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,handleMouseLeave:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,setChildRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,setWrapperRef:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func).isRequired,style:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object).isRequired});\n\nvar defaultOptions={zIndex:100};function getStyles(styles){var options=deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions,styles.options||{});return {wrapper:{cursor:'help',display:'inline-flex',flexDirection:'column',zIndex:options.zIndex},wrapperPosition:{left:-1000,position:'absolute',top:-1000,visibility:'hidden'},floater:{display:'inline-block',filter:'drop-shadow(0 0 3px rgba(0, 0, 0, 0.3))',maxWidth:300,opacity:0,position:'relative',transition:'opacity 0.3s',visibility:'hidden',zIndex:options.zIndex},floaterOpening:{opacity:1,visibility:'visible'},floaterWithAnimation:{opacity:1,transition:'opacity 0.3s, transform 0.2s',visibility:'visible'},floaterWithComponent:{maxWidth:'100%'},floaterClosing:{opacity:0,visibility:'visible'},floaterCentered:{left:'50%',position:'fixed',top:'50%',transform:'translate(-50%, -50%)'},container:{backgroundColor:'#fff',color:'#666',minHeight:60,minWidth:200,padding:20,position:'relative',zIndex:10},title:{borderBottom:'1px solid #555',color:'#555',fontSize:18,marginBottom:5,paddingBottom:6,paddingRight:18},content:{fontSize:15},close:{backgroundColor:'transparent',border:0,borderRadius:0,color:'#555',fontSize:0,height:15,outline:'none',padding:10,position:'absolute',right:0,top:0,width:15,WebkitAppearance:'none'},footer:{borderTop:'1px solid #ccc',fontSize:13,marginTop:10,paddingTop:5},arrow:{color:'#fff',display:'inline-flex',length:16,margin:8,position:'absolute',spread:32},options:options};}\n\nvar _excluded=[\"arrow\",\"flip\",\"offset\"];var POSITIONING_PROPS=['position','top','right','bottom','left'];var ReactFloater=/*#__PURE__*/function(_React$Component){_inherits(ReactFloater,_React$Component);var _super=_createSuper(ReactFloater);function ReactFloater(props){var _this;_classCallCheck(this,ReactFloater);_this=_super.call(this,props);/* istanbul ignore else */_defineProperty(_assertThisInitialized(_this),\"setArrowRef\",function(ref){_this.arrowRef=ref;});_defineProperty(_assertThisInitialized(_this),\"setChildRef\",function(ref){_this.childRef=ref;});_defineProperty(_assertThisInitialized(_this),\"setFloaterRef\",function(ref){_this.floaterRef=ref;});_defineProperty(_assertThisInitialized(_this),\"setWrapperRef\",function(ref){_this.wrapperRef=ref;});_defineProperty(_assertThisInitialized(_this),\"handleTransitionEnd\",function(){var status=_this.state.status;var callback=_this.props.callback;/* istanbul ignore else */if(_this.wrapperPopper){_this.wrapperPopper.instance.update();}_this.setState({status:status===STATUS.OPENING?STATUS.OPEN:STATUS.IDLE},function(){var newStatus=_this.state.status;callback(newStatus===STATUS.OPEN?'open':'close',_this.props);});});_defineProperty(_assertThisInitialized(_this),\"handleClick\",function(){var _this$props=_this.props,event=_this$props.event,open=_this$props.open;if(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open))return;var _this$state=_this.state,positionWrapper=_this$state.positionWrapper,status=_this$state.status;/* istanbul ignore else */if(_this.event==='click'||_this.event==='hover'&&positionWrapper){log({title:'click',data:[{event:event,status:status===STATUS.OPEN?'closing':'opening'}],debug:_this.debug});_this.toggle();}});_defineProperty(_assertThisInitialized(_this),\"handleMouseEnter\",function(){var _this$props2=_this.props,event=_this$props2.event,open=_this$props2.open;if(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open)||isMobile())return;var status=_this.state.status;/* istanbul ignore else */if(_this.event==='hover'&&status===STATUS.IDLE){log({title:'mouseEnter',data:[{key:'originalEvent',value:event}],debug:_this.debug});clearTimeout(_this.eventDelayTimeout);_this.toggle();}});_defineProperty(_assertThisInitialized(_this),\"handleMouseLeave\",function(){var _this$props3=_this.props,event=_this$props3.event,eventDelay=_this$props3.eventDelay,open=_this$props3.open;if(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open)||isMobile())return;var _this$state2=_this.state,status=_this$state2.status,positionWrapper=_this$state2.positionWrapper;/* istanbul ignore else */if(_this.event==='hover'){log({title:'mouseLeave',data:[{key:'originalEvent',value:event}],debug:_this.debug});if(!eventDelay){_this.toggle(STATUS.IDLE);}else if([STATUS.OPENING,STATUS.OPEN].indexOf(status)!==-1&&!positionWrapper&&!_this.eventDelayTimeout){_this.eventDelayTimeout=setTimeout(function(){delete _this.eventDelayTimeout;_this.toggle();},eventDelay*1000);}}});_this.state={currentPlacement:props.placement,needsUpdate:false,positionWrapper:props.wrapperOptions.position&&!!props.target,status:STATUS.INIT,statusWrapper:STATUS.INIT};_this._isMounted=false;_this.hasMounted=false;if(canUseDOM()){window.addEventListener('load',function(){if(_this.popper){_this.popper.instance.update();}if(_this.wrapperPopper){_this.wrapperPopper.instance.update();}});}return _this;}_createClass(ReactFloater,[{key:\"componentDidMount\",value:function componentDidMount(){if(!canUseDOM())return;var positionWrapper=this.state.positionWrapper;var _this$props5=this.props,children=_this$props5.children,open=_this$props5.open,target=_this$props5.target;this._isMounted=true;log({title:'init',data:{hasChildren:!!children,hasTarget:!!target,isControlled:is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open),positionWrapper:positionWrapper,target:this.target,floater:this.floaterRef},debug:this.debug});if(!this.hasMounted){this.initPopper();this.hasMounted=true;}if(!children&&target&&!is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open));}},{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps,prevState){if(!canUseDOM())return;var _this$props6=this.props,autoOpen=_this$props6.autoOpen,open=_this$props6.open,target=_this$props6.target,wrapperOptions=_this$props6.wrapperOptions;var _treeChanges=(0,tree_changes__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(prevState,this.state),changedFrom=_treeChanges.changedFrom,changed=_treeChanges.changed;if(prevProps.open!==open){var forceStatus;// always follow `open` in controlled mode\nif(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"][\"boolean\"](open)){forceStatus=open?STATUS.OPENING:STATUS.CLOSING;}this.toggle(forceStatus);}if(prevProps.wrapperOptions.position!==wrapperOptions.position||prevProps.target!==target){this.changeWrapperPosition(this.props);}if(changed('status',STATUS.IDLE)&&open){this.toggle(STATUS.OPEN);}else if(changedFrom('status',STATUS.INIT,STATUS.IDLE)&&autoOpen){this.toggle(STATUS.OPEN);}if(this.popper&&changed('status',STATUS.OPENING)){this.popper.instance.update();}if(this.floaterRef&&(changed('status',STATUS.OPENING)||changed('status',STATUS.CLOSING))){once(this.floaterRef,'transitionend',this.handleTransitionEnd);}if(changed('needsUpdate',true)){this.rebuildPopper();}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){if(!canUseDOM())return;this._isMounted=false;if(this.popper){this.popper.instance.destroy();}if(this.wrapperPopper){this.wrapperPopper.instance.destroy();}}},{key:\"initPopper\",value:function initPopper(){var _this2=this;var target=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.target;var positionWrapper=this.state.positionWrapper;var _this$props7=this.props,disableFlip=_this$props7.disableFlip,getPopper=_this$props7.getPopper,hideArrow=_this$props7.hideArrow,offset=_this$props7.offset,placement=_this$props7.placement,wrapperOptions=_this$props7.wrapperOptions;var flipBehavior=placement==='top'||placement==='bottom'?'flip':['right','bottom-end','top-end','left','top-start','bottom-start'];/* istanbul ignore else */if(placement==='center'){this.setState({status:STATUS.IDLE});}else if(target&&this.floaterRef){var _this$options=this.options,arrow=_this$options.arrow,flip=_this$options.flip,offsetOptions=_this$options.offset,rest=_objectWithoutProperties(_this$options,_excluded);new popper_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](target,this.floaterRef,{placement:placement,modifiers:_objectSpread2({arrow:_objectSpread2({enabled:!hideArrow,element:this.arrowRef},arrow),flip:_objectSpread2({enabled:!disableFlip,behavior:flipBehavior},flip),offset:_objectSpread2({offset:\"0, \".concat(offset,\"px\")},offsetOptions)},rest),onCreate:function onCreate(data){var _this2$floaterRef;_this2.popper=data;if(!((_this2$floaterRef=_this2.floaterRef)!==null&&_this2$floaterRef!==void 0&&_this2$floaterRef.isConnected)){_this2.setState({needsUpdate:true});return;}getPopper(data,'floater');if(_this2._isMounted){_this2.setState({currentPlacement:data.placement,status:STATUS.IDLE});}if(placement!==data.placement){setTimeout(function(){data.instance.update();},1);}},onUpdate:function onUpdate(data){_this2.popper=data;var currentPlacement=_this2.state.currentPlacement;if(_this2._isMounted&&data.placement!==currentPlacement){_this2.setState({currentPlacement:data.placement});}}});}if(positionWrapper){var wrapperOffset=!is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"].undefined(wrapperOptions.offset)?wrapperOptions.offset:0;new popper_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.target,this.wrapperRef,{placement:wrapperOptions.placement||placement,modifiers:{arrow:{enabled:false},offset:{offset:\"0, \".concat(wrapperOffset,\"px\")},flip:{enabled:false}},onCreate:function onCreate(data){_this2.wrapperPopper=data;if(_this2._isMounted){_this2.setState({statusWrapper:STATUS.IDLE});}getPopper(data,'wrapper');if(placement!==data.placement){setTimeout(function(){data.instance.update();},1);}}});}}},{key:\"rebuildPopper\",value:function rebuildPopper(){var _this3=this;this.floaterRefInterval=setInterval(function(){var _this3$floaterRef;if((_this3$floaterRef=_this3.floaterRef)!==null&&_this3$floaterRef!==void 0&&_this3$floaterRef.isConnected){clearInterval(_this3.floaterRefInterval);_this3.setState({needsUpdate:false});_this3.initPopper();}},50);}},{key:\"changeWrapperPosition\",value:function changeWrapperPosition(_ref){var target=_ref.target,wrapperOptions=_ref.wrapperOptions;this.setState({positionWrapper:wrapperOptions.position&&!!target});}},{key:\"toggle\",value:function toggle(forceStatus){var status=this.state.status;var nextStatus=status===STATUS.OPEN?STATUS.CLOSING:STATUS.OPENING;if(!is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"].undefined(forceStatus)){nextStatus=forceStatus;}this.setState({status:nextStatus});}},{key:\"debug\",get:function get(){var debug=this.props.debug;return debug||canUseDOM()&&'ReactFloaterDebug'in window&&!!window.ReactFloaterDebug;}},{key:\"event\",get:function get(){var _this$props8=this.props,disableHoverToClick=_this$props8.disableHoverToClick,event=_this$props8.event;if(event==='hover'&&isMobile()&&!disableHoverToClick){return 'click';}return event;}},{key:\"options\",get:function get(){var options=this.props.options;return deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(DEFAULTS,options||{});}},{key:\"styles\",get:function get(){var _this4=this;var _this$state3=this.state,status=_this$state3.status,positionWrapper=_this$state3.positionWrapper,statusWrapper=_this$state3.statusWrapper;var styles=this.props.styles;var nextStyles=deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(getStyles(styles),styles);if(positionWrapper){var wrapperStyles;if(!([STATUS.IDLE].indexOf(status)!==-1)||!([STATUS.IDLE].indexOf(statusWrapper)!==-1)){wrapperStyles=nextStyles.wrapperPosition;}else {wrapperStyles=this.wrapperPopper.styles;}nextStyles.wrapper=_objectSpread2(_objectSpread2({},nextStyles.wrapper),wrapperStyles);}/* istanbul ignore else */if(this.target){var targetStyles=window.getComputedStyle(this.target);/* istanbul ignore else */if(this.wrapperStyles){nextStyles.wrapper=_objectSpread2(_objectSpread2({},nextStyles.wrapper),this.wrapperStyles);}else if(!(['relative','static'].indexOf(targetStyles.position)!==-1)){this.wrapperStyles={};if(!positionWrapper){POSITIONING_PROPS.forEach(function(d){_this4.wrapperStyles[d]=targetStyles[d];});nextStyles.wrapper=_objectSpread2(_objectSpread2({},nextStyles.wrapper),this.wrapperStyles);this.target.style.position='relative';this.target.style.top='auto';this.target.style.right='auto';this.target.style.bottom='auto';this.target.style.left='auto';}}}return nextStyles;}},{key:\"target\",get:function get(){if(!canUseDOM())return null;var target=this.props.target;if(target){if(is_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"].domElement(target)){return target;}return document.querySelector(target);}return this.childRef||this.wrapperRef;}},{key:\"render\",value:function render(){var _this$state4=this.state,currentPlacement=_this$state4.currentPlacement,positionWrapper=_this$state4.positionWrapper,status=_this$state4.status;var _this$props9=this.props,children=_this$props9.children,component=_this$props9.component,content=_this$props9.content,disableAnimation=_this$props9.disableAnimation,footer=_this$props9.footer,hideArrow=_this$props9.hideArrow,id=_this$props9.id,open=_this$props9.open,showCloseButton=_this$props9.showCloseButton,style=_this$props9.style,target=_this$props9.target,title=_this$props9.title;var wrapper=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ReactFloaterWrapper,{handleClick:this.handleClick,handleMouseEnter:this.handleMouseEnter,handleMouseLeave:this.handleMouseLeave,setChildRef:this.setChildRef,setWrapperRef:this.setWrapperRef,style:style,styles:this.styles.wrapper},children);var output={};if(positionWrapper){output.wrapperInPortal=wrapper;}else {output.wrapperAsChildren=wrapper;}return/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\",null,/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ReactFloaterPortal,{hasChildren:!!children,id:id,placement:currentPlacement,setRef:this.setFloaterRef,target:target,zIndex:this.styles.options.zIndex},/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Floater,{component:component,content:content,disableAnimation:disableAnimation,footer:footer,handleClick:this.handleClick,hideArrow:hideArrow||currentPlacement==='center',open:open,placement:currentPlacement,positionWrapper:positionWrapper,setArrowRef:this.setArrowRef,setFloaterRef:this.setFloaterRef,showCloseButton:showCloseButton,status:status,styles:this.styles,title:title}),output.wrapperInPortal),output.wrapperAsChildren);}}]);return ReactFloater;}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));_defineProperty(ReactFloater,\"propTypes\",{autoOpen:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),callback:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),children:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),component:isRequiredIf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().element)]),function(props){return !props.content;}),content:isRequiredIf((prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),function(props){return !props.component;}),debug:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),disableAnimation:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),disableFlip:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),disableHoverToClick:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),event:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOf(['hover','click']),eventDelay:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number),footer:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),getPopper:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().func),hideArrow:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),id:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number)]),offset:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number),open:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),options:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),placement:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOf(['top','top-start','top-end','bottom','bottom-start','bottom-end','left','left-start','left-end','right','right-start','right-end','auto','center']),showCloseButton:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool),style:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),styles:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),target:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().object),(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string)]),title:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().node),wrapperOptions:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({offset:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().number),placement:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOf(['top','top-start','top-end','bottom','bottom-start','bottom-end','left','left-start','left-end','right','right-start','right-end','auto']),position:(prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool)})});_defineProperty(ReactFloater,\"defaultProps\",{autoOpen:false,callback:noop,debug:false,disableAnimation:false,disableFlip:false,disableHoverToClick:false,event:'click',eventDelay:0.4,getPopper:noop,hideArrow:false,offset:15,placement:'bottom',showCloseButton:false,styles:{},target:null,wrapperOptions:{position:false}});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ1M7QUFDSjtBQUNHO0FBQ1Q7QUFDYztBQUNOOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE1BQU0sV0FBVyxrQkFBa0I7O0FBRW5ELGdKQUFnSixpR0FBaUcsZ0VBQWdFLGlDQUFpQyxrQkFBa0Isa0NBQWtDLGdEQUFnRCw4QkFBOEIsMkJBQTJCLGNBQWMsb0NBQW9DLG1EQUFtRCxnRUFBZ0UsWUFBWSwyQkFBMkIsbUlBQW1JLDREQUE0RCxzQ0FBc0Msa0RBQWtELGdEQUFnRCxpREFBaUQsdURBQXVELG1EQUFtRCw4Q0FBOEMscUVBQXFFLFVBQVUsUUFBUSw4QkFBOEIsMkRBQTJELCtCQUErQixnRkFBZ0YsK0RBQStEO0FBQ3ppRDs7QUFFQSxjQUFjOztBQUVkLGNBQWMsbURBQXFCLGFBQWEscUJBQXFCLHdGQUF3RixvQkFBb0Isa0VBQWtFO0FBQ25QO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsc0JBQXNCLGlLQUFpSyxzRkFBc0YsdUJBQXVCLDBFQUEwRSxtQkFBbUIsZ0JBQWdCLEdBQUcsd0JBQXdCLHlCQUF5QixHQUFHLCtDQUFFLHdCQUF3QixzQ0FBc0MsTUFBTSwyQkFBMkIsR0FBRyxNQUFNLDZCQUE2QixvQkFBb0Isb0JBQW9CLDhCQUE4Qiw0RUFBNEUsNENBQTRDLCtCQUErQiw0RUFBNEUsK0NBQStDLGdDQUFnQyw0RUFBNEUsWUFBWTtBQUMvaEMsMkJBQTJCLE1BQU0sNkJBQTZCLG1DQUFtQzs7QUFFakcsK0RBQStELCtDQUErQyw0Q0FBNEMsOEJBQThCLHlDQUF5QyxxQ0FBcUMsa0NBQWtDLDJEQUEyRCx1QkFBdUIsZUFBZSxtQkFBbUIsZUFBZSx1QkFBdUIsRUFBRSw2REFBNkQsdUJBQXVCLGVBQWUsdUJBQXVCLEVBQUUsaUVBQWlFLG1DQUFtQyxlQUFlLDZEQUErQixhQUFhLG9EQUFvRCxxQ0FBcUMsdUJBQXVCLEVBQUUsNkNBQTZDLHVFQUF1RSxlQUFlLHdDQUF3QyxpQ0FBaUMsaUJBQWlCLFdBQVcsK0JBQStCLHdDQUF3QyxFQUFFLGlEQUFpRCw0QkFBNEIsc0ZBQXNGLGVBQWUsbUJBQW1CLHdDQUF3QyxtQkFBbUIsbURBQXFCLHNCQUFzQixXQUFXLDBFQUE0QyxxQ0FBcUMsMERBQW1CLDZDQUE2QyxlQUFlLGNBQWMsRUFBRSxtREFBbUQsNkhBQTZILGlCQUFpQixpQ0FBaUMsNEJBQTRCLGFBQWEsNkJBQTZCLEVBQUUscUNBQXFDLGVBQWUsYUFBYSw4QkFBOEIsR0FBRywyQkFBMkIsQ0FBQyx3REFBZSxFQUFFLGdEQUFnRCxTQUFTLDJEQUFtQixFQUFFLDJEQUFpQixDQUFDLHlEQUFlLGVBQWUsd0RBQWMsSUFBSSwyREFBbUIsRUFBRSwwREFBZ0IsQ0FBQywwREFBZ0IsYUFBYSwwREFBZ0IsUUFBUSx3REFBYyxtQkFBbUIsMkRBQW1CLEVBQUUsMERBQWdCLENBQUMsMERBQWdCLFVBQVUsMERBQWdCLENBQUM7O0FBRTkzRSx5REFBeUQseUNBQXlDLHNDQUFzQyx3QkFBd0IsbUNBQW1DLHFDQUFxQyw0QkFBNEIscUNBQXFDLHFGQUFxRiwrQkFBK0IsV0FBVyx1REFBdUQsMERBQTBELGVBQWUsYUFBYSxjQUFjLHFCQUFxQix3Q0FBd0MsYUFBYSxjQUFjLFlBQVkscUJBQXFCLHNDQUFzQyxjQUFjLFlBQVksZ0JBQWdCLHVDQUF1QyxhQUFhLGFBQWEsZUFBZSxFQUFFLHFDQUFxQyw2SEFBNkgsMk1BQTJNLGlCQUFpQixtQ0FBbUMsV0FBVyxhQUFhLGFBQWEsMERBQTBELDJEQUEyRCxxQkFBcUIsOEJBQThCLGdDQUFnQyx3Q0FBd0Msb0VBQW9FLGtCQUFrQiw4QkFBOEIsZ0NBQWdDLHNDQUFzQyxTQUFTLFNBQVMsd0RBQXdELG9CQUFvQiw2QkFBNkIsaUNBQWlDLHVDQUF1QyxTQUFTLFNBQVMsb0VBQW9FLG1CQUFtQiw2QkFBNkIsaUNBQWlDLG1CQUFtQiwwREFBbUIsUUFBUSxvREFBb0QsY0FBYywwREFBbUIsU0FBUyxrQ0FBa0MsY0FBYywwREFBbUIsUUFBUSxrRUFBa0UsY0FBYywwREFBbUIsWUFBWSx5QkFBeUIsT0FBTyxHQUFHLHFCQUFxQixDQUFDLHdEQUFlLEVBQUUsMENBQTBDLFVBQVUsMERBQWdCLHdCQUF3Qix3REFBYyxtQkFBbUIsMERBQWdCLFlBQVk7O0FBRWptRiwyQ0FBMkMsK0JBQStCLG9EQUFvRCxrSEFBa0gsbUJBQW1CLDBEQUFtQixXQUFXLG1FQUFtRSxjQUFjLDBEQUFtQixRQUFRLDhKQUE4SixjQUFjLDBEQUFtQix1QkFBdUIsMERBQW1CLFNBQVMsNDdCQUE0N0IsTUFBTSwyQkFBMkIsWUFBWSx3REFBYyxtQkFBbUIsMERBQWdCOztBQUV6cEQsZ0NBQWdDLHNNQUFzTSxZQUFZLHFCQUFxQiwyREFBb0IsK0JBQStCLDBEQUFtQixRQUFRLG9EQUFvRCxXQUFXLFVBQVUsMEJBQTBCLDJEQUFvQiwyQkFBMkIsMERBQW1CLFFBQVEsZ0RBQWdELFNBQVMsV0FBVywyQkFBMkIsMkRBQW9CLDZCQUE2QiwwREFBbUIsUUFBUSxrREFBa0QsVUFBVSx3Q0FBd0MsK0NBQUUsbUJBQW1CLDBCQUEwQiwwREFBbUIsa0JBQWtCLDRDQUE0QyxHQUFHLG1CQUFtQiwwREFBbUIsUUFBUSx3REFBd0QsMERBQTBELDRCQUE0QixRQUFRLHdEQUFjLG1CQUFtQix3REFBYyxhQUFhLHdEQUFjLGlCQUFpQix3REFBYyxpQkFBaUIsd0RBQWMsNEJBQTRCLHdEQUFjLG1CQUFtQiwwREFBZ0Isa0JBQWtCLHdEQUFjOztBQUU3MEMsb0RBQW9ELG9DQUFvQyxpQ0FBaUMsbUJBQW1CLDhCQUE4QixxQ0FBcUMsdUJBQXVCLCtCQUErQiw2TkFBNk4seVFBQXlRLGVBQWUsZUFBZSxnQ0FBZ0MsNENBQTRDLHdDQUF3Qyw0Q0FBNEMsc0NBQXNDLDhDQUE4Qyx1Q0FBdUMsK0NBQStDLHNEQUFzRCx3Q0FBd0MsMkJBQTJCLDRCQUE0Qix3Q0FBd0MsMkJBQTJCLDRDQUE0Qyx3Q0FBd0MsaUNBQWlDLHlCQUF5Qix3Q0FBd0MsNEJBQTRCLGNBQWMsd0NBQXdDLGlDQUFpQyx1Q0FBdUMscUJBQXFCLEVBQUUscUNBQXFDLG1NQUFtTSxjQUFjLDBCQUEwQixjQUFjLGdCQUFnQiwyREFBb0IsYUFBYSw0QkFBNEIseURBQWtCLFlBQVksZ0JBQWdCLEdBQUcsTUFBTSwwQkFBMEIsZ0JBQWdCLElBQUksTUFBTSw0QkFBNEIsMERBQW1CLCtCQUErQix5QkFBeUIsaUNBQWlDLGVBQWUsMEJBQTBCLDBEQUFtQiwyQkFBMkIsbUJBQW1CLDBEQUFtQixRQUFRLCtEQUErRCxjQUFjLDBEQUFtQixRQUFRLDRCQUE0QixpQ0FBaUMsR0FBRyxnQkFBZ0IsQ0FBQyx3REFBZSxFQUFFLHFDQUFxQyxVQUFVLDJEQUFtQixFQUFFLHdEQUFjLENBQUMsMkRBQWlCLFdBQVcsd0RBQWMsa0JBQWtCLHdEQUFjLG1CQUFtQix3REFBYyxhQUFhLHdEQUFjLHNCQUFzQix3REFBYyxpQkFBaUIsd0RBQWMsV0FBVywwREFBZ0IsNEJBQTRCLHdEQUFjLHdCQUF3Qix3REFBYywwQkFBMEIsd0RBQWMsNEJBQTRCLHdEQUFjLFFBQVEsMERBQWdCLG1CQUFtQiwwREFBZ0Isa0JBQWtCLHdEQUFjLENBQUM7O0FBRXBuRyxnRUFBZ0UsZ0RBQWdELDZDQUE2QywrQkFBK0IsMENBQTBDLHFDQUFxQyxtQ0FBbUMscUNBQXFDLHVUQUF1VCxZQUFZLHVDQUF1QyxHQUFHLHFEQUFjLHNCQUFzQixpQkFBaUIsMkRBQW9CLFlBQVkscUJBQXFCLDBEQUFtQix3QkFBd0IsTUFBTSxZQUFZLCtDQUFFLDZDQUE2QyxxQkFBcUIseURBQWtCLENBQUMscURBQWMsa0NBQWtDLHlCQUF5QixNQUFNLG1CQUFtQixhQUFhLGFBQWEsbUJBQW1CLDBEQUFtQixTQUFTLHdEQUF3RCxnR0FBZ0csWUFBWSxHQUFHLDRCQUE0QixDQUFDLHdEQUFlLEVBQUUsaURBQWlELFNBQVMsd0RBQWMsYUFBYSx3REFBYyw2QkFBNkIsd0RBQWMsNkJBQTZCLHdEQUFjLHdCQUF3Qix3REFBYywwQkFBMEIsd0RBQWMsa0JBQWtCLDBEQUFnQixRQUFRLDBEQUFnQixZQUFZOztBQUUzb0Qsb0JBQW9CLFlBQVksMkJBQTJCLFlBQVksZ0RBQVMsa0NBQWtDLEVBQUUsUUFBUSxTQUFTLGlGQUFpRixrQkFBa0IsNkRBQTZELFVBQVUsdUxBQXVMLGlCQUFpQiwrQkFBK0IsdUJBQXVCLHlFQUF5RSx1QkFBdUIsZ0JBQWdCLGlCQUFpQiwrQkFBK0Isa0JBQWtCLHdFQUF3RSxZQUFZLHVHQUF1RyxRQUFRLHNHQUFzRyxVQUFVLFlBQVksUUFBUSxxTEFBcUwsU0FBUyxpRUFBaUUsUUFBUSxvRkFBb0Y7O0FBRWo0Qyx3Q0FBd0MsaUVBQWlFLHlEQUF5RCx5Q0FBeUMsc0NBQXNDLDZCQUE2QixVQUFVLG1DQUFtQyw4QkFBOEIsb0dBQW9HLG9CQUFvQixFQUFFLDBFQUEwRSxvQkFBb0IsRUFBRSw0RUFBNEUsc0JBQXNCLEVBQUUsNEVBQTRFLHNCQUFzQixFQUFFLCtFQUErRSw4QkFBOEIsa0NBQWtDLGtEQUFrRCx1Q0FBdUMsZ0JBQWdCLHVEQUF1RCxZQUFZLGlDQUFpQyw4REFBOEQsR0FBRyxFQUFFLHVFQUF1RSwwRUFBMEUsR0FBRywrQ0FBRSx5QkFBeUIsa0dBQWtHLDRGQUE0RixLQUFLLHFCQUFxQiw0REFBNEQsb0JBQW9CLEVBQUUsaUJBQWlCLEVBQUUsNEVBQTRFLDZFQUE2RSxHQUFHLCtDQUFFLHFDQUFxQyw4QkFBOEIsMEVBQTBFLEtBQUssMEJBQTBCLGdDQUFnQyxvQkFBb0IsRUFBRSxzQ0FBc0MsaUJBQWlCLEVBQUUsNEVBQTRFLGdIQUFnSCxHQUFHLCtDQUFFLHFDQUFxQyxxR0FBcUcsb0RBQW9ELEtBQUssMEJBQTBCLGdDQUFnQyxvQkFBb0IsRUFBRSxnQkFBZ0IsMkJBQTJCLHVHQUF1Ryw4Q0FBOEMsK0JBQStCLGdCQUFnQixxQkFBcUIsRUFBRSxhQUFhLCtKQUErSix1QkFBdUIsdUJBQXVCLGdCQUFnQiwwQ0FBMEMsaUJBQWlCLGdDQUFnQyx3QkFBd0Isd0NBQXdDLEdBQUcsY0FBYyw0QkFBNEIsMkRBQTJELHVCQUF1QiwrQ0FBK0MsNkdBQTZHLHFCQUFxQixLQUFLLG1CQUFtQix1REFBdUQsK0NBQUUsNkZBQTZGLGtCQUFrQixFQUFFLHFCQUFxQixrQkFBa0Isc0JBQXNCLHVCQUF1QiwrQ0FBRSxxQkFBcUIsRUFBRSxnRkFBZ0YsdUJBQXVCLHdKQUF3SixpQkFBaUIsd0RBQVcseUZBQXlGLDBCQUEwQixnQkFBZ0I7QUFDM3BJLEdBQUcsK0NBQUUsbUJBQW1CLGdEQUFnRCwwQkFBMEIsMkZBQTJGLHdDQUF3Qyx3Q0FBd0MsMEJBQTBCLGlFQUFpRSwwQkFBMEIsa0RBQWtELCtCQUErQiwwRkFBMEYsZ0VBQWdFLGdDQUFnQyx3QkFBd0IsRUFBRSxpRUFBaUUsdUJBQXVCLHNCQUFzQixnQkFBZ0IsZ0NBQWdDLHVCQUF1Qix5Q0FBeUMsRUFBRSw2Q0FBNkMsZ0JBQWdCLGlGQUFpRiwrQ0FBK0MsME9BQTBPLG1JQUFtSSxtREFBbUQsZUFBZSxtQkFBbUIsR0FBRyxpQ0FBaUMsMktBQTJLLElBQUksaURBQU0seUJBQXlCLDhDQUE4QyxzQkFBc0IseUNBQXlDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLGlDQUFpQyxnQkFBZ0Isd0NBQXdDLHNCQUFzQixtQkFBbUIsK0dBQStHLGlCQUFpQixpQkFBaUIsRUFBRSxRQUFRLDBCQUEwQixzQkFBc0IsaUJBQWlCLG1EQUFtRCxHQUFHLCtCQUErQixzQkFBc0Isd0JBQXdCLE1BQU0sa0NBQWtDLG1CQUFtQixtREFBbUQseURBQXlELGlCQUFpQixnQ0FBZ0MsS0FBSyxHQUFHLG9CQUFvQixtQkFBbUIsK0NBQUUsMERBQTBELElBQUksaURBQU0sOEJBQThCLHlEQUF5RCxPQUFPLGNBQWMsU0FBUyx3Q0FBd0MsT0FBTyxlQUFlLGtDQUFrQywwQkFBMEIsc0JBQXNCLGlCQUFpQiwwQkFBMEIsR0FBRywwQkFBMEIsK0JBQStCLHNCQUFzQix3QkFBd0IsT0FBTyxLQUFLLEVBQUUsbURBQW1ELGdCQUFnQiwrQ0FBK0Msc0JBQXNCLDRHQUE0Ryx5Q0FBeUMsaUJBQWlCLGtCQUFrQixFQUFFLHNCQUFzQixPQUFPLEVBQUUsdUVBQXVFLDBEQUEwRCxlQUFlLGtEQUFrRCxJQUFJLEVBQUUsZ0RBQWdELDZCQUE2QixrRUFBa0UsSUFBSSwrQ0FBRSx5QkFBeUIsd0JBQXdCLGVBQWUsa0JBQWtCLElBQUksRUFBRSwrQkFBK0IsMkJBQTJCLHNGQUFzRixFQUFFLCtCQUErQiwwR0FBMEcsc0RBQXNELGdCQUFnQixlQUFlLEVBQUUsaUNBQWlDLCtCQUErQixPQUFPLGdEQUFTLHFCQUFxQixJQUFJLEVBQUUsZ0NBQWdDLGdCQUFnQiw2SUFBNkksNkJBQTZCLGVBQWUsZ0RBQVMsMkJBQTJCLG9CQUFvQixrQkFBa0Isd0ZBQXdGLDBDQUEwQyxNQUFNLHlDQUF5QyxtREFBbUQscUNBQXFDLDBDQUEwQyxzREFBc0QsaURBQWlELG1EQUFtRCwwQ0FBMEMsc0VBQXNFLHNCQUFzQixxQkFBcUIsc0NBQXNDLHlDQUF5QyxFQUFFLG1EQUFtRCx5Q0FBeUMsc0NBQXNDLDZCQUE2QiwrQkFBK0IsZ0NBQWdDLGlDQUFpQyxvQkFBb0IsRUFBRSxnQ0FBZ0MsNEJBQTRCLDZCQUE2QixXQUFXLEdBQUcsK0NBQUUscUJBQXFCLGVBQWUsdUNBQXVDLHdDQUF3QyxFQUFFLHFDQUFxQyxtSkFBbUosd1lBQXdZLHlCQUF5QiwwREFBbUIsc0JBQXNCLGdOQUFnTixXQUFXLGNBQWMsb0JBQW9CLGdDQUFnQyxNQUFNLGtDQUFrQyxtQkFBbUIsMERBQW1CLDBCQUEwQiwwREFBbUIscUJBQXFCLGtJQUFrSSxjQUFjLDBEQUFtQixVQUFVLGtYQUFrWCxzREFBc0QsR0FBRyxxQkFBcUIsQ0FBQyx3REFBZSxFQUFFLDBDQUEwQyxTQUFTLHdEQUFjLFVBQVUsd0RBQWMsVUFBVSx3REFBYyx3QkFBd0IsMkRBQW1CLEVBQUUsd0RBQWMsQ0FBQywyREFBaUIsbUJBQW1CLHVCQUF1Qix1QkFBdUIsd0RBQWMsaUJBQWlCLHlCQUF5QixRQUFRLHdEQUFjLGtCQUFrQix3REFBYyxhQUFhLHdEQUFjLHFCQUFxQix3REFBYyxPQUFPLHVEQUFlLCtCQUErQiwwREFBZ0IsUUFBUSx3REFBYyxXQUFXLHdEQUFjLFdBQVcsd0RBQWMsSUFBSSwyREFBbUIsRUFBRSwwREFBZ0IsQ0FBQywwREFBZ0IsVUFBVSwwREFBZ0IsTUFBTSx3REFBYyxTQUFTLDBEQUFnQixXQUFXLHVEQUFlLHNLQUFzSyx3REFBYyxPQUFPLDBEQUFnQixRQUFRLDBEQUFnQixRQUFRLDJEQUFtQixFQUFFLDBEQUFnQixDQUFDLDBEQUFnQixTQUFTLHdEQUFjLGdCQUFnQix1REFBZSxFQUFFLE9BQU8sMERBQWdCLFdBQVcsdURBQWUsc0pBQXNKLHdEQUFjLENBQUMsRUFBRSxFQUFFLDZDQUE2QyxvT0FBb08sNkJBQTZCLGdCQUFnQjs7QUFFbGtTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL2VzL2luZGV4LmpzPzA0NGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgZGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgaXMgZnJvbSAnaXMtbGl0ZSc7XG5pbXBvcnQgdHJlZUNoYW5nZXMgZnJvbSAndHJlZS1jaGFuZ2VzJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG52YXIgREVGQVVMVFMgPSB7ZmxpcDp7cGFkZGluZzoyMH0scHJldmVudE92ZXJmbG93OntwYWRkaW5nOjEwfX07XG5cbnZhciBWQUxJREFUT1JfQVJHX0VSUk9SX01FU1NBR0U9J1RoZSB0eXBlVmFsaWRhdG9yIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiAnKyd3aXRoIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKS4nO3ZhciBNRVNTQUdFX0FSR19FUlJPUl9NRVNTQUdFPSdUaGUgZXJyb3IgbWVzc2FnZSBpcyBvcHRpb25hbCwgYnV0IG11c3QgYmUgYSBzdHJpbmcgaWYgcHJvdmlkZWQuJztmdW5jdGlvbiBwcm9wSXNSZXF1aXJlZChjb25kaXRpb24scHJvcHMscHJvcE5hbWUsY29tcG9uZW50TmFtZSl7aWYodHlwZW9mIGNvbmRpdGlvbj09PSdib29sZWFuJyl7cmV0dXJuIGNvbmRpdGlvbjt9aWYodHlwZW9mIGNvbmRpdGlvbj09PSdmdW5jdGlvbicpe3JldHVybiBjb25kaXRpb24ocHJvcHMscHJvcE5hbWUsY29tcG9uZW50TmFtZSk7fWlmKEJvb2xlYW4oY29uZGl0aW9uKT09PXRydWUpe3JldHVybiBCb29sZWFuKGNvbmRpdGlvbik7fXJldHVybiBmYWxzZTt9ZnVuY3Rpb24gcHJvcEV4aXN0cyhwcm9wcyxwcm9wTmFtZSl7cmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLHByb3BOYW1lKTt9ZnVuY3Rpb24gbWlzc2luZ1Byb3BFcnJvcihwcm9wcyxwcm9wTmFtZSxjb21wb25lbnROYW1lLG1lc3NhZ2Upe2lmKG1lc3NhZ2Upe3JldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7fXJldHVybiBuZXcgRXJyb3IoXCJSZXF1aXJlZCBcIi5jb25jYXQocHJvcHNbcHJvcE5hbWVdLFwiIGBcIikuY29uY2F0KHByb3BOYW1lLFwiYCB3YXMgbm90IHNwZWNpZmllZCBpbiBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLFwiYC5cIikpO31mdW5jdGlvbiBndWFyZEFnYWluc3RJbnZhbGlkQXJnVHlwZXModHlwZVZhbGlkYXRvcixtZXNzYWdlKXtpZih0eXBlb2YgdHlwZVZhbGlkYXRvciE9PSdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoVkFMSURBVE9SX0FSR19FUlJPUl9NRVNTQUdFKTt9aWYoQm9vbGVhbihtZXNzYWdlKSYmdHlwZW9mIG1lc3NhZ2UhPT0nc3RyaW5nJyl7dGhyb3cgbmV3IFR5cGVFcnJvcihNRVNTQUdFX0FSR19FUlJPUl9NRVNTQUdFKTt9fWZ1bmN0aW9uIGlzUmVxdWlyZWRJZih0eXBlVmFsaWRhdG9yLGNvbmRpdGlvbixtZXNzYWdlKXtndWFyZEFnYWluc3RJbnZhbGlkQXJnVHlwZXModHlwZVZhbGlkYXRvcixtZXNzYWdlKTtyZXR1cm4gZnVuY3Rpb24ocHJvcHMscHJvcE5hbWUsY29tcG9uZW50TmFtZSl7Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgscmVzdD1uZXcgQXJyYXkoX2xlbj4zP19sZW4tMzowKSxfa2V5PTM7X2tleTxfbGVuO19rZXkrKyl7cmVzdFtfa2V5LTNdPWFyZ3VtZW50c1tfa2V5XTt9aWYocHJvcElzUmVxdWlyZWQoY29uZGl0aW9uLHByb3BzLHByb3BOYW1lLGNvbXBvbmVudE5hbWUpKXtpZihwcm9wRXhpc3RzKHByb3BzLHByb3BOYW1lKSl7cmV0dXJuIHR5cGVWYWxpZGF0b3IuYXBwbHkodm9pZCAwLFtwcm9wcyxwcm9wTmFtZSxjb21wb25lbnROYW1lXS5jb25jYXQocmVzdCkpO31yZXR1cm4gbWlzc2luZ1Byb3BFcnJvcihwcm9wcyxwcm9wTmFtZSxjb21wb25lbnROYW1lLG1lc3NhZ2UpO30vLyBJcyBub3QgcmVxdWlyZWQsIHNvIGp1c3QgcnVuIHR5cGVWYWxpZGF0b3IuXG5yZXR1cm4gdHlwZVZhbGlkYXRvci5hcHBseSh2b2lkIDAsW3Byb3BzLHByb3BOYW1lLGNvbXBvbmVudE5hbWVdLmNvbmNhdChyZXN0KSk7fTt9XG5cbnZhciBTVEFUVVMgPSB7SU5JVDonaW5pdCcsSURMRTonaWRsZScsT1BFTklORzonb3BlbmluZycsT1BFTjonb3BlbicsQ0xPU0lORzonY2xvc2luZycsRVJST1I6J2Vycm9yJ307XG5cbnZhciBpc1JlYWN0MTY9UmVhY3RET00uY3JlYXRlUG9ydGFsIT09dW5kZWZpbmVkO2Z1bmN0aW9uIGNhblVzZURPTSgpe3JldHVybiAhISh0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCcmJndpbmRvdy5kb2N1bWVudCYmd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO31mdW5jdGlvbiBpc01vYmlsZSgpe3JldHVybiAnb250b3VjaHN0YXJ0J2luIHdpbmRvdyYmL01vYmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7fS8qKlxuICogTG9nIG1ldGhvZCBjYWxscyBpZiBkZWJ1ZyBpcyBlbmFibGVkXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICBhcmcudGl0bGUgICAgLSBUaGUgdGl0bGUgdGhlIGxvZ2dlciB3YXMgY2FsbGVkIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBbYXJnLmRhdGFdICAgLSBUaGUgZGF0YSB0byBiZSBsb2dnZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICBbYXJnLndhcm5dICAtIElmIHRydWUsIHRoZSBtZXNzYWdlIHdpbGwgYmUgYSB3YXJuaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgW2FyZy5kZWJ1Z10gLSBOb3RoaW5nIHdpbGwgYmUgbG9nZ2VkIHVubGVzcyBkZWJ1ZyBpcyB0cnVlXG4gKi9mdW5jdGlvbiBsb2coX3JlZil7dmFyIHRpdGxlPV9yZWYudGl0bGUsZGF0YT1fcmVmLmRhdGEsX3JlZiR3YXJuPV9yZWYud2Fybix3YXJuPV9yZWYkd2Fybj09PXZvaWQgMD9mYWxzZTpfcmVmJHdhcm4sX3JlZiRkZWJ1Zz1fcmVmLmRlYnVnLGRlYnVnPV9yZWYkZGVidWc9PT12b2lkIDA/ZmFsc2U6X3JlZiRkZWJ1ZzsvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovdmFyIGxvZ0ZuPXdhcm4/Y29uc29sZS53YXJufHxjb25zb2xlLmVycm9yOmNvbnNvbGUubG9nO2lmKGRlYnVnJiZ0aXRsZSYmZGF0YSl7Y29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjcmVhY3QtZmxvYXRlcjogXCIuY29uY2F0KHRpdGxlKSwnY29sb3I6ICM5YjAwZmY7IGZvbnQtd2VpZ2h0OiBib2xkOyBmb250LXNpemU6IDEycHg7Jyk7aWYoQXJyYXkuaXNBcnJheShkYXRhKSl7ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpe2lmKGlzLnBsYWluT2JqZWN0KGQpJiZkLmtleSl7bG9nRm4uYXBwbHkoY29uc29sZSxbZC5rZXksZC52YWx1ZV0pO31lbHNlIHtsb2dGbi5hcHBseShjb25zb2xlLFtkXSk7fX0pO31lbHNlIHtsb2dGbi5hcHBseShjb25zb2xlLFtkYXRhXSk7fWNvbnNvbGUuZ3JvdXBFbmQoKTt9LyogZXNsaW50LWVuYWJsZSAqL31mdW5jdGlvbiBvbihlbGVtZW50LGV2ZW50LGNiKXt2YXIgY2FwdHVyZT1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106ZmFsc2U7ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LGNiLGNhcHR1cmUpO31mdW5jdGlvbiBvZmYoZWxlbWVudCxldmVudCxjYil7dmFyIGNhcHR1cmU9YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT11bmRlZmluZWQ/YXJndW1lbnRzWzNdOmZhbHNlO2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCxjYixjYXB0dXJlKTt9ZnVuY3Rpb24gb25jZShlbGVtZW50LGV2ZW50LGNiKXt2YXIgY2FwdHVyZT1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbM106ZmFsc2U7dmFyIF9uZXh0Q0I7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuX25leHRDQj1mdW5jdGlvbiBuZXh0Q0IoZSl7Y2IoZSk7b2ZmKGVsZW1lbnQsZXZlbnQsX25leHRDQik7fTtvbihlbGVtZW50LGV2ZW50LF9uZXh0Q0IsY2FwdHVyZSk7fWZ1bmN0aW9uIG5vb3AoKXt9XG5cbnZhciBSZWFjdEZsb2F0ZXJQb3J0YWw9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpe19pbmhlcml0cyhSZWFjdEZsb2F0ZXJQb3J0YWwsX1JlYWN0JENvbXBvbmVudCk7dmFyIF9zdXBlcj1fY3JlYXRlU3VwZXIoUmVhY3RGbG9hdGVyUG9ydGFsKTtmdW5jdGlvbiBSZWFjdEZsb2F0ZXJQb3J0YWwoKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxSZWFjdEZsb2F0ZXJQb3J0YWwpO3JldHVybiBfc3VwZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO31fY3JlYXRlQ2xhc3MoUmVhY3RGbG9hdGVyUG9ydGFsLFt7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpe2lmKCFjYW5Vc2VET00oKSlyZXR1cm47aWYoIXRoaXMubm9kZSl7dGhpcy5hcHBlbmROb2RlKCk7fWlmKCFpc1JlYWN0MTYpe3RoaXMucmVuZGVyUG9ydGFsKCk7fX19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKXtpZighY2FuVXNlRE9NKCkpcmV0dXJuO2lmKCFpc1JlYWN0MTYpe3RoaXMucmVuZGVyUG9ydGFsKCk7fX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7aWYoIWNhblVzZURPTSgpfHwhdGhpcy5ub2RlKXJldHVybjtpZighaXNSZWFjdDE2KXtSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMubm9kZSk7fWlmKHRoaXMubm9kZSYmdGhpcy5ub2RlLnBhcmVudE5vZGU9PT1kb2N1bWVudC5ib2R5KXtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7dGhpcy5ub2RlPXVuZGVmaW5lZDt9fX0se2tleTpcImFwcGVuZE5vZGVcIix2YWx1ZTpmdW5jdGlvbiBhcHBlbmROb2RlKCl7dmFyIF90aGlzJHByb3BzPXRoaXMucHJvcHMsaWQ9X3RoaXMkcHJvcHMuaWQsekluZGV4PV90aGlzJHByb3BzLnpJbmRleDtpZighdGhpcy5ub2RlKXt0aGlzLm5vZGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9pZihpZCl7dGhpcy5ub2RlLmlkPWlkO31pZih6SW5kZXgpe3RoaXMubm9kZS5zdHlsZS56SW5kZXg9ekluZGV4O31kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubm9kZSk7fX19LHtrZXk6XCJyZW5kZXJQb3J0YWxcIix2YWx1ZTpmdW5jdGlvbiByZW5kZXJQb3J0YWwoKXtpZighY2FuVXNlRE9NKCkpcmV0dXJuIG51bGw7dmFyIF90aGlzJHByb3BzMj10aGlzLnByb3BzLGNoaWxkcmVuPV90aGlzJHByb3BzMi5jaGlsZHJlbixzZXRSZWY9X3RoaXMkcHJvcHMyLnNldFJlZjtpZighdGhpcy5ub2RlKXt0aGlzLmFwcGVuZE5vZGUoKTt9LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9pZihpc1JlYWN0MTYpe3JldHVybi8qI19fUFVSRV9fKi9SZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sdGhpcy5ub2RlKTt9dmFyIHBvcnRhbD1SZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcih0aGlzLGNoaWxkcmVuLmxlbmd0aD4xPy8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbnVsbCxjaGlsZHJlbik6Y2hpbGRyZW5bMF0sdGhpcy5ub2RlKTtzZXRSZWYocG9ydGFsKTtyZXR1cm4gbnVsbDt9fSx7a2V5OlwicmVuZGVyUmVhY3QxNlwiLHZhbHVlOmZ1bmN0aW9uIHJlbmRlclJlYWN0MTYoKXt2YXIgX3RoaXMkcHJvcHMzPXRoaXMucHJvcHMsaGFzQ2hpbGRyZW49X3RoaXMkcHJvcHMzLmhhc0NoaWxkcmVuLHBsYWNlbWVudD1fdGhpcyRwcm9wczMucGxhY2VtZW50LHRhcmdldD1fdGhpcyRwcm9wczMudGFyZ2V0O2lmKCFoYXNDaGlsZHJlbil7aWYodGFyZ2V0fHxwbGFjZW1lbnQ9PT0nY2VudGVyJyl7cmV0dXJuIHRoaXMucmVuZGVyUG9ydGFsKCk7fXJldHVybiBudWxsO31yZXR1cm4gdGhpcy5yZW5kZXJQb3J0YWwoKTt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24gcmVuZGVyKCl7aWYoIWlzUmVhY3QxNil7cmV0dXJuIG51bGw7fXJldHVybiB0aGlzLnJlbmRlclJlYWN0MTYoKTt9fV0pO3JldHVybiBSZWFjdEZsb2F0ZXJQb3J0YWw7fShSZWFjdC5Db21wb25lbnQpO19kZWZpbmVQcm9wZXJ0eShSZWFjdEZsb2F0ZXJQb3J0YWwsXCJwcm9wVHlwZXNcIix7Y2hpbGRyZW46UHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsUHJvcFR5cGVzLmFycmF5XSksaGFzQ2hpbGRyZW46UHJvcFR5cGVzLmJvb2wsaWQ6UHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZyxQcm9wVHlwZXMubnVtYmVyXSkscGxhY2VtZW50OlByb3BUeXBlcy5zdHJpbmcsc2V0UmVmOlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsdGFyZ2V0OlByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsUHJvcFR5cGVzLnN0cmluZ10pLHpJbmRleDpQcm9wVHlwZXMubnVtYmVyfSk7XG5cbnZhciBGbG9hdGVyQXJyb3c9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpe19pbmhlcml0cyhGbG9hdGVyQXJyb3csX1JlYWN0JENvbXBvbmVudCk7dmFyIF9zdXBlcj1fY3JlYXRlU3VwZXIoRmxvYXRlckFycm93KTtmdW5jdGlvbiBGbG9hdGVyQXJyb3coKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxGbG9hdGVyQXJyb3cpO3JldHVybiBfc3VwZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO31fY3JlYXRlQ2xhc3MoRmxvYXRlckFycm93LFt7a2V5OlwicGFyZW50U3R5bGVcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIF90aGlzJHByb3BzPXRoaXMucHJvcHMscGxhY2VtZW50PV90aGlzJHByb3BzLnBsYWNlbWVudCxzdHlsZXM9X3RoaXMkcHJvcHMuc3R5bGVzO3ZhciBsZW5ndGg9c3R5bGVzLmFycm93Lmxlbmd0aDt2YXIgYXJyb3c9e3BvaW50ZXJFdmVudHM6J25vbmUnLHBvc2l0aW9uOidhYnNvbHV0ZScsd2lkdGg6JzEwMCUnfTsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKHBsYWNlbWVudC5zdGFydHNXaXRoKCd0b3AnKSl7YXJyb3cuYm90dG9tPTA7YXJyb3cubGVmdD0wO2Fycm93LnJpZ2h0PTA7YXJyb3cuaGVpZ2h0PWxlbmd0aDt9ZWxzZSBpZihwbGFjZW1lbnQuc3RhcnRzV2l0aCgnYm90dG9tJykpe2Fycm93LmxlZnQ9MDthcnJvdy5yaWdodD0wO2Fycm93LnRvcD0wO2Fycm93LmhlaWdodD1sZW5ndGg7fWVsc2UgaWYocGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2xlZnQnKSl7YXJyb3cucmlnaHQ9MDthcnJvdy50b3A9MDthcnJvdy5ib3R0b209MDt9ZWxzZSBpZihwbGFjZW1lbnQuc3RhcnRzV2l0aCgncmlnaHQnKSl7YXJyb3cubGVmdD0wO2Fycm93LnRvcD0wO31yZXR1cm4gYXJyb3c7fX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uIHJlbmRlcigpe3ZhciBfdGhpcyRwcm9wczI9dGhpcy5wcm9wcyxwbGFjZW1lbnQ9X3RoaXMkcHJvcHMyLnBsYWNlbWVudCxzZXRBcnJvd1JlZj1fdGhpcyRwcm9wczIuc2V0QXJyb3dSZWYsc3R5bGVzPV90aGlzJHByb3BzMi5zdHlsZXM7dmFyIF9zdHlsZXMkYXJyb3c9c3R5bGVzLmFycm93LGNvbG9yPV9zdHlsZXMkYXJyb3cuY29sb3IsZGlzcGxheT1fc3R5bGVzJGFycm93LmRpc3BsYXksbGVuZ3RoPV9zdHlsZXMkYXJyb3cubGVuZ3RoLG1hcmdpbj1fc3R5bGVzJGFycm93Lm1hcmdpbixwb3NpdGlvbj1fc3R5bGVzJGFycm93LnBvc2l0aW9uLHNwcmVhZD1fc3R5bGVzJGFycm93LnNwcmVhZDt2YXIgYXJyb3dTdHlsZXM9e2Rpc3BsYXk6ZGlzcGxheSxwb3NpdGlvbjpwb3NpdGlvbn07dmFyIHBvaW50czt2YXIgeD1zcHJlYWQ7dmFyIHk9bGVuZ3RoOy8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovaWYocGxhY2VtZW50LnN0YXJ0c1dpdGgoJ3RvcCcpKXtwb2ludHM9XCIwLDAgXCIuY29uY2F0KHgvMixcIixcIikuY29uY2F0KHksXCIgXCIpLmNvbmNhdCh4LFwiLDBcIik7YXJyb3dTdHlsZXMuYm90dG9tPTA7YXJyb3dTdHlsZXMubWFyZ2luTGVmdD1tYXJnaW47YXJyb3dTdHlsZXMubWFyZ2luUmlnaHQ9bWFyZ2luO31lbHNlIGlmKHBsYWNlbWVudC5zdGFydHNXaXRoKCdib3R0b20nKSl7cG9pbnRzPVwiXCIuY29uY2F0KHgsXCIsXCIpLmNvbmNhdCh5LFwiIFwiKS5jb25jYXQoeC8yLFwiLDAgMCxcIikuY29uY2F0KHkpO2Fycm93U3R5bGVzLnRvcD0wO2Fycm93U3R5bGVzLm1hcmdpbkxlZnQ9bWFyZ2luO2Fycm93U3R5bGVzLm1hcmdpblJpZ2h0PW1hcmdpbjt9ZWxzZSBpZihwbGFjZW1lbnQuc3RhcnRzV2l0aCgnbGVmdCcpKXt5PXNwcmVhZDt4PWxlbmd0aDtwb2ludHM9XCIwLDAgXCIuY29uY2F0KHgsXCIsXCIpLmNvbmNhdCh5LzIsXCIgMCxcIikuY29uY2F0KHkpO2Fycm93U3R5bGVzLnJpZ2h0PTA7YXJyb3dTdHlsZXMubWFyZ2luVG9wPW1hcmdpbjthcnJvd1N0eWxlcy5tYXJnaW5Cb3R0b209bWFyZ2luO31lbHNlIGlmKHBsYWNlbWVudC5zdGFydHNXaXRoKCdyaWdodCcpKXt5PXNwcmVhZDt4PWxlbmd0aDtwb2ludHM9XCJcIi5jb25jYXQoeCxcIixcIikuY29uY2F0KHksXCIgXCIpLmNvbmNhdCh4LFwiLDAgMCxcIikuY29uY2F0KHkvMik7YXJyb3dTdHlsZXMubGVmdD0wO2Fycm93U3R5bGVzLm1hcmdpblRvcD1tYXJnaW47YXJyb3dTdHlsZXMubWFyZ2luQm90dG9tPW1hcmdpbjt9cmV0dXJuLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiX19mbG9hdGVyX19hcnJvd1wiLHN0eWxlOnRoaXMucGFyZW50U3R5bGV9LC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtyZWY6c2V0QXJyb3dSZWYsc3R5bGU6YXJyb3dTdHlsZXN9LC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3dpZHRoOngsaGVpZ2h0OnksdmVyc2lvbjpcIjEuMVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0sLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5Z29uXCIse3BvaW50czpwb2ludHMsZmlsbDpjb2xvcn0pKSkpO319XSk7cmV0dXJuIEZsb2F0ZXJBcnJvdzt9KFJlYWN0LkNvbXBvbmVudCk7X2RlZmluZVByb3BlcnR5KEZsb2F0ZXJBcnJvdyxcInByb3BUeXBlc1wiLHtwbGFjZW1lbnQ6UHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLHNldEFycm93UmVmOlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsc3R5bGVzOlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZH0pO1xuXG52YXIgX2V4Y2x1ZGVkJDE9W1wiY29sb3JcIixcImhlaWdodFwiLFwid2lkdGhcIl07ZnVuY3Rpb24gRmxvYXRlckNsb3NlQnRuKF9yZWYpe3ZhciBoYW5kbGVDbGljaz1fcmVmLmhhbmRsZUNsaWNrLHN0eWxlcz1fcmVmLnN0eWxlczt2YXIgY29sb3I9c3R5bGVzLmNvbG9yLGhlaWdodD1zdHlsZXMuaGVpZ2h0LHdpZHRoPXN0eWxlcy53aWR0aCxzdHlsZT1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3R5bGVzLF9leGNsdWRlZCQxKTtyZXR1cm4vKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHtcImFyaWEtbGFiZWxcIjpcImNsb3NlXCIsb25DbGljazpoYW5kbGVDbGljayxzdHlsZTpzdHlsZSx0eXBlOlwiYnV0dG9uXCJ9LC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3dpZHRoOlwiXCIuY29uY2F0KHdpZHRoLFwicHhcIiksaGVpZ2h0OlwiXCIuY29uY2F0KGhlaWdodCxcInB4XCIpLHZpZXdCb3g6XCIwIDAgMTggMThcIix2ZXJzaW9uOlwiMS4xXCIseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHByZXNlcnZlQXNwZWN0UmF0aW86XCJ4TWlkWU1pZFwifSwvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIixudWxsLC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTguMTM5MTExMjksOS4wMDI2ODE5MSBMMC4xNzE1MjE4MjcsMTcuMDI1ODQ2NyBDLTAuMDQ5ODAyNzA0OSwxNy4yNDg3MTUgLTAuMDQ5ODAyNzA0OSwxNy42MDk4Mzk0IDAuMTcxNTIxODI3LDE3LjgzMjc1NDUgQzAuMjgyMDQzNTQsMTcuOTQ0MzUyNiAwLjQyNzE4ODIwNiwxNy45OTk4NzA2IDAuNTcyMDUxNzY1LDE3Ljk5OTg3MDYgQzAuNzE3MTQ5NTgsMTcuOTk5ODcwNiAwLjg2MjAxMzEzOSwxNy45NDQzNTI2IDAuOTcyNTgxNzAzLDE3LjgzMjc1NDUgTDkuMDAwMDkzNyw5Ljc0OTI0NjE4IEwxNy4wMjc2MDU3LDE3LjgzMjc1NDUgQzE3LjEzODQwODUsMTcuOTQ0MzUyNiAxNy4yODMyNzIxLDE3Ljk5OTg3MDYgMTcuNDI4MTM1NiwxNy45OTk4NzA2IEMxNy41NzI5OTkyLDE3Ljk5OTg3MDYgMTcuNzE4MDk3LDE3Ljk0NDM1MjYgMTcuODI4NjY1NiwxNy44MzI3NTQ1IEMxOC4wNDk5OTAxLDE3LjYwOTg4NjIgMTguMDQ5OTkwMSwxNy4yNDg3NjE4IDE3LjgyODY2NTYsMTcuMDI1ODQ2NyBMOS44NjEzNTcyMiw5LjAwMjY4MTkxIEwxNy44MzQwMDY2LDAuOTczODQ4MjI1IEMxOC4wNTUzMzExLDAuNzUwOTc5OTM0IDE4LjA1NTMzMTEsMC4zODk4NTU1MzIgMTcuODM0MDA2NiwwLjE2Njk0MDM5IEMxNy42MTI2ODIxLC0wLjA1NTY0Njc5NjggMTcuMjU0MDM3LC0wLjA1NTY0Njc5NjggMTcuMDMyOTQ2NywwLjE2Njk0MDM5IEw5LjAwMDQyMTY2LDguMjU2MTE3NjUgTDAuOTY3MDA2NDI0LDAuMTY3MjY4MzQ1IEMwLjc0NTY4MTg5MiwtMC4wNTUzMTg4NDI2IDAuMzg3MzE3OTMxLC0wLjA1NTMxODg0MjYgMC4xNjU5OTMzOTksMC4xNjcyNjgzNDUgQy0wLjA1NTMzMTEzMzEsMC4zOTAxMzY2MzUgLTAuMDU1MzMxMTMzMSwwLjc1MTI2MTAzOCAwLjE2NTk5MzM5OSwwLjk3NDE3NjE3OSBMOC4xMzkyMDQ5OSw5LjAwMjY4MTkxIEw4LjEzOTExMTI5LDkuMDAyNjgxOTEgWlwiLGZpbGw6Y29sb3J9KSkpKTt9RmxvYXRlckNsb3NlQnRuLnByb3BUeXBlcz17aGFuZGxlQ2xpY2s6UHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxzdHlsZXM6UHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkfTtcblxuZnVuY3Rpb24gRmxvYXRlckNvbnRhaW5lcihfcmVmKXt2YXIgY29udGVudD1fcmVmLmNvbnRlbnQsZm9vdGVyPV9yZWYuZm9vdGVyLGhhbmRsZUNsaWNrPV9yZWYuaGFuZGxlQ2xpY2ssb3Blbj1fcmVmLm9wZW4scG9zaXRpb25XcmFwcGVyPV9yZWYucG9zaXRpb25XcmFwcGVyLHNob3dDbG9zZUJ1dHRvbj1fcmVmLnNob3dDbG9zZUJ1dHRvbix0aXRsZT1fcmVmLnRpdGxlLHN0eWxlcz1fcmVmLnN0eWxlczt2YXIgb3V0cHV0PXtjb250ZW50Oi8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjb250ZW50KT9jb250ZW50Oi8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIl9fZmxvYXRlcl9fY29udGVudFwiLHN0eWxlOnN0eWxlcy5jb250ZW50fSxjb250ZW50KX07aWYodGl0bGUpe291dHB1dC50aXRsZT0vKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQodGl0bGUpP3RpdGxlOi8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIl9fZmxvYXRlcl9fdGl0bGVcIixzdHlsZTpzdHlsZXMudGl0bGV9LHRpdGxlKTt9aWYoZm9vdGVyKXtvdXRwdXQuZm9vdGVyPS8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmb290ZXIpP2Zvb3RlcjovKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJfX2Zsb2F0ZXJfX2Zvb3RlclwiLHN0eWxlOnN0eWxlcy5mb290ZXJ9LGZvb3Rlcik7fWlmKChzaG93Q2xvc2VCdXR0b258fHBvc2l0aW9uV3JhcHBlcikmJiFpc1tcImJvb2xlYW5cIl0ob3Blbikpe291dHB1dC5jbG9zZT0vKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGVyQ2xvc2VCdG4se3N0eWxlczpzdHlsZXMuY2xvc2UsaGFuZGxlQ2xpY2s6aGFuZGxlQ2xpY2t9KTt9cmV0dXJuLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiX19mbG9hdGVyX19jb250YWluZXJcIixzdHlsZTpzdHlsZXMuY29udGFpbmVyfSxvdXRwdXQuY2xvc2Usb3V0cHV0LnRpdGxlLG91dHB1dC5jb250ZW50LG91dHB1dC5mb290ZXIpO31GbG9hdGVyQ29udGFpbmVyLnByb3BUeXBlcz17Y29udGVudDpQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLGZvb3RlcjpQcm9wVHlwZXMubm9kZSxoYW5kbGVDbGljazpQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLG9wZW46UHJvcFR5cGVzLmJvb2wscG9zaXRpb25XcmFwcGVyOlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsc2hvd0Nsb3NlQnV0dG9uOlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsc3R5bGVzOlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCx0aXRsZTpQcm9wVHlwZXMubm9kZX07XG5cbnZhciBGbG9hdGVyPS8qI19fUFVSRV9fKi9mdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KXtfaW5oZXJpdHMoRmxvYXRlcixfUmVhY3QkQ29tcG9uZW50KTt2YXIgX3N1cGVyPV9jcmVhdGVTdXBlcihGbG9hdGVyKTtmdW5jdGlvbiBGbG9hdGVyKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsRmxvYXRlcik7cmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fV9jcmVhdGVDbGFzcyhGbG9hdGVyLFt7a2V5Olwic3R5bGVcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIF90aGlzJHByb3BzPXRoaXMucHJvcHMsZGlzYWJsZUFuaW1hdGlvbj1fdGhpcyRwcm9wcy5kaXNhYmxlQW5pbWF0aW9uLGNvbXBvbmVudD1fdGhpcyRwcm9wcy5jb21wb25lbnQscGxhY2VtZW50PV90aGlzJHByb3BzLnBsYWNlbWVudCxoaWRlQXJyb3c9X3RoaXMkcHJvcHMuaGlkZUFycm93LHN0YXR1cz1fdGhpcyRwcm9wcy5zdGF0dXMsc3R5bGVzPV90aGlzJHByb3BzLnN0eWxlczt2YXIgbGVuZ3RoPXN0eWxlcy5hcnJvdy5sZW5ndGgsZmxvYXRlcj1zdHlsZXMuZmxvYXRlcixmbG9hdGVyQ2VudGVyZWQ9c3R5bGVzLmZsb2F0ZXJDZW50ZXJlZCxmbG9hdGVyQ2xvc2luZz1zdHlsZXMuZmxvYXRlckNsb3NpbmcsZmxvYXRlck9wZW5pbmc9c3R5bGVzLmZsb2F0ZXJPcGVuaW5nLGZsb2F0ZXJXaXRoQW5pbWF0aW9uPXN0eWxlcy5mbG9hdGVyV2l0aEFuaW1hdGlvbixmbG9hdGVyV2l0aENvbXBvbmVudD1zdHlsZXMuZmxvYXRlcldpdGhDb21wb25lbnQ7dmFyIGVsZW1lbnQ9e307aWYoIWhpZGVBcnJvdyl7aWYocGxhY2VtZW50LnN0YXJ0c1dpdGgoJ3RvcCcpKXtlbGVtZW50LnBhZGRpbmc9XCIwIDAgXCIuY29uY2F0KGxlbmd0aCxcInB4XCIpO31lbHNlIGlmKHBsYWNlbWVudC5zdGFydHNXaXRoKCdib3R0b20nKSl7ZWxlbWVudC5wYWRkaW5nPVwiXCIuY29uY2F0KGxlbmd0aCxcInB4IDAgMFwiKTt9ZWxzZSBpZihwbGFjZW1lbnQuc3RhcnRzV2l0aCgnbGVmdCcpKXtlbGVtZW50LnBhZGRpbmc9XCIwIFwiLmNvbmNhdChsZW5ndGgsXCJweCAwIDBcIik7fWVsc2UgaWYocGxhY2VtZW50LnN0YXJ0c1dpdGgoJ3JpZ2h0Jykpe2VsZW1lbnQucGFkZGluZz1cIjAgMCAwIFwiLmNvbmNhdChsZW5ndGgsXCJweFwiKTt9fWlmKFtTVEFUVVMuT1BFTklORyxTVEFUVVMuT1BFTl0uaW5kZXhPZihzdGF0dXMpIT09LTEpe2VsZW1lbnQ9X29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sZWxlbWVudCksZmxvYXRlck9wZW5pbmcpO31pZihzdGF0dXM9PT1TVEFUVVMuQ0xPU0lORyl7ZWxlbWVudD1fb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSxlbGVtZW50KSxmbG9hdGVyQ2xvc2luZyk7fWlmKHN0YXR1cz09PVNUQVRVUy5PUEVOJiYhZGlzYWJsZUFuaW1hdGlvbil7ZWxlbWVudD1fb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSxlbGVtZW50KSxmbG9hdGVyV2l0aEFuaW1hdGlvbik7fWlmKHBsYWNlbWVudD09PSdjZW50ZXInKXtlbGVtZW50PV9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LGVsZW1lbnQpLGZsb2F0ZXJDZW50ZXJlZCk7fWlmKGNvbXBvbmVudCl7ZWxlbWVudD1fb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSxlbGVtZW50KSxmbG9hdGVyV2l0aENvbXBvbmVudCk7fXJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSxmbG9hdGVyKSxlbGVtZW50KTt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24gcmVuZGVyKCl7dmFyIF90aGlzJHByb3BzMj10aGlzLnByb3BzLGNvbXBvbmVudD1fdGhpcyRwcm9wczIuY29tcG9uZW50LGNsb3NlRm49X3RoaXMkcHJvcHMyLmhhbmRsZUNsaWNrLGhpZGVBcnJvdz1fdGhpcyRwcm9wczIuaGlkZUFycm93LHNldEZsb2F0ZXJSZWY9X3RoaXMkcHJvcHMyLnNldEZsb2F0ZXJSZWYsc3RhdHVzPV90aGlzJHByb3BzMi5zdGF0dXM7dmFyIG91dHB1dD17fTt2YXIgY2xhc3Nlcz1bJ19fZmxvYXRlciddO2lmKGNvbXBvbmVudCl7aWYoLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNvbXBvbmVudCkpe291dHB1dC5jb250ZW50PS8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY29tcG9uZW50LHtjbG9zZUZuOmNsb3NlRm59KTt9ZWxzZSB7b3V0cHV0LmNvbnRlbnQ9Y29tcG9uZW50KHtjbG9zZUZuOmNsb3NlRm59KTt9fWVsc2Uge291dHB1dC5jb250ZW50PS8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0ZXJDb250YWluZXIsdGhpcy5wcm9wcyk7fWlmKHN0YXR1cz09PVNUQVRVUy5PUEVOKXtjbGFzc2VzLnB1c2goJ19fZmxvYXRlcl9fb3BlbicpO31pZighaGlkZUFycm93KXtvdXRwdXQuYXJyb3c9LyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRlckFycm93LHRoaXMucHJvcHMpO31yZXR1cm4vKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6c2V0RmxvYXRlclJlZixjbGFzc05hbWU6Y2xhc3Nlcy5qb2luKCcgJyksc3R5bGU6dGhpcy5zdHlsZX0sLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiX19mbG9hdGVyX19ib2R5XCJ9LG91dHB1dC5jb250ZW50LG91dHB1dC5hcnJvdykpO319XSk7cmV0dXJuIEZsb2F0ZXI7fShSZWFjdC5Db21wb25lbnQpO19kZWZpbmVQcm9wZXJ0eShGbG9hdGVyLFwicHJvcFR5cGVzXCIse2NvbXBvbmVudDpQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYyxQcm9wVHlwZXMuZWxlbWVudF0pLGNvbnRlbnQ6UHJvcFR5cGVzLm5vZGUsZGlzYWJsZUFuaW1hdGlvbjpQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLGZvb3RlcjpQcm9wVHlwZXMubm9kZSxoYW5kbGVDbGljazpQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLGhpZGVBcnJvdzpQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLG9wZW46UHJvcFR5cGVzLmJvb2wscGxhY2VtZW50OlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxwb3NpdGlvbldyYXBwZXI6UHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxzZXRBcnJvd1JlZjpQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLHNldEZsb2F0ZXJSZWY6UHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxzaG93Q2xvc2VCdXR0b246UHJvcFR5cGVzLmJvb2wsc3RhdHVzOlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxzdHlsZXM6UHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLHRpdGxlOlByb3BUeXBlcy5ub2RlfSk7XG5cbnZhciBSZWFjdEZsb2F0ZXJXcmFwcGVyPS8qI19fUFVSRV9fKi9mdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KXtfaW5oZXJpdHMoUmVhY3RGbG9hdGVyV3JhcHBlcixfUmVhY3QkQ29tcG9uZW50KTt2YXIgX3N1cGVyPV9jcmVhdGVTdXBlcihSZWFjdEZsb2F0ZXJXcmFwcGVyKTtmdW5jdGlvbiBSZWFjdEZsb2F0ZXJXcmFwcGVyKCl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsUmVhY3RGbG9hdGVyV3JhcHBlcik7cmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fV9jcmVhdGVDbGFzcyhSZWFjdEZsb2F0ZXJXcmFwcGVyLFt7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24gcmVuZGVyKCl7dmFyIF90aGlzJHByb3BzPXRoaXMucHJvcHMsY2hpbGRyZW49X3RoaXMkcHJvcHMuY2hpbGRyZW4saGFuZGxlQ2xpY2s9X3RoaXMkcHJvcHMuaGFuZGxlQ2xpY2ssaGFuZGxlTW91c2VFbnRlcj1fdGhpcyRwcm9wcy5oYW5kbGVNb3VzZUVudGVyLGhhbmRsZU1vdXNlTGVhdmU9X3RoaXMkcHJvcHMuaGFuZGxlTW91c2VMZWF2ZSxzZXRDaGlsZFJlZj1fdGhpcyRwcm9wcy5zZXRDaGlsZFJlZixzZXRXcmFwcGVyUmVmPV90aGlzJHByb3BzLnNldFdyYXBwZXJSZWYsc3R5bGU9X3RoaXMkcHJvcHMuc3R5bGUsc3R5bGVzPV90aGlzJHByb3BzLnN0eWxlczt2YXIgZWxlbWVudDsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKGNoaWxkcmVuKXtpZihSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbik9PT0xKXtpZighLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSl7ZWxlbWVudD0vKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLGNoaWxkcmVuKTt9ZWxzZSB7dmFyIHJlZlByb3A9aXNbXCJmdW5jdGlvblwiXShjaGlsZHJlbi50eXBlKT8naW5uZXJSZWYnOidyZWYnO2VsZW1lbnQ9LyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSxfZGVmaW5lUHJvcGVydHkoe30scmVmUHJvcCxzZXRDaGlsZFJlZikpO319ZWxzZSB7ZWxlbWVudD1jaGlsZHJlbjt9fWlmKCFlbGVtZW50KXtyZXR1cm4gbnVsbDt9cmV0dXJuLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse3JlZjpzZXRXcmFwcGVyUmVmLHN0eWxlOl9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LHN0eWxlcyksc3R5bGUpLG9uQ2xpY2s6aGFuZGxlQ2xpY2ssb25Nb3VzZUVudGVyOmhhbmRsZU1vdXNlRW50ZXIsb25Nb3VzZUxlYXZlOmhhbmRsZU1vdXNlTGVhdmV9LGVsZW1lbnQpO319XSk7cmV0dXJuIFJlYWN0RmxvYXRlcldyYXBwZXI7fShSZWFjdC5Db21wb25lbnQpO19kZWZpbmVQcm9wZXJ0eShSZWFjdEZsb2F0ZXJXcmFwcGVyLFwicHJvcFR5cGVzXCIse2NoaWxkcmVuOlByb3BUeXBlcy5ub2RlLGhhbmRsZUNsaWNrOlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsaGFuZGxlTW91c2VFbnRlcjpQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLGhhbmRsZU1vdXNlTGVhdmU6UHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxzZXRDaGlsZFJlZjpQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLHNldFdyYXBwZXJSZWY6UHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxzdHlsZTpQcm9wVHlwZXMub2JqZWN0LHN0eWxlczpQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWR9KTtcblxudmFyIGRlZmF1bHRPcHRpb25zPXt6SW5kZXg6MTAwfTtmdW5jdGlvbiBnZXRTdHlsZXMoc3R5bGVzKXt2YXIgb3B0aW9ucz1kZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsc3R5bGVzLm9wdGlvbnN8fHt9KTtyZXR1cm4ge3dyYXBwZXI6e2N1cnNvcjonaGVscCcsZGlzcGxheTonaW5saW5lLWZsZXgnLGZsZXhEaXJlY3Rpb246J2NvbHVtbicsekluZGV4Om9wdGlvbnMuekluZGV4fSx3cmFwcGVyUG9zaXRpb246e2xlZnQ6LTEwMDAscG9zaXRpb246J2Fic29sdXRlJyx0b3A6LTEwMDAsdmlzaWJpbGl0eTonaGlkZGVuJ30sZmxvYXRlcjp7ZGlzcGxheTonaW5saW5lLWJsb2NrJyxmaWx0ZXI6J2Ryb3Atc2hhZG93KDAgMCAzcHggcmdiYSgwLCAwLCAwLCAwLjMpKScsbWF4V2lkdGg6MzAwLG9wYWNpdHk6MCxwb3NpdGlvbjoncmVsYXRpdmUnLHRyYW5zaXRpb246J29wYWNpdHkgMC4zcycsdmlzaWJpbGl0eTonaGlkZGVuJyx6SW5kZXg6b3B0aW9ucy56SW5kZXh9LGZsb2F0ZXJPcGVuaW5nOntvcGFjaXR5OjEsdmlzaWJpbGl0eTondmlzaWJsZSd9LGZsb2F0ZXJXaXRoQW5pbWF0aW9uOntvcGFjaXR5OjEsdHJhbnNpdGlvbjonb3BhY2l0eSAwLjNzLCB0cmFuc2Zvcm0gMC4ycycsdmlzaWJpbGl0eTondmlzaWJsZSd9LGZsb2F0ZXJXaXRoQ29tcG9uZW50OnttYXhXaWR0aDonMTAwJSd9LGZsb2F0ZXJDbG9zaW5nOntvcGFjaXR5OjAsdmlzaWJpbGl0eTondmlzaWJsZSd9LGZsb2F0ZXJDZW50ZXJlZDp7bGVmdDonNTAlJyxwb3NpdGlvbjonZml4ZWQnLHRvcDonNTAlJyx0cmFuc2Zvcm06J3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSd9LGNvbnRhaW5lcjp7YmFja2dyb3VuZENvbG9yOicjZmZmJyxjb2xvcjonIzY2NicsbWluSGVpZ2h0OjYwLG1pbldpZHRoOjIwMCxwYWRkaW5nOjIwLHBvc2l0aW9uOidyZWxhdGl2ZScsekluZGV4OjEwfSx0aXRsZTp7Ym9yZGVyQm90dG9tOicxcHggc29saWQgIzU1NScsY29sb3I6JyM1NTUnLGZvbnRTaXplOjE4LG1hcmdpbkJvdHRvbTo1LHBhZGRpbmdCb3R0b206NixwYWRkaW5nUmlnaHQ6MTh9LGNvbnRlbnQ6e2ZvbnRTaXplOjE1fSxjbG9zZTp7YmFja2dyb3VuZENvbG9yOid0cmFuc3BhcmVudCcsYm9yZGVyOjAsYm9yZGVyUmFkaXVzOjAsY29sb3I6JyM1NTUnLGZvbnRTaXplOjAsaGVpZ2h0OjE1LG91dGxpbmU6J25vbmUnLHBhZGRpbmc6MTAscG9zaXRpb246J2Fic29sdXRlJyxyaWdodDowLHRvcDowLHdpZHRoOjE1LFdlYmtpdEFwcGVhcmFuY2U6J25vbmUnfSxmb290ZXI6e2JvcmRlclRvcDonMXB4IHNvbGlkICNjY2MnLGZvbnRTaXplOjEzLG1hcmdpblRvcDoxMCxwYWRkaW5nVG9wOjV9LGFycm93Ontjb2xvcjonI2ZmZicsZGlzcGxheTonaW5saW5lLWZsZXgnLGxlbmd0aDoxNixtYXJnaW46OCxwb3NpdGlvbjonYWJzb2x1dGUnLHNwcmVhZDozMn0sb3B0aW9uczpvcHRpb25zfTt9XG5cbnZhciBfZXhjbHVkZWQ9W1wiYXJyb3dcIixcImZsaXBcIixcIm9mZnNldFwiXTt2YXIgUE9TSVRJT05JTkdfUFJPUFM9Wydwb3NpdGlvbicsJ3RvcCcsJ3JpZ2h0JywnYm90dG9tJywnbGVmdCddO3ZhciBSZWFjdEZsb2F0ZXI9LyojX19QVVJFX18qL2Z1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpe19pbmhlcml0cyhSZWFjdEZsb2F0ZXIsX1JlYWN0JENvbXBvbmVudCk7dmFyIF9zdXBlcj1fY3JlYXRlU3VwZXIoUmVhY3RGbG9hdGVyKTtmdW5jdGlvbiBSZWFjdEZsb2F0ZXIocHJvcHMpe3ZhciBfdGhpcztfY2xhc3NDYWxsQ2hlY2sodGhpcyxSZWFjdEZsb2F0ZXIpO190aGlzPV9zdXBlci5jYWxsKHRoaXMscHJvcHMpOy8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFwic2V0QXJyb3dSZWZcIixmdW5jdGlvbihyZWYpe190aGlzLmFycm93UmVmPXJlZjt9KTtfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXCJzZXRDaGlsZFJlZlwiLGZ1bmN0aW9uKHJlZil7X3RoaXMuY2hpbGRSZWY9cmVmO30pO19kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcInNldEZsb2F0ZXJSZWZcIixmdW5jdGlvbihyZWYpe190aGlzLmZsb2F0ZXJSZWY9cmVmO30pO19kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcInNldFdyYXBwZXJSZWZcIixmdW5jdGlvbihyZWYpe190aGlzLndyYXBwZXJSZWY9cmVmO30pO19kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcImhhbmRsZVRyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe3ZhciBzdGF0dXM9X3RoaXMuc3RhdGUuc3RhdHVzO3ZhciBjYWxsYmFjaz1fdGhpcy5wcm9wcy5jYWxsYmFjazsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKF90aGlzLndyYXBwZXJQb3BwZXIpe190aGlzLndyYXBwZXJQb3BwZXIuaW5zdGFuY2UudXBkYXRlKCk7fV90aGlzLnNldFN0YXRlKHtzdGF0dXM6c3RhdHVzPT09U1RBVFVTLk9QRU5JTkc/U1RBVFVTLk9QRU46U1RBVFVTLklETEV9LGZ1bmN0aW9uKCl7dmFyIG5ld1N0YXR1cz1fdGhpcy5zdGF0ZS5zdGF0dXM7Y2FsbGJhY2sobmV3U3RhdHVzPT09U1RBVFVTLk9QRU4/J29wZW4nOidjbG9zZScsX3RoaXMucHJvcHMpO30pO30pO19kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcImhhbmRsZUNsaWNrXCIsZnVuY3Rpb24oKXt2YXIgX3RoaXMkcHJvcHM9X3RoaXMucHJvcHMsZXZlbnQ9X3RoaXMkcHJvcHMuZXZlbnQsb3Blbj1fdGhpcyRwcm9wcy5vcGVuO2lmKGlzW1wiYm9vbGVhblwiXShvcGVuKSlyZXR1cm47dmFyIF90aGlzJHN0YXRlPV90aGlzLnN0YXRlLHBvc2l0aW9uV3JhcHBlcj1fdGhpcyRzdGF0ZS5wb3NpdGlvbldyYXBwZXIsc3RhdHVzPV90aGlzJHN0YXRlLnN0YXR1czsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKF90aGlzLmV2ZW50PT09J2NsaWNrJ3x8X3RoaXMuZXZlbnQ9PT0naG92ZXInJiZwb3NpdGlvbldyYXBwZXIpe2xvZyh7dGl0bGU6J2NsaWNrJyxkYXRhOlt7ZXZlbnQ6ZXZlbnQsc3RhdHVzOnN0YXR1cz09PVNUQVRVUy5PUEVOPydjbG9zaW5nJzonb3BlbmluZyd9XSxkZWJ1ZzpfdGhpcy5kZWJ1Z30pO190aGlzLnRvZ2dsZSgpO319KTtfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXCJoYW5kbGVNb3VzZUVudGVyXCIsZnVuY3Rpb24oKXt2YXIgX3RoaXMkcHJvcHMyPV90aGlzLnByb3BzLGV2ZW50PV90aGlzJHByb3BzMi5ldmVudCxvcGVuPV90aGlzJHByb3BzMi5vcGVuO2lmKGlzW1wiYm9vbGVhblwiXShvcGVuKXx8aXNNb2JpbGUoKSlyZXR1cm47dmFyIHN0YXR1cz1fdGhpcy5zdGF0ZS5zdGF0dXM7LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9pZihfdGhpcy5ldmVudD09PSdob3ZlcicmJnN0YXR1cz09PVNUQVRVUy5JRExFKXtsb2coe3RpdGxlOidtb3VzZUVudGVyJyxkYXRhOlt7a2V5OidvcmlnaW5hbEV2ZW50Jyx2YWx1ZTpldmVudH1dLGRlYnVnOl90aGlzLmRlYnVnfSk7Y2xlYXJUaW1lb3V0KF90aGlzLmV2ZW50RGVsYXlUaW1lb3V0KTtfdGhpcy50b2dnbGUoKTt9fSk7X2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFwiaGFuZGxlTW91c2VMZWF2ZVwiLGZ1bmN0aW9uKCl7dmFyIF90aGlzJHByb3BzMz1fdGhpcy5wcm9wcyxldmVudD1fdGhpcyRwcm9wczMuZXZlbnQsZXZlbnREZWxheT1fdGhpcyRwcm9wczMuZXZlbnREZWxheSxvcGVuPV90aGlzJHByb3BzMy5vcGVuO2lmKGlzW1wiYm9vbGVhblwiXShvcGVuKXx8aXNNb2JpbGUoKSlyZXR1cm47dmFyIF90aGlzJHN0YXRlMj1fdGhpcy5zdGF0ZSxzdGF0dXM9X3RoaXMkc3RhdGUyLnN0YXR1cyxwb3NpdGlvbldyYXBwZXI9X3RoaXMkc3RhdGUyLnBvc2l0aW9uV3JhcHBlcjsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKF90aGlzLmV2ZW50PT09J2hvdmVyJyl7bG9nKHt0aXRsZTonbW91c2VMZWF2ZScsZGF0YTpbe2tleTonb3JpZ2luYWxFdmVudCcsdmFsdWU6ZXZlbnR9XSxkZWJ1ZzpfdGhpcy5kZWJ1Z30pO2lmKCFldmVudERlbGF5KXtfdGhpcy50b2dnbGUoU1RBVFVTLklETEUpO31lbHNlIGlmKFtTVEFUVVMuT1BFTklORyxTVEFUVVMuT1BFTl0uaW5kZXhPZihzdGF0dXMpIT09LTEmJiFwb3NpdGlvbldyYXBwZXImJiFfdGhpcy5ldmVudERlbGF5VGltZW91dCl7X3RoaXMuZXZlbnREZWxheVRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2RlbGV0ZSBfdGhpcy5ldmVudERlbGF5VGltZW91dDtfdGhpcy50b2dnbGUoKTt9LGV2ZW50RGVsYXkqMTAwMCk7fX19KTtfdGhpcy5zdGF0ZT17Y3VycmVudFBsYWNlbWVudDpwcm9wcy5wbGFjZW1lbnQsbmVlZHNVcGRhdGU6ZmFsc2UscG9zaXRpb25XcmFwcGVyOnByb3BzLndyYXBwZXJPcHRpb25zLnBvc2l0aW9uJiYhIXByb3BzLnRhcmdldCxzdGF0dXM6U1RBVFVTLklOSVQsc3RhdHVzV3JhcHBlcjpTVEFUVVMuSU5JVH07X3RoaXMuX2lzTW91bnRlZD1mYWxzZTtfdGhpcy5oYXNNb3VudGVkPWZhbHNlO2lmKGNhblVzZURPTSgpKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsZnVuY3Rpb24oKXtpZihfdGhpcy5wb3BwZXIpe190aGlzLnBvcHBlci5pbnN0YW5jZS51cGRhdGUoKTt9aWYoX3RoaXMud3JhcHBlclBvcHBlcil7X3RoaXMud3JhcHBlclBvcHBlci5pbnN0YW5jZS51cGRhdGUoKTt9fSk7fXJldHVybiBfdGhpczt9X2NyZWF0ZUNsYXNzKFJlYWN0RmxvYXRlcixbe2tleTpcImNvbXBvbmVudERpZE1vdW50XCIsdmFsdWU6ZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKXtpZighY2FuVXNlRE9NKCkpcmV0dXJuO3ZhciBwb3NpdGlvbldyYXBwZXI9dGhpcy5zdGF0ZS5wb3NpdGlvbldyYXBwZXI7dmFyIF90aGlzJHByb3BzNT10aGlzLnByb3BzLGNoaWxkcmVuPV90aGlzJHByb3BzNS5jaGlsZHJlbixvcGVuPV90aGlzJHByb3BzNS5vcGVuLHRhcmdldD1fdGhpcyRwcm9wczUudGFyZ2V0O3RoaXMuX2lzTW91bnRlZD10cnVlO2xvZyh7dGl0bGU6J2luaXQnLGRhdGE6e2hhc0NoaWxkcmVuOiEhY2hpbGRyZW4saGFzVGFyZ2V0OiEhdGFyZ2V0LGlzQ29udHJvbGxlZDppc1tcImJvb2xlYW5cIl0ob3BlbikscG9zaXRpb25XcmFwcGVyOnBvc2l0aW9uV3JhcHBlcix0YXJnZXQ6dGhpcy50YXJnZXQsZmxvYXRlcjp0aGlzLmZsb2F0ZXJSZWZ9LGRlYnVnOnRoaXMuZGVidWd9KTtpZighdGhpcy5oYXNNb3VudGVkKXt0aGlzLmluaXRQb3BwZXIoKTt0aGlzLmhhc01vdW50ZWQ9dHJ1ZTt9aWYoIWNoaWxkcmVuJiZ0YXJnZXQmJiFpc1tcImJvb2xlYW5cIl0ob3BlbikpO319LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLHByZXZTdGF0ZSl7aWYoIWNhblVzZURPTSgpKXJldHVybjt2YXIgX3RoaXMkcHJvcHM2PXRoaXMucHJvcHMsYXV0b09wZW49X3RoaXMkcHJvcHM2LmF1dG9PcGVuLG9wZW49X3RoaXMkcHJvcHM2Lm9wZW4sdGFyZ2V0PV90aGlzJHByb3BzNi50YXJnZXQsd3JhcHBlck9wdGlvbnM9X3RoaXMkcHJvcHM2LndyYXBwZXJPcHRpb25zO3ZhciBfdHJlZUNoYW5nZXM9dHJlZUNoYW5nZXMocHJldlN0YXRlLHRoaXMuc3RhdGUpLGNoYW5nZWRGcm9tPV90cmVlQ2hhbmdlcy5jaGFuZ2VkRnJvbSxjaGFuZ2VkPV90cmVlQ2hhbmdlcy5jaGFuZ2VkO2lmKHByZXZQcm9wcy5vcGVuIT09b3Blbil7dmFyIGZvcmNlU3RhdHVzOy8vIGFsd2F5cyBmb2xsb3cgYG9wZW5gIGluIGNvbnRyb2xsZWQgbW9kZVxuaWYoaXNbXCJib29sZWFuXCJdKG9wZW4pKXtmb3JjZVN0YXR1cz1vcGVuP1NUQVRVUy5PUEVOSU5HOlNUQVRVUy5DTE9TSU5HO310aGlzLnRvZ2dsZShmb3JjZVN0YXR1cyk7fWlmKHByZXZQcm9wcy53cmFwcGVyT3B0aW9ucy5wb3NpdGlvbiE9PXdyYXBwZXJPcHRpb25zLnBvc2l0aW9ufHxwcmV2UHJvcHMudGFyZ2V0IT09dGFyZ2V0KXt0aGlzLmNoYW5nZVdyYXBwZXJQb3NpdGlvbih0aGlzLnByb3BzKTt9aWYoY2hhbmdlZCgnc3RhdHVzJyxTVEFUVVMuSURMRSkmJm9wZW4pe3RoaXMudG9nZ2xlKFNUQVRVUy5PUEVOKTt9ZWxzZSBpZihjaGFuZ2VkRnJvbSgnc3RhdHVzJyxTVEFUVVMuSU5JVCxTVEFUVVMuSURMRSkmJmF1dG9PcGVuKXt0aGlzLnRvZ2dsZShTVEFUVVMuT1BFTik7fWlmKHRoaXMucG9wcGVyJiZjaGFuZ2VkKCdzdGF0dXMnLFNUQVRVUy5PUEVOSU5HKSl7dGhpcy5wb3BwZXIuaW5zdGFuY2UudXBkYXRlKCk7fWlmKHRoaXMuZmxvYXRlclJlZiYmKGNoYW5nZWQoJ3N0YXR1cycsU1RBVFVTLk9QRU5JTkcpfHxjaGFuZ2VkKCdzdGF0dXMnLFNUQVRVUy5DTE9TSU5HKSkpe29uY2UodGhpcy5mbG9hdGVyUmVmLCd0cmFuc2l0aW9uZW5kJyx0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmQpO31pZihjaGFuZ2VkKCduZWVkc1VwZGF0ZScsdHJ1ZSkpe3RoaXMucmVidWlsZFBvcHBlcigpO319fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpe2lmKCFjYW5Vc2VET00oKSlyZXR1cm47dGhpcy5faXNNb3VudGVkPWZhbHNlO2lmKHRoaXMucG9wcGVyKXt0aGlzLnBvcHBlci5pbnN0YW5jZS5kZXN0cm95KCk7fWlmKHRoaXMud3JhcHBlclBvcHBlcil7dGhpcy53cmFwcGVyUG9wcGVyLmluc3RhbmNlLmRlc3Ryb3koKTt9fX0se2tleTpcImluaXRQb3BwZXJcIix2YWx1ZTpmdW5jdGlvbiBpbml0UG9wcGVyKCl7dmFyIF90aGlzMj10aGlzO3ZhciB0YXJnZXQ9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnRoaXMudGFyZ2V0O3ZhciBwb3NpdGlvbldyYXBwZXI9dGhpcy5zdGF0ZS5wb3NpdGlvbldyYXBwZXI7dmFyIF90aGlzJHByb3BzNz10aGlzLnByb3BzLGRpc2FibGVGbGlwPV90aGlzJHByb3BzNy5kaXNhYmxlRmxpcCxnZXRQb3BwZXI9X3RoaXMkcHJvcHM3LmdldFBvcHBlcixoaWRlQXJyb3c9X3RoaXMkcHJvcHM3LmhpZGVBcnJvdyxvZmZzZXQ9X3RoaXMkcHJvcHM3Lm9mZnNldCxwbGFjZW1lbnQ9X3RoaXMkcHJvcHM3LnBsYWNlbWVudCx3cmFwcGVyT3B0aW9ucz1fdGhpcyRwcm9wczcud3JhcHBlck9wdGlvbnM7dmFyIGZsaXBCZWhhdmlvcj1wbGFjZW1lbnQ9PT0ndG9wJ3x8cGxhY2VtZW50PT09J2JvdHRvbSc/J2ZsaXAnOlsncmlnaHQnLCdib3R0b20tZW5kJywndG9wLWVuZCcsJ2xlZnQnLCd0b3Atc3RhcnQnLCdib3R0b20tc3RhcnQnXTsvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL2lmKHBsYWNlbWVudD09PSdjZW50ZXInKXt0aGlzLnNldFN0YXRlKHtzdGF0dXM6U1RBVFVTLklETEV9KTt9ZWxzZSBpZih0YXJnZXQmJnRoaXMuZmxvYXRlclJlZil7dmFyIF90aGlzJG9wdGlvbnM9dGhpcy5vcHRpb25zLGFycm93PV90aGlzJG9wdGlvbnMuYXJyb3csZmxpcD1fdGhpcyRvcHRpb25zLmZsaXAsb2Zmc2V0T3B0aW9ucz1fdGhpcyRvcHRpb25zLm9mZnNldCxyZXN0PV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRvcHRpb25zLF9leGNsdWRlZCk7bmV3IFBvcHBlcih0YXJnZXQsdGhpcy5mbG9hdGVyUmVmLHtwbGFjZW1lbnQ6cGxhY2VtZW50LG1vZGlmaWVyczpfb2JqZWN0U3ByZWFkMih7YXJyb3c6X29iamVjdFNwcmVhZDIoe2VuYWJsZWQ6IWhpZGVBcnJvdyxlbGVtZW50OnRoaXMuYXJyb3dSZWZ9LGFycm93KSxmbGlwOl9vYmplY3RTcHJlYWQyKHtlbmFibGVkOiFkaXNhYmxlRmxpcCxiZWhhdmlvcjpmbGlwQmVoYXZpb3J9LGZsaXApLG9mZnNldDpfb2JqZWN0U3ByZWFkMih7b2Zmc2V0OlwiMCwgXCIuY29uY2F0KG9mZnNldCxcInB4XCIpfSxvZmZzZXRPcHRpb25zKX0scmVzdCksb25DcmVhdGU6ZnVuY3Rpb24gb25DcmVhdGUoZGF0YSl7dmFyIF90aGlzMiRmbG9hdGVyUmVmO190aGlzMi5wb3BwZXI9ZGF0YTtpZighKChfdGhpczIkZmxvYXRlclJlZj1fdGhpczIuZmxvYXRlclJlZikhPT1udWxsJiZfdGhpczIkZmxvYXRlclJlZiE9PXZvaWQgMCYmX3RoaXMyJGZsb2F0ZXJSZWYuaXNDb25uZWN0ZWQpKXtfdGhpczIuc2V0U3RhdGUoe25lZWRzVXBkYXRlOnRydWV9KTtyZXR1cm47fWdldFBvcHBlcihkYXRhLCdmbG9hdGVyJyk7aWYoX3RoaXMyLl9pc01vdW50ZWQpe190aGlzMi5zZXRTdGF0ZSh7Y3VycmVudFBsYWNlbWVudDpkYXRhLnBsYWNlbWVudCxzdGF0dXM6U1RBVFVTLklETEV9KTt9aWYocGxhY2VtZW50IT09ZGF0YS5wbGFjZW1lbnQpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkYXRhLmluc3RhbmNlLnVwZGF0ZSgpO30sMSk7fX0sb25VcGRhdGU6ZnVuY3Rpb24gb25VcGRhdGUoZGF0YSl7X3RoaXMyLnBvcHBlcj1kYXRhO3ZhciBjdXJyZW50UGxhY2VtZW50PV90aGlzMi5zdGF0ZS5jdXJyZW50UGxhY2VtZW50O2lmKF90aGlzMi5faXNNb3VudGVkJiZkYXRhLnBsYWNlbWVudCE9PWN1cnJlbnRQbGFjZW1lbnQpe190aGlzMi5zZXRTdGF0ZSh7Y3VycmVudFBsYWNlbWVudDpkYXRhLnBsYWNlbWVudH0pO319fSk7fWlmKHBvc2l0aW9uV3JhcHBlcil7dmFyIHdyYXBwZXJPZmZzZXQ9IWlzLnVuZGVmaW5lZCh3cmFwcGVyT3B0aW9ucy5vZmZzZXQpP3dyYXBwZXJPcHRpb25zLm9mZnNldDowO25ldyBQb3BwZXIodGhpcy50YXJnZXQsdGhpcy53cmFwcGVyUmVmLHtwbGFjZW1lbnQ6d3JhcHBlck9wdGlvbnMucGxhY2VtZW50fHxwbGFjZW1lbnQsbW9kaWZpZXJzOnthcnJvdzp7ZW5hYmxlZDpmYWxzZX0sb2Zmc2V0OntvZmZzZXQ6XCIwLCBcIi5jb25jYXQod3JhcHBlck9mZnNldCxcInB4XCIpfSxmbGlwOntlbmFibGVkOmZhbHNlfX0sb25DcmVhdGU6ZnVuY3Rpb24gb25DcmVhdGUoZGF0YSl7X3RoaXMyLndyYXBwZXJQb3BwZXI9ZGF0YTtpZihfdGhpczIuX2lzTW91bnRlZCl7X3RoaXMyLnNldFN0YXRlKHtzdGF0dXNXcmFwcGVyOlNUQVRVUy5JRExFfSk7fWdldFBvcHBlcihkYXRhLCd3cmFwcGVyJyk7aWYocGxhY2VtZW50IT09ZGF0YS5wbGFjZW1lbnQpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkYXRhLmluc3RhbmNlLnVwZGF0ZSgpO30sMSk7fX19KTt9fX0se2tleTpcInJlYnVpbGRQb3BwZXJcIix2YWx1ZTpmdW5jdGlvbiByZWJ1aWxkUG9wcGVyKCl7dmFyIF90aGlzMz10aGlzO3RoaXMuZmxvYXRlclJlZkludGVydmFsPXNldEludGVydmFsKGZ1bmN0aW9uKCl7dmFyIF90aGlzMyRmbG9hdGVyUmVmO2lmKChfdGhpczMkZmxvYXRlclJlZj1fdGhpczMuZmxvYXRlclJlZikhPT1udWxsJiZfdGhpczMkZmxvYXRlclJlZiE9PXZvaWQgMCYmX3RoaXMzJGZsb2F0ZXJSZWYuaXNDb25uZWN0ZWQpe2NsZWFySW50ZXJ2YWwoX3RoaXMzLmZsb2F0ZXJSZWZJbnRlcnZhbCk7X3RoaXMzLnNldFN0YXRlKHtuZWVkc1VwZGF0ZTpmYWxzZX0pO190aGlzMy5pbml0UG9wcGVyKCk7fX0sNTApO319LHtrZXk6XCJjaGFuZ2VXcmFwcGVyUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbiBjaGFuZ2VXcmFwcGVyUG9zaXRpb24oX3JlZil7dmFyIHRhcmdldD1fcmVmLnRhcmdldCx3cmFwcGVyT3B0aW9ucz1fcmVmLndyYXBwZXJPcHRpb25zO3RoaXMuc2V0U3RhdGUoe3Bvc2l0aW9uV3JhcHBlcjp3cmFwcGVyT3B0aW9ucy5wb3NpdGlvbiYmISF0YXJnZXR9KTt9fSx7a2V5OlwidG9nZ2xlXCIsdmFsdWU6ZnVuY3Rpb24gdG9nZ2xlKGZvcmNlU3RhdHVzKXt2YXIgc3RhdHVzPXRoaXMuc3RhdGUuc3RhdHVzO3ZhciBuZXh0U3RhdHVzPXN0YXR1cz09PVNUQVRVUy5PUEVOP1NUQVRVUy5DTE9TSU5HOlNUQVRVUy5PUEVOSU5HO2lmKCFpcy51bmRlZmluZWQoZm9yY2VTdGF0dXMpKXtuZXh0U3RhdHVzPWZvcmNlU3RhdHVzO310aGlzLnNldFN0YXRlKHtzdGF0dXM6bmV4dFN0YXR1c30pO319LHtrZXk6XCJkZWJ1Z1wiLGdldDpmdW5jdGlvbiBnZXQoKXt2YXIgZGVidWc9dGhpcy5wcm9wcy5kZWJ1ZztyZXR1cm4gZGVidWd8fGNhblVzZURPTSgpJiYnUmVhY3RGbG9hdGVyRGVidWcnaW4gd2luZG93JiYhIXdpbmRvdy5SZWFjdEZsb2F0ZXJEZWJ1Zzt9fSx7a2V5OlwiZXZlbnRcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIF90aGlzJHByb3BzOD10aGlzLnByb3BzLGRpc2FibGVIb3ZlclRvQ2xpY2s9X3RoaXMkcHJvcHM4LmRpc2FibGVIb3ZlclRvQ2xpY2ssZXZlbnQ9X3RoaXMkcHJvcHM4LmV2ZW50O2lmKGV2ZW50PT09J2hvdmVyJyYmaXNNb2JpbGUoKSYmIWRpc2FibGVIb3ZlclRvQ2xpY2spe3JldHVybiAnY2xpY2snO31yZXR1cm4gZXZlbnQ7fX0se2tleTpcIm9wdGlvbnNcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIG9wdGlvbnM9dGhpcy5wcm9wcy5vcHRpb25zO3JldHVybiBkZWVwbWVyZ2UoREVGQVVMVFMsb3B0aW9uc3x8e30pO319LHtrZXk6XCJzdHlsZXNcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIF90aGlzND10aGlzO3ZhciBfdGhpcyRzdGF0ZTM9dGhpcy5zdGF0ZSxzdGF0dXM9X3RoaXMkc3RhdGUzLnN0YXR1cyxwb3NpdGlvbldyYXBwZXI9X3RoaXMkc3RhdGUzLnBvc2l0aW9uV3JhcHBlcixzdGF0dXNXcmFwcGVyPV90aGlzJHN0YXRlMy5zdGF0dXNXcmFwcGVyO3ZhciBzdHlsZXM9dGhpcy5wcm9wcy5zdHlsZXM7dmFyIG5leHRTdHlsZXM9ZGVlcG1lcmdlKGdldFN0eWxlcyhzdHlsZXMpLHN0eWxlcyk7aWYocG9zaXRpb25XcmFwcGVyKXt2YXIgd3JhcHBlclN0eWxlcztpZighKFtTVEFUVVMuSURMRV0uaW5kZXhPZihzdGF0dXMpIT09LTEpfHwhKFtTVEFUVVMuSURMRV0uaW5kZXhPZihzdGF0dXNXcmFwcGVyKSE9PS0xKSl7d3JhcHBlclN0eWxlcz1uZXh0U3R5bGVzLndyYXBwZXJQb3NpdGlvbjt9ZWxzZSB7d3JhcHBlclN0eWxlcz10aGlzLndyYXBwZXJQb3BwZXIuc3R5bGVzO31uZXh0U3R5bGVzLndyYXBwZXI9X29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sbmV4dFN0eWxlcy53cmFwcGVyKSx3cmFwcGVyU3R5bGVzKTt9LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9pZih0aGlzLnRhcmdldCl7dmFyIHRhcmdldFN0eWxlcz13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnRhcmdldCk7LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9pZih0aGlzLndyYXBwZXJTdHlsZXMpe25leHRTdHlsZXMud3JhcHBlcj1fb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSxuZXh0U3R5bGVzLndyYXBwZXIpLHRoaXMud3JhcHBlclN0eWxlcyk7fWVsc2UgaWYoIShbJ3JlbGF0aXZlJywnc3RhdGljJ10uaW5kZXhPZih0YXJnZXRTdHlsZXMucG9zaXRpb24pIT09LTEpKXt0aGlzLndyYXBwZXJTdHlsZXM9e307aWYoIXBvc2l0aW9uV3JhcHBlcil7UE9TSVRJT05JTkdfUFJPUFMuZm9yRWFjaChmdW5jdGlvbihkKXtfdGhpczQud3JhcHBlclN0eWxlc1tkXT10YXJnZXRTdHlsZXNbZF07fSk7bmV4dFN0eWxlcy53cmFwcGVyPV9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LG5leHRTdHlsZXMud3JhcHBlciksdGhpcy53cmFwcGVyU3R5bGVzKTt0aGlzLnRhcmdldC5zdHlsZS5wb3NpdGlvbj0ncmVsYXRpdmUnO3RoaXMudGFyZ2V0LnN0eWxlLnRvcD0nYXV0byc7dGhpcy50YXJnZXQuc3R5bGUucmlnaHQ9J2F1dG8nO3RoaXMudGFyZ2V0LnN0eWxlLmJvdHRvbT0nYXV0byc7dGhpcy50YXJnZXQuc3R5bGUubGVmdD0nYXV0byc7fX19cmV0dXJuIG5leHRTdHlsZXM7fX0se2tleTpcInRhcmdldFwiLGdldDpmdW5jdGlvbiBnZXQoKXtpZighY2FuVXNlRE9NKCkpcmV0dXJuIG51bGw7dmFyIHRhcmdldD10aGlzLnByb3BzLnRhcmdldDtpZih0YXJnZXQpe2lmKGlzLmRvbUVsZW1lbnQodGFyZ2V0KSl7cmV0dXJuIHRhcmdldDt9cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTt9cmV0dXJuIHRoaXMuY2hpbGRSZWZ8fHRoaXMud3JhcHBlclJlZjt9fSx7a2V5OlwicmVuZGVyXCIsdmFsdWU6ZnVuY3Rpb24gcmVuZGVyKCl7dmFyIF90aGlzJHN0YXRlND10aGlzLnN0YXRlLGN1cnJlbnRQbGFjZW1lbnQ9X3RoaXMkc3RhdGU0LmN1cnJlbnRQbGFjZW1lbnQscG9zaXRpb25XcmFwcGVyPV90aGlzJHN0YXRlNC5wb3NpdGlvbldyYXBwZXIsc3RhdHVzPV90aGlzJHN0YXRlNC5zdGF0dXM7dmFyIF90aGlzJHByb3BzOT10aGlzLnByb3BzLGNoaWxkcmVuPV90aGlzJHByb3BzOS5jaGlsZHJlbixjb21wb25lbnQ9X3RoaXMkcHJvcHM5LmNvbXBvbmVudCxjb250ZW50PV90aGlzJHByb3BzOS5jb250ZW50LGRpc2FibGVBbmltYXRpb249X3RoaXMkcHJvcHM5LmRpc2FibGVBbmltYXRpb24sZm9vdGVyPV90aGlzJHByb3BzOS5mb290ZXIsaGlkZUFycm93PV90aGlzJHByb3BzOS5oaWRlQXJyb3csaWQ9X3RoaXMkcHJvcHM5LmlkLG9wZW49X3RoaXMkcHJvcHM5Lm9wZW4sc2hvd0Nsb3NlQnV0dG9uPV90aGlzJHByb3BzOS5zaG93Q2xvc2VCdXR0b24sc3R5bGU9X3RoaXMkcHJvcHM5LnN0eWxlLHRhcmdldD1fdGhpcyRwcm9wczkudGFyZ2V0LHRpdGxlPV90aGlzJHByb3BzOS50aXRsZTt2YXIgd3JhcHBlcj0vKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdEZsb2F0ZXJXcmFwcGVyLHtoYW5kbGVDbGljazp0aGlzLmhhbmRsZUNsaWNrLGhhbmRsZU1vdXNlRW50ZXI6dGhpcy5oYW5kbGVNb3VzZUVudGVyLGhhbmRsZU1vdXNlTGVhdmU6dGhpcy5oYW5kbGVNb3VzZUxlYXZlLHNldENoaWxkUmVmOnRoaXMuc2V0Q2hpbGRSZWYsc2V0V3JhcHBlclJlZjp0aGlzLnNldFdyYXBwZXJSZWYsc3R5bGU6c3R5bGUsc3R5bGVzOnRoaXMuc3R5bGVzLndyYXBwZXJ9LGNoaWxkcmVuKTt2YXIgb3V0cHV0PXt9O2lmKHBvc2l0aW9uV3JhcHBlcil7b3V0cHV0LndyYXBwZXJJblBvcnRhbD13cmFwcGVyO31lbHNlIHtvdXRwdXQud3JhcHBlckFzQ2hpbGRyZW49d3JhcHBlcjt9cmV0dXJuLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCwvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdEZsb2F0ZXJQb3J0YWwse2hhc0NoaWxkcmVuOiEhY2hpbGRyZW4saWQ6aWQscGxhY2VtZW50OmN1cnJlbnRQbGFjZW1lbnQsc2V0UmVmOnRoaXMuc2V0RmxvYXRlclJlZix0YXJnZXQ6dGFyZ2V0LHpJbmRleDp0aGlzLnN0eWxlcy5vcHRpb25zLnpJbmRleH0sLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRlcix7Y29tcG9uZW50OmNvbXBvbmVudCxjb250ZW50OmNvbnRlbnQsZGlzYWJsZUFuaW1hdGlvbjpkaXNhYmxlQW5pbWF0aW9uLGZvb3Rlcjpmb290ZXIsaGFuZGxlQ2xpY2s6dGhpcy5oYW5kbGVDbGljayxoaWRlQXJyb3c6aGlkZUFycm93fHxjdXJyZW50UGxhY2VtZW50PT09J2NlbnRlcicsb3BlbjpvcGVuLHBsYWNlbWVudDpjdXJyZW50UGxhY2VtZW50LHBvc2l0aW9uV3JhcHBlcjpwb3NpdGlvbldyYXBwZXIsc2V0QXJyb3dSZWY6dGhpcy5zZXRBcnJvd1JlZixzZXRGbG9hdGVyUmVmOnRoaXMuc2V0RmxvYXRlclJlZixzaG93Q2xvc2VCdXR0b246c2hvd0Nsb3NlQnV0dG9uLHN0YXR1czpzdGF0dXMsc3R5bGVzOnRoaXMuc3R5bGVzLHRpdGxlOnRpdGxlfSksb3V0cHV0LndyYXBwZXJJblBvcnRhbCksb3V0cHV0LndyYXBwZXJBc0NoaWxkcmVuKTt9fV0pO3JldHVybiBSZWFjdEZsb2F0ZXI7fShSZWFjdC5Db21wb25lbnQpO19kZWZpbmVQcm9wZXJ0eShSZWFjdEZsb2F0ZXIsXCJwcm9wVHlwZXNcIix7YXV0b09wZW46UHJvcFR5cGVzLmJvb2wsY2FsbGJhY2s6UHJvcFR5cGVzLmZ1bmMsY2hpbGRyZW46UHJvcFR5cGVzLm5vZGUsY29tcG9uZW50OmlzUmVxdWlyZWRJZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYyxQcm9wVHlwZXMuZWxlbWVudF0pLGZ1bmN0aW9uKHByb3BzKXtyZXR1cm4gIXByb3BzLmNvbnRlbnQ7fSksY29udGVudDppc1JlcXVpcmVkSWYoUHJvcFR5cGVzLm5vZGUsZnVuY3Rpb24ocHJvcHMpe3JldHVybiAhcHJvcHMuY29tcG9uZW50O30pLGRlYnVnOlByb3BUeXBlcy5ib29sLGRpc2FibGVBbmltYXRpb246UHJvcFR5cGVzLmJvb2wsZGlzYWJsZUZsaXA6UHJvcFR5cGVzLmJvb2wsZGlzYWJsZUhvdmVyVG9DbGljazpQcm9wVHlwZXMuYm9vbCxldmVudDpQcm9wVHlwZXMub25lT2YoWydob3ZlcicsJ2NsaWNrJ10pLGV2ZW50RGVsYXk6UHJvcFR5cGVzLm51bWJlcixmb290ZXI6UHJvcFR5cGVzLm5vZGUsZ2V0UG9wcGVyOlByb3BUeXBlcy5mdW5jLGhpZGVBcnJvdzpQcm9wVHlwZXMuYm9vbCxpZDpQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLFByb3BUeXBlcy5udW1iZXJdKSxvZmZzZXQ6UHJvcFR5cGVzLm51bWJlcixvcGVuOlByb3BUeXBlcy5ib29sLG9wdGlvbnM6UHJvcFR5cGVzLm9iamVjdCxwbGFjZW1lbnQ6UHJvcFR5cGVzLm9uZU9mKFsndG9wJywndG9wLXN0YXJ0JywndG9wLWVuZCcsJ2JvdHRvbScsJ2JvdHRvbS1zdGFydCcsJ2JvdHRvbS1lbmQnLCdsZWZ0JywnbGVmdC1zdGFydCcsJ2xlZnQtZW5kJywncmlnaHQnLCdyaWdodC1zdGFydCcsJ3JpZ2h0LWVuZCcsJ2F1dG8nLCdjZW50ZXInXSksc2hvd0Nsb3NlQnV0dG9uOlByb3BUeXBlcy5ib29sLHN0eWxlOlByb3BUeXBlcy5vYmplY3Qsc3R5bGVzOlByb3BUeXBlcy5vYmplY3QsdGFyZ2V0OlByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsUHJvcFR5cGVzLnN0cmluZ10pLHRpdGxlOlByb3BUeXBlcy5ub2RlLHdyYXBwZXJPcHRpb25zOlByb3BUeXBlcy5zaGFwZSh7b2Zmc2V0OlByb3BUeXBlcy5udW1iZXIscGxhY2VtZW50OlByb3BUeXBlcy5vbmVPZihbJ3RvcCcsJ3RvcC1zdGFydCcsJ3RvcC1lbmQnLCdib3R0b20nLCdib3R0b20tc3RhcnQnLCdib3R0b20tZW5kJywnbGVmdCcsJ2xlZnQtc3RhcnQnLCdsZWZ0LWVuZCcsJ3JpZ2h0JywncmlnaHQtc3RhcnQnLCdyaWdodC1lbmQnLCdhdXRvJ10pLHBvc2l0aW9uOlByb3BUeXBlcy5ib29sfSl9KTtfZGVmaW5lUHJvcGVydHkoUmVhY3RGbG9hdGVyLFwiZGVmYXVsdFByb3BzXCIse2F1dG9PcGVuOmZhbHNlLGNhbGxiYWNrOm5vb3AsZGVidWc6ZmFsc2UsZGlzYWJsZUFuaW1hdGlvbjpmYWxzZSxkaXNhYmxlRmxpcDpmYWxzZSxkaXNhYmxlSG92ZXJUb0NsaWNrOmZhbHNlLGV2ZW50OidjbGljaycsZXZlbnREZWxheTowLjQsZ2V0UG9wcGVyOm5vb3AsaGlkZUFycm93OmZhbHNlLG9mZnNldDoxNSxwbGFjZW1lbnQ6J2JvdHRvbScsc2hvd0Nsb3NlQnV0dG9uOmZhbHNlLHN0eWxlczp7fSx0YXJnZXQ6bnVsbCx3cmFwcGVyT3B0aW9uczp7cG9zaXRpb246ZmFsc2V9fSk7XG5cbmV4cG9ydCB7IFJlYWN0RmxvYXRlciBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/helpers.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/helpers.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isNull: function() { return /* binding */ isNull; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isRegex: function() { return /* binding */ isRegex; },\n/* harmony export */   isUndefined: function() { return /* binding */ isUndefined; }\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isOfType(type) {\n    return function (value) { return typeof value === type; };\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nvar isFunction = isOfType('function');\nvar isNull = function (value) {\n    return value === null;\n};\nvar isRegex = function (value) {\n    return Object.prototype.toString.call(value).slice(8, -1) === 'RegExp';\n};\nvar isObject = function (value) {\n    return !isUndefined(value) && !isNull(value) && (isFunction(value) || typeof value === 'object');\n};\nvar isUndefined = isOfType('undefined');\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy9AZ2lsYmFyYmFyYS9kZWVwLWVxdWFsL2VzbS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy9AZ2lsYmFyYmFyYS9kZWVwLWVxdWFsL2VzbS9oZWxwZXJzLmpzPzNlYzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGlzT2ZUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHR5cGU7IH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IHZhciBpc0Z1bmN0aW9uID0gaXNPZlR5cGUoJ2Z1bmN0aW9uJyk7XG5leHBvcnQgdmFyIGlzTnVsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn07XG5leHBvcnQgdmFyIGlzUmVnZXggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgPT09ICdSZWdFeHAnO1xufTtcbmV4cG9ydCB2YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHZhbHVlKSAmJiAhaXNOdWxsKHZhbHVlKSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG59O1xuZXhwb3J0IHZhciBpc1VuZGVmaW5lZCA9IGlzT2ZUeXBlKCd1bmRlZmluZWQnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ equal; }\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/helpers.js\");\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nfunction equalArray(left, right) {\n    var length = left.length;\n    if (length !== right.length) {\n        return false;\n    }\n    for (var index = length; index-- !== 0;) {\n        if (!equal(left[index], right[index])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction equalArrayBuffer(left, right) {\n    if (left.byteLength !== right.byteLength) {\n        return false;\n    }\n    var view1 = new DataView(left.buffer);\n    var view2 = new DataView(right.buffer);\n    var index = left.byteLength;\n    while (index--) {\n        if (view1.getUint8(index) !== view2.getUint8(index)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction equalMap(left, right) {\n    var e_1, _a, e_2, _b;\n    if (left.size !== right.size) {\n        return false;\n    }\n    try {\n        for (var _c = __values(left.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var index = _d.value;\n            if (!right.has(index[0])) {\n                return false;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    try {\n        for (var _e = __values(left.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var index = _f.value;\n            if (!equal(index[1], right.get(index[0]))) {\n                return false;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return true;\n}\nfunction equalSet(left, right) {\n    var e_3, _a;\n    if (left.size !== right.size) {\n        return false;\n    }\n    try {\n        for (var _b = __values(left.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var index = _c.value;\n            if (!right.has(index[0])) {\n                return false;\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return true;\n}\nfunction equal(left, right) {\n    if (left === right) {\n        return true;\n    }\n    if (left && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(left) && right && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(right)) {\n        if (left.constructor !== right.constructor) {\n            return false;\n        }\n        if (Array.isArray(left) && Array.isArray(right)) {\n            return equalArray(left, right);\n        }\n        if (left instanceof Map && right instanceof Map) {\n            return equalMap(left, right);\n        }\n        if (left instanceof Set && right instanceof Set) {\n            return equalSet(left, right);\n        }\n        if (ArrayBuffer.isView(left) && ArrayBuffer.isView(right)) {\n            return equalArrayBuffer(left, right);\n        }\n        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isRegex)(left) && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isRegex)(right)) {\n            return left.source === right.source && left.flags === right.flags;\n        }\n        if (left.valueOf !== Object.prototype.valueOf) {\n            return left.valueOf() === right.valueOf();\n        }\n        if (left.toString !== Object.prototype.toString) {\n            return left.toString() === right.toString();\n        }\n        var leftKeys = Object.keys(left);\n        var rightKeys = Object.keys(right);\n        if (leftKeys.length !== rightKeys.length) {\n            return false;\n        }\n        for (var index = leftKeys.length; index-- !== 0;) {\n            if (!Object.prototype.hasOwnProperty.call(right, leftKeys[index])) {\n                return false;\n            }\n        }\n        for (var index = leftKeys.length; index-- !== 0;) {\n            var key = leftKeys[index];\n            if (key === '_owner' && left.$$typeof) {\n                // React-specific: avoid traversing React elements' _owner.\n                //  _owner contains circular references\n                // and is not needed when comparing the actual elements (and not their owners)\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            if (!equal(left[key], right[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (Number.isNaN(left) && Number.isNaN(right)) {\n        return true;\n    }\n    return left === right;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy9AZ2lsYmFyYmFyYS9kZWVwLWVxdWFsL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdCQUFnQixTQUFJLElBQUksU0FBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFRLG1CQUFtQixrREFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFPLFVBQVUsaURBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWZsb2F0ZXIvbm9kZV9tb2R1bGVzL0BnaWxiYXJiYXJhL2RlZXAtZXF1YWwvZXNtL2luZGV4LmpzPzA3ZDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuaW1wb3J0IHsgaXNPYmplY3QsIGlzUmVnZXggfSBmcm9tICcuL2hlbHBlcnMnO1xuZnVuY3Rpb24gZXF1YWxBcnJheShsZWZ0LCByaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbmRleCA9IGxlbmd0aDsgaW5kZXgtLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFlcXVhbChsZWZ0W2luZGV4XSwgcmlnaHRbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXF1YWxBcnJheUJ1ZmZlcihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmJ5dGVMZW5ndGggIT09IHJpZ2h0LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmlldzEgPSBuZXcgRGF0YVZpZXcobGVmdC5idWZmZXIpO1xuICAgIHZhciB2aWV3MiA9IG5ldyBEYXRhVmlldyhyaWdodC5idWZmZXIpO1xuICAgIHZhciBpbmRleCA9IGxlZnQuYnl0ZUxlbmd0aDtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAodmlldzEuZ2V0VWludDgoaW5kZXgpICE9PSB2aWV3Mi5nZXRVaW50OChpbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVxdWFsTWFwKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgaWYgKGxlZnQuc2l6ZSAhPT0gcmlnaHQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMobGVmdC5lbnRyaWVzKCkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfZC52YWx1ZTtcbiAgICAgICAgICAgIGlmICghcmlnaHQuaGFzKGluZGV4WzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhsZWZ0LmVudHJpZXMoKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCFlcXVhbChpbmRleFsxXSwgcmlnaHQuZ2V0KGluZGV4WzBdKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXF1YWxTZXQobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICBpZiAobGVmdC5zaXplICE9PSByaWdodC5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhsZWZ0LmVudHJpZXMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCFyaWdodC5oYXMoaW5kZXhbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVmdCAmJiBpc09iamVjdChsZWZ0KSAmJiByaWdodCAmJiBpc09iamVjdChyaWdodCkpIHtcbiAgICAgICAgaWYgKGxlZnQuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbEFycmF5KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIE1hcCAmJiByaWdodCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsTWFwKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFNldCAmJiByaWdodCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsU2V0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGxlZnQpICYmIEFycmF5QnVmZmVyLmlzVmlldyhyaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbEFycmF5QnVmZmVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdleChsZWZ0KSAmJiBpc1JlZ2V4KHJpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQuc291cmNlID09PSByaWdodC5zb3VyY2UgJiYgbGVmdC5mbGFncyA9PT0gcmlnaHQuZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdC52YWx1ZU9mKCkgPT09IHJpZ2h0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQudG9TdHJpbmcoKSA9PT0gcmlnaHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdEtleXMgPSBPYmplY3Qua2V5cyhsZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0S2V5cyA9IE9iamVjdC5rZXlzKHJpZ2h0KTtcbiAgICAgICAgaWYgKGxlZnRLZXlzLmxlbmd0aCAhPT0gcmlnaHRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gbGVmdEtleXMubGVuZ3RoOyBpbmRleC0tICE9PSAwOykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmlnaHQsIGxlZnRLZXlzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSBsZWZ0S2V5cy5sZW5ndGg7IGluZGV4LS0gIT09IDA7KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbGVmdEtleXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgbGVmdC4kJHR5cGVvZikge1xuICAgICAgICAgICAgICAgIC8vIFJlYWN0LXNwZWNpZmljOiBhdm9pZCB0cmF2ZXJzaW5nIFJlYWN0IGVsZW1lbnRzJyBfb3duZXIuXG4gICAgICAgICAgICAgICAgLy8gIF9vd25lciBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIG5vdCBuZWVkZWQgd2hlbiBjb21wYXJpbmcgdGhlIGFjdHVhbCBlbGVtZW50cyAoYW5kIG5vdCB0aGVpciBvd25lcnMpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVxdWFsKGxlZnRba2V5XSwgcmlnaHRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4obGVmdCkgJiYgTnVtYmVyLmlzTmFOKHJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/node_modules/is-lite/esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-floater/node_modules/is-lite/esm/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getObjectType: function() { return /* binding */ getObjectType; }\n/* harmony export */ });\nvar DOM_PROPERTIES_TO_CHECK = [\n    'innerHTML',\n    'ownerDocument',\n    'style',\n    'attributes',\n    'nodeValue',\n];\nvar objectTypes = [\n    'Array',\n    'ArrayBuffer',\n    'AsyncFunction',\n    'AsyncGenerator',\n    'AsyncGeneratorFunction',\n    'Date',\n    'Error',\n    'Function',\n    'Generator',\n    'GeneratorFunction',\n    'HTMLElement',\n    'Map',\n    'Object',\n    'Promise',\n    'RegExp',\n    'Set',\n    'WeakMap',\n    'WeakSet',\n];\nvar primitiveTypes = [\n    'bigint',\n    'boolean',\n    'null',\n    'number',\n    'string',\n    'symbol',\n    'undefined',\n];\nfunction getObjectType(value) {\n    var objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n    if (/HTML\\w+Element/.test(objectTypeName)) {\n        return 'HTMLElement';\n    }\n    if (isObjectType(objectTypeName)) {\n        return objectTypeName;\n    }\n    return undefined;\n}\nfunction isObjectOfType(type) {\n    return function (value) { return getObjectType(value) === type; };\n}\nfunction isObjectType(name) {\n    return objectTypes.includes(name);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isOfType(type) {\n    return function (value) { return typeof value === type; };\n}\nfunction isPrimitiveType(name) {\n    return primitiveTypes.includes(name);\n}\nfunction is(value) {\n    if (value === null) {\n        return 'null';\n    }\n    switch (typeof value) {\n        case 'bigint':\n            return 'bigint';\n        case 'boolean':\n            return 'boolean';\n        case 'number':\n            return 'number';\n        case 'string':\n            return 'string';\n        case 'symbol':\n            return 'symbol';\n        case 'undefined':\n            return 'undefined';\n        default:\n    }\n    if (is.array(value)) {\n        return 'Array';\n    }\n    if (is.plainFunction(value)) {\n        return 'Function';\n    }\n    var tagType = getObjectType(value);\n    /* istanbul ignore else */\n    if (tagType) {\n        return tagType;\n    }\n    /* istanbul ignore next */\n    return 'Object';\n}\nis.array = Array.isArray;\nis.arrayOf = function (target, predicate) {\n    if (!is.array(target) && !is.function(predicate)) {\n        return false;\n    }\n    return target.every(function (d) { return predicate(d); });\n};\nis.asyncGeneratorFunction = function (value) {\n    return getObjectType(value) === 'AsyncGeneratorFunction';\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nis.asyncFunction = isObjectOfType('AsyncFunction');\nis.bigint = isOfType('bigint');\nis.boolean = function (value) {\n    return value === true || value === false;\n};\nis.date = isObjectOfType('Date');\nis.defined = function (value) { return !is.undefined(value); };\nis.domElement = function (value) {\n    return (is.object(value) &&\n        !is.plainObject(value) &&\n        value.nodeType === 1 &&\n        is.string(value.nodeName) &&\n        DOM_PROPERTIES_TO_CHECK.every(function (property) { return property in value; }));\n};\nis.empty = function (value) {\n    return ((is.string(value) && value.length === 0) ||\n        (is.array(value) && value.length === 0) ||\n        (is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0) ||\n        (is.set(value) && value.size === 0) ||\n        (is.map(value) && value.size === 0));\n};\nis.error = isObjectOfType('Error');\n// eslint-disable-next-line @typescript-eslint/ban-types\nis.function = isOfType('function');\nis.generator = function (value) {\n    return (is.iterable(value) &&\n        is.function(value.next) &&\n        is.function(value.throw));\n};\nis.generatorFunction = isObjectOfType('GeneratorFunction');\nis.instanceOf = function (instance, class_) {\n    if (!instance || !class_) {\n        return false;\n    }\n    return Object.getPrototypeOf(instance) === class_.prototype;\n};\nis.iterable = function (value) {\n    return (!is.nullOrUndefined(value) && is.function(value[Symbol.iterator]));\n};\nis.map = isObjectOfType('Map');\nis.nan = function (value) {\n    return Number.isNaN(value);\n};\nis.null = function (value) {\n    return value === null;\n};\nis.nullOrUndefined = function (value) {\n    return is.null(value) || is.undefined(value);\n};\nis.number = function (value) {\n    return isOfType('number')(value) && !is.nan(value);\n};\nis.numericString = function (value) {\n    return is.string(value) && value.length > 0 && !Number.isNaN(Number(value));\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nis.object = function (value) {\n    return !is.nullOrUndefined(value) && (is.function(value) || typeof value === 'object');\n};\nis.oneOf = function (target, value) {\n    if (!is.array(target)) {\n        return false;\n    }\n    // eslint-disable-next-line unicorn/prefer-includes\n    return target.indexOf(value) > -1;\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nis.plainFunction = isObjectOfType('Function');\nis.plainObject = function (value) {\n    if (getObjectType(value) !== 'Object') {\n        return false;\n    }\n    var prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.getPrototypeOf({});\n};\nis.primitive = function (value) {\n    return is.null(value) || isPrimitiveType(typeof value);\n};\nis.promise = isObjectOfType('Promise');\nis.propertyOf = function (target, key, predicate) {\n    if (!is.object(target) || !key) {\n        return false;\n    }\n    var value = target[key];\n    if (is.function(predicate)) {\n        return predicate(value);\n    }\n    return is.defined(value);\n};\nis.regexp = isObjectOfType('RegExp');\nis.set = isObjectOfType('Set');\nis.string = isOfType('string');\nis.symbol = isOfType('symbol');\nis.undefined = isOfType('undefined');\nis.weakMap = isObjectOfType('WeakMap');\nis.weakSet = isObjectOfType('WeakSet');\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (is);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy9pcy1saXRlL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QjtBQUN4QiwrREFBZSxFQUFFLEVBQUM7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWZsb2F0ZXIvbm9kZV9tb2R1bGVzL2lzLWxpdGUvZXNtL2luZGV4LmpzP2FjMDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERPTV9QUk9QRVJUSUVTX1RPX0NIRUNLID0gW1xuICAgICdpbm5lckhUTUwnLFxuICAgICdvd25lckRvY3VtZW50JyxcbiAgICAnc3R5bGUnLFxuICAgICdhdHRyaWJ1dGVzJyxcbiAgICAnbm9kZVZhbHVlJyxcbl07XG52YXIgb2JqZWN0VHlwZXMgPSBbXG4gICAgJ0FycmF5JyxcbiAgICAnQXJyYXlCdWZmZXInLFxuICAgICdBc3luY0Z1bmN0aW9uJyxcbiAgICAnQXN5bmNHZW5lcmF0b3InLFxuICAgICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJyxcbiAgICAnRGF0ZScsXG4gICAgJ0Vycm9yJyxcbiAgICAnRnVuY3Rpb24nLFxuICAgICdHZW5lcmF0b3InLFxuICAgICdHZW5lcmF0b3JGdW5jdGlvbicsXG4gICAgJ0hUTUxFbGVtZW50JyxcbiAgICAnTWFwJyxcbiAgICAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsXG4gICAgJ1JlZ0V4cCcsXG4gICAgJ1NldCcsXG4gICAgJ1dlYWtNYXAnLFxuICAgICdXZWFrU2V0Jyxcbl07XG52YXIgcHJpbWl0aXZlVHlwZXMgPSBbXG4gICAgJ2JpZ2ludCcsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdudWxsJyxcbiAgICAnbnVtYmVyJyxcbiAgICAnc3RyaW5nJyxcbiAgICAnc3ltYm9sJyxcbiAgICAndW5kZWZpbmVkJyxcbl07XG5leHBvcnQgZnVuY3Rpb24gZ2V0T2JqZWN0VHlwZSh2YWx1ZSkge1xuICAgIHZhciBvYmplY3RUeXBlTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICAgIGlmICgvSFRNTFxcdytFbGVtZW50Ly50ZXN0KG9iamVjdFR5cGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gJ0hUTUxFbGVtZW50JztcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0VHlwZShvYmplY3RUeXBlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFR5cGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNPYmplY3RPZlR5cGUodHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGdldE9iamVjdFR5cGUodmFsdWUpID09PSB0eXBlOyB9O1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlKG5hbWUpIHtcbiAgICByZXR1cm4gb2JqZWN0VHlwZXMuaW5jbHVkZXMobmFtZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNPZlR5cGUodHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gdHlwZTsgfTtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLmluY2x1ZGVzKG5hbWUpO1xufVxuZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgIHJldHVybiAnYmlnaW50JztcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBpZiAoaXMuYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBpZiAoaXMucGxhaW5GdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgfVxuICAgIHZhciB0YWdUeXBlID0gZ2V0T2JqZWN0VHlwZSh2YWx1ZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGFnVHlwZSkge1xuICAgICAgICByZXR1cm4gdGFnVHlwZTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJ09iamVjdCc7XG59XG5pcy5hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5pcy5hcnJheU9mID0gZnVuY3Rpb24gKHRhcmdldCwgcHJlZGljYXRlKSB7XG4gICAgaWYgKCFpcy5hcnJheSh0YXJnZXQpICYmICFpcy5mdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5ldmVyeShmdW5jdGlvbiAoZCkgeyByZXR1cm4gcHJlZGljYXRlKGQpOyB9KTtcbn07XG5pcy5hc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE9iamVjdFR5cGUodmFsdWUpID09PSAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbic7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmlzLmFzeW5jRnVuY3Rpb24gPSBpc09iamVjdE9mVHlwZSgnQXN5bmNGdW5jdGlvbicpO1xuaXMuYmlnaW50ID0gaXNPZlR5cGUoJ2JpZ2ludCcpO1xuaXMuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59O1xuaXMuZGF0ZSA9IGlzT2JqZWN0T2ZUeXBlKCdEYXRlJyk7XG5pcy5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhaXMudW5kZWZpbmVkKHZhbHVlKTsgfTtcbmlzLmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzLm9iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgIWlzLnBsYWluT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICBpcy5zdHJpbmcodmFsdWUubm9kZU5hbWUpICYmXG4gICAgICAgIERPTV9QUk9QRVJUSUVTX1RPX0NIRUNLLmV2ZXJ5KGZ1bmN0aW9uIChwcm9wZXJ0eSkgeyByZXR1cm4gcHJvcGVydHkgaW4gdmFsdWU7IH0pKTtcbn07XG5pcy5lbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoaXMuYXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKGlzLm9iamVjdCh2YWx1ZSkgJiYgIWlzLm1hcCh2YWx1ZSkgJiYgIWlzLnNldCh2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKGlzLnNldCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA9PT0gMCkgfHxcbiAgICAgICAgKGlzLm1hcCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA9PT0gMCkpO1xufTtcbmlzLmVycm9yID0gaXNPYmplY3RPZlR5cGUoJ0Vycm9yJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuaXMuZnVuY3Rpb24gPSBpc09mVHlwZSgnZnVuY3Rpb24nKTtcbmlzLmdlbmVyYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAoaXMuaXRlcmFibGUodmFsdWUpICYmXG4gICAgICAgIGlzLmZ1bmN0aW9uKHZhbHVlLm5leHQpICYmXG4gICAgICAgIGlzLmZ1bmN0aW9uKHZhbHVlLnRocm93KSk7XG59O1xuaXMuZ2VuZXJhdG9yRnVuY3Rpb24gPSBpc09iamVjdE9mVHlwZSgnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbmlzLmluc3RhbmNlT2YgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNsYXNzXykge1xuICAgIGlmICghaW5zdGFuY2UgfHwgIWNsYXNzXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpID09PSBjbGFzc18ucHJvdG90eXBlO1xufTtcbmlzLml0ZXJhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICghaXMubnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJiBpcy5mdW5jdGlvbih2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKSk7XG59O1xuaXMubWFwID0gaXNPYmplY3RPZlR5cGUoJ01hcCcpO1xuaXMubmFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc05hTih2YWx1ZSk7XG59O1xuaXMubnVsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn07XG5pcy5udWxsT3JVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXMubnVsbCh2YWx1ZSkgfHwgaXMudW5kZWZpbmVkKHZhbHVlKTtcbn07XG5pcy5udW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPZlR5cGUoJ251bWJlcicpKHZhbHVlKSAmJiAhaXMubmFuKHZhbHVlKTtcbn07XG5pcy5udW1lcmljU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCAmJiAhTnVtYmVyLmlzTmFOKE51bWJlcih2YWx1ZSkpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5pcy5vYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzLm51bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiYgKGlzLmZ1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbn07XG5pcy5vbmVPZiA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgaWYgKCFpcy5hcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgcmV0dXJuIHRhcmdldC5pbmRleE9mKHZhbHVlKSA+IC0xO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5pcy5wbGFpbkZ1bmN0aW9uID0gaXNPYmplY3RPZlR5cGUoJ0Z1bmN0aW9uJyk7XG5pcy5wbGFpbk9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChnZXRPYmplY3RUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbn07XG5pcy5wcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXMubnVsbCh2YWx1ZSkgfHwgaXNQcmltaXRpdmVUeXBlKHR5cGVvZiB2YWx1ZSk7XG59O1xuaXMucHJvbWlzZSA9IGlzT2JqZWN0T2ZUeXBlKCdQcm9taXNlJyk7XG5pcy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCBwcmVkaWNhdGUpIHtcbiAgICBpZiAoIWlzLm9iamVjdCh0YXJnZXQpIHx8ICFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoaXMuZnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzLmRlZmluZWQodmFsdWUpO1xufTtcbmlzLnJlZ2V4cCA9IGlzT2JqZWN0T2ZUeXBlKCdSZWdFeHAnKTtcbmlzLnNldCA9IGlzT2JqZWN0T2ZUeXBlKCdTZXQnKTtcbmlzLnN0cmluZyA9IGlzT2ZUeXBlKCdzdHJpbmcnKTtcbmlzLnN5bWJvbCA9IGlzT2ZUeXBlKCdzeW1ib2wnKTtcbmlzLnVuZGVmaW5lZCA9IGlzT2ZUeXBlKCd1bmRlZmluZWQnKTtcbmlzLndlYWtNYXAgPSBpc09iamVjdE9mVHlwZSgnV2Vha01hcCcpO1xuaXMud2Vha1NldCA9IGlzT2JqZWN0T2ZUeXBlKCdXZWFrU2V0Jyk7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCBkZWZhdWx0IGlzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/node_modules/is-lite/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/helpers.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-floater/node_modules/tree-changes/esm/helpers.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canHaveLength: function() { return /* binding */ canHaveLength; },\n/* harmony export */   checkEquality: function() { return /* binding */ checkEquality; },\n/* harmony export */   compareNumbers: function() { return /* binding */ compareNumbers; },\n/* harmony export */   compareValues: function() { return /* binding */ compareValues; },\n/* harmony export */   getIterables: function() { return /* binding */ getIterables; },\n/* harmony export */   hasEntry: function() { return /* binding */ hasEntry; },\n/* harmony export */   hasExtraKeys: function() { return /* binding */ hasExtraKeys; },\n/* harmony export */   hasValue: function() { return /* binding */ hasValue; },\n/* harmony export */   includesOrEqualsTo: function() { return /* binding */ includesOrEqualsTo; },\n/* harmony export */   isEqualPredicate: function() { return /* binding */ isEqualPredicate; },\n/* harmony export */   isSameType: function() { return /* binding */ isSameType; },\n/* harmony export */   nested: function() { return /* binding */ nested; }\n/* harmony export */ });\n/* harmony import */ var _gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gilbarbara/deep-equal */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/index.js\");\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-lite */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/is-lite/esm/index.js\");\n\n\nfunction canHaveLength() {\n    var arguments_ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arguments_[_i] = arguments[_i];\n    }\n    return arguments_.every(function (d) { return is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(d); });\n}\nfunction checkEquality(left, right, value) {\n    if (!isSameType(left, right)) {\n        return false;\n    }\n    if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array)) {\n        return !left.some(hasValue(value)) && right.some(hasValue(value));\n    }\n    /* istanbul ignore else */\n    if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n        return (!Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value)));\n    }\n    return right === value;\n}\nfunction compareNumbers(previousData, data, options) {\n    var actual = options.actual, key = options.key, previous = options.previous, type = options.type;\n    var left = nested(previousData, key);\n    var right = nested(data, key);\n    var changed = [left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number) && (type === 'increased' ? left < right : left > right);\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].undefined(actual)) {\n        changed = changed && right === actual;\n    }\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].undefined(previous)) {\n        changed = changed && left === previous;\n    }\n    return changed;\n}\nfunction compareValues(previousData, data, options) {\n    var key = options.key, type = options.type, value = options.value;\n    var left = nested(previousData, key);\n    var right = nested(data, key);\n    var primary = type === 'added' ? left : right;\n    var secondary = type === 'added' ? right : left;\n    // console.log({ primary, secondary });\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nullOrUndefined(value)) {\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(primary)) {\n            // check if nested data matches\n            if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(primary) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(primary)) {\n                return checkEquality(primary, secondary, value);\n            }\n        }\n        else {\n            return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(secondary, value);\n        }\n        return false;\n    }\n    if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array)) {\n        return !secondary.every(isEqualPredicate(primary));\n    }\n    if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n        return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n    }\n    return (![left, right].every(function (d) { return is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].primitive(d) && is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(d); }) &&\n        (type === 'added'\n            ? !is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(left) && is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(right)\n            : is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(left) && !is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(right)));\n}\nfunction getIterables(previousData, data, _a) {\n    var _b = _a === void 0 ? {} : _a, key = _b.key;\n    var left = nested(previousData, key);\n    var right = nested(data, key);\n    if (!isSameType(left, right)) {\n        throw new TypeError('Inputs have different types');\n    }\n    if (!canHaveLength(left, right)) {\n        throw new TypeError(\"Inputs don't have length\");\n    }\n    if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n        left = Object.keys(left);\n        right = Object.keys(right);\n    }\n    return [left, right];\n}\nfunction hasEntry(input) {\n    return function (_a) {\n        var key = _a[0], value = _a[1];\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(input)) {\n            return ((0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value) ||\n                input.some(function (d) { return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value) || (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(value) && isEqualPredicate(value)(d)); }));\n        }\n        /* istanbul ignore else */\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(input) && input[key]) {\n            return !!input[key] && (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input[key], value);\n        }\n        return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value);\n    };\n}\nfunction hasExtraKeys(left, right) {\n    return right.some(function (d) { return !left.includes(d); });\n}\nfunction hasValue(input) {\n    return function (value) {\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(input)) {\n            return input.some(function (d) { return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value) || (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(value) && isEqualPredicate(value)(d)); });\n        }\n        return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value);\n    };\n}\nfunction includesOrEqualsTo(previousValue, value) {\n    return is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(previousValue)\n        ? previousValue.some(function (d) { return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value); })\n        : (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(previousValue, value);\n}\nfunction isEqualPredicate(data) {\n    return function (value) { return data.some(function (d) { return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value); }); };\n}\nfunction isSameType() {\n    var arguments_ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arguments_[_i] = arguments[_i];\n    }\n    return (arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array) ||\n        arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number) ||\n        arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject) ||\n        arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string));\n}\nfunction nested(data, property) {\n    /* istanbul ignore else */\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(data) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(data)) {\n        /* istanbul ignore else */\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string(property)) {\n            var props = property.split('.');\n            return props.reduce(function (acc, d) { return acc && acc[d]; }, data);\n        }\n        /* istanbul ignore else */\n        if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(property)) {\n            return data[property];\n        }\n        return data;\n    }\n    return data;\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy90cmVlLWNoYW5nZXMvZXNtL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDbEI7QUFDbEI7QUFDUDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLCtDQUFFLGNBQWMsK0NBQUUsYUFBYSwrQ0FBRSxrQkFBa0I7QUFDckc7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBRTtBQUN4QyxTQUFTLCtDQUFFO0FBQ1g7QUFDQTtBQUNBLFNBQVMsK0NBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsU0FBUywrQ0FBRTtBQUNYLFlBQVksK0NBQUU7QUFDZDtBQUNBLGdCQUFnQiwrQ0FBRSxtQkFBbUIsK0NBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFFO0FBQzlCO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQUU7QUFDOUI7QUFDQTtBQUNBLGdEQUFnRCxPQUFPLCtDQUFFLGlCQUFpQiwrQ0FBRSxjQUFjO0FBQzFGO0FBQ0EsZUFBZSwrQ0FBRSxrQkFBa0IsK0NBQUU7QUFDckMsY0FBYywrQ0FBRSxtQkFBbUIsK0NBQUU7QUFDckM7QUFDTztBQUNQLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLCtDQUFFO0FBQ2Qsb0JBQW9CLGtFQUFLO0FBQ3pCLDBDQUEwQyxPQUFPLGtFQUFLLGVBQWUsK0NBQUUsK0NBQStDO0FBQ3RIO0FBQ0E7QUFDQSxZQUFZLCtDQUFFO0FBQ2QsbUNBQW1DLGtFQUFLO0FBQ3hDO0FBQ0EsZUFBZSxrRUFBSztBQUNwQjtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsMkJBQTJCO0FBQ2hFO0FBQ087QUFDUDtBQUNBLFlBQVksK0NBQUU7QUFDZCw2Q0FBNkMsT0FBTyxrRUFBSyxlQUFlLCtDQUFFLCtDQUErQztBQUN6SDtBQUNBLGVBQWUsa0VBQUs7QUFDcEI7QUFDQTtBQUNPO0FBQ1AsV0FBVywrQ0FBRTtBQUNiLDRDQUE0QyxPQUFPLGtFQUFLLGFBQWE7QUFDckUsVUFBVSxrRUFBSztBQUNmO0FBQ087QUFDUCw4QkFBOEIsZ0NBQWdDLE9BQU8sa0VBQUssYUFBYTtBQUN2RjtBQUNPO0FBQ1A7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQUU7QUFDL0IseUJBQXlCLCtDQUFFO0FBQzNCLHlCQUF5QiwrQ0FBRTtBQUMzQix5QkFBeUIsK0NBQUU7QUFDM0I7QUFDTztBQUNQO0FBQ0EsUUFBUSwrQ0FBRSxzQkFBc0IsK0NBQUU7QUFDbEM7QUFDQSxZQUFZLCtDQUFFO0FBQ2Q7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQSxZQUFZLCtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWZsb2F0ZXIvbm9kZV9tb2R1bGVzL3RyZWUtY2hhbmdlcy9lc20vaGVscGVycy5qcz8zYWFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlcXVhbCBmcm9tICdAZ2lsYmFyYmFyYS9kZWVwLWVxdWFsJztcbmltcG9ydCBpcyBmcm9tICdpcy1saXRlJztcbmV4cG9ydCBmdW5jdGlvbiBjYW5IYXZlTGVuZ3RoKCkge1xuICAgIHZhciBhcmd1bWVudHNfID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJndW1lbnRzX1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRzXy5ldmVyeShmdW5jdGlvbiAoZCkgeyByZXR1cm4gaXMuc3RyaW5nKGQpIHx8IGlzLmFycmF5KGQpIHx8IGlzLnBsYWluT2JqZWN0KGQpOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0VxdWFsaXR5KGxlZnQsIHJpZ2h0LCB2YWx1ZSkge1xuICAgIGlmICghaXNTYW1lVHlwZShsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5hcnJheSkpIHtcbiAgICAgICAgcmV0dXJuICFsZWZ0LnNvbWUoaGFzVmFsdWUodmFsdWUpKSAmJiByaWdodC5zb21lKGhhc1ZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKFtsZWZ0LCByaWdodF0uZXZlcnkoaXMucGxhaW5PYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAoIU9iamVjdC5lbnRyaWVzKGxlZnQpLnNvbWUoaGFzRW50cnkodmFsdWUpKSAmJiBPYmplY3QuZW50cmllcyhyaWdodCkuc29tZShoYXNFbnRyeSh2YWx1ZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0ID09PSB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlTnVtYmVycyhwcmV2aW91c0RhdGEsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWN0dWFsID0gb3B0aW9ucy5hY3R1YWwsIGtleSA9IG9wdGlvbnMua2V5LCBwcmV2aW91cyA9IG9wdGlvbnMucHJldmlvdXMsIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdmFyIGxlZnQgPSBuZXN0ZWQocHJldmlvdXNEYXRhLCBrZXkpO1xuICAgIHZhciByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICAgIHZhciBjaGFuZ2VkID0gW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5udW1iZXIpICYmICh0eXBlID09PSAnaW5jcmVhc2VkJyA/IGxlZnQgPCByaWdodCA6IGxlZnQgPiByaWdodCk7XG4gICAgaWYgKCFpcy51bmRlZmluZWQoYWN0dWFsKSkge1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCAmJiByaWdodCA9PT0gYWN0dWFsO1xuICAgIH1cbiAgICBpZiAoIWlzLnVuZGVmaW5lZChwcmV2aW91cykpIHtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgJiYgbGVmdCA9PT0gcHJldmlvdXM7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZXMocHJldmlvdXNEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5LCB0eXBlID0gb3B0aW9ucy50eXBlLCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGxlZnQgPSBuZXN0ZWQocHJldmlvdXNEYXRhLCBrZXkpO1xuICAgIHZhciByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICAgIHZhciBwcmltYXJ5ID0gdHlwZSA9PT0gJ2FkZGVkJyA/IGxlZnQgOiByaWdodDtcbiAgICB2YXIgc2Vjb25kYXJ5ID0gdHlwZSA9PT0gJ2FkZGVkJyA/IHJpZ2h0IDogbGVmdDtcbiAgICAvLyBjb25zb2xlLmxvZyh7IHByaW1hcnksIHNlY29uZGFyeSB9KTtcbiAgICBpZiAoIWlzLm51bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzLmRlZmluZWQocHJpbWFyeSkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5lc3RlZCBkYXRhIG1hdGNoZXNcbiAgICAgICAgICAgIGlmIChpcy5hcnJheShwcmltYXJ5KSB8fCBpcy5wbGFpbk9iamVjdChwcmltYXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0VxdWFsaXR5KHByaW1hcnksIHNlY29uZGFyeSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVxdWFsKHNlY29uZGFyeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFtsZWZ0LCByaWdodF0uZXZlcnkoaXMuYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiAhc2Vjb25kYXJ5LmV2ZXJ5KGlzRXF1YWxQcmVkaWNhdGUocHJpbWFyeSkpO1xuICAgIH1cbiAgICBpZiAoW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5wbGFpbk9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGhhc0V4dHJhS2V5cyhPYmplY3Qua2V5cyhwcmltYXJ5KSwgT2JqZWN0LmtleXMoc2Vjb25kYXJ5KSk7XG4gICAgfVxuICAgIHJldHVybiAoIVtsZWZ0LCByaWdodF0uZXZlcnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGlzLnByaW1pdGl2ZShkKSAmJiBpcy5kZWZpbmVkKGQpOyB9KSAmJlxuICAgICAgICAodHlwZSA9PT0gJ2FkZGVkJ1xuICAgICAgICAgICAgPyAhaXMuZGVmaW5lZChsZWZ0KSAmJiBpcy5kZWZpbmVkKHJpZ2h0KVxuICAgICAgICAgICAgOiBpcy5kZWZpbmVkKGxlZnQpICYmICFpcy5kZWZpbmVkKHJpZ2h0KSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZXJhYmxlcyhwcmV2aW91c0RhdGEsIGRhdGEsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGtleSA9IF9iLmtleTtcbiAgICB2YXIgbGVmdCA9IG5lc3RlZChwcmV2aW91c0RhdGEsIGtleSk7XG4gICAgdmFyIHJpZ2h0ID0gbmVzdGVkKGRhdGEsIGtleSk7XG4gICAgaWYgKCFpc1NhbWVUeXBlKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dHMgaGF2ZSBkaWZmZXJlbnQgdHlwZXMnKTtcbiAgICB9XG4gICAgaWYgKCFjYW5IYXZlTGVuZ3RoKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW5wdXRzIGRvbid0IGhhdmUgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBpZiAoW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5wbGFpbk9iamVjdCkpIHtcbiAgICAgICAgbGVmdCA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICAgICAgICByaWdodCA9IE9iamVjdC5rZXlzKHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzRW50cnkoaW5wdXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgaWYgKGlzLmFycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIChlcXVhbChpbnB1dCwgdmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgaW5wdXQuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZXF1YWwoZCwgdmFsdWUpIHx8IChpcy5hcnJheSh2YWx1ZSkgJiYgaXNFcXVhbFByZWRpY2F0ZSh2YWx1ZSkoZCkpOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzLnBsYWluT2JqZWN0KGlucHV0KSAmJiBpbnB1dFtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gISFpbnB1dFtrZXldICYmIGVxdWFsKGlucHV0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXF1YWwoaW5wdXQsIHZhbHVlKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0V4dHJhS2V5cyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiByaWdodC5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiAhbGVmdC5pbmNsdWRlcyhkKTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUoaW5wdXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpcy5hcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBlcXVhbChkLCB2YWx1ZSkgfHwgKGlzLmFycmF5KHZhbHVlKSAmJiBpc0VxdWFsUHJlZGljYXRlKHZhbHVlKShkKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcXVhbChpbnB1dCwgdmFsdWUpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXNPckVxdWFsc1RvKHByZXZpb3VzVmFsdWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzLmFycmF5KHByZXZpb3VzVmFsdWUpXG4gICAgICAgID8gcHJldmlvdXNWYWx1ZS5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBlcXVhbChkLCB2YWx1ZSk7IH0pXG4gICAgICAgIDogZXF1YWwocHJldmlvdXNWYWx1ZSwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWxQcmVkaWNhdGUoZGF0YSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRhdGEuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZXF1YWwoZCwgdmFsdWUpOyB9KTsgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NhbWVUeXBlKCkge1xuICAgIHZhciBhcmd1bWVudHNfID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJndW1lbnRzX1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZ3VtZW50c18uZXZlcnkoaXMuYXJyYXkpIHx8XG4gICAgICAgIGFyZ3VtZW50c18uZXZlcnkoaXMubnVtYmVyKSB8fFxuICAgICAgICBhcmd1bWVudHNfLmV2ZXJ5KGlzLnBsYWluT2JqZWN0KSB8fFxuICAgICAgICBhcmd1bWVudHNfLmV2ZXJ5KGlzLnN0cmluZykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5lc3RlZChkYXRhLCBwcm9wZXJ0eSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzLnBsYWluT2JqZWN0KGRhdGEpIHx8IGlzLmFycmF5KGRhdGEpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpcy5zdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBkKSB7IHJldHVybiBhY2MgJiYgYWNjW2RdOyB9LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXMubnVtYmVyKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-floater/node_modules/tree-changes/esm/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ treeChanges; }\n/* harmony export */ });\n/* harmony import */ var _gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @gilbarbara/deep-equal */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/@gilbarbara/deep-equal/esm/index.js\");\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-lite */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/is-lite/esm/index.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/helpers.js\");\n\n\n\nfunction treeChanges(previousData, data) {\n    if ([previousData, data].some(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nullOrUndefined)) {\n        throw new Error('Missing required parameters');\n    }\n    if (![previousData, data].every(function (d) { return is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(d); })) {\n        throw new Error('Expected plain objects or array');\n    }\n    var added = function (key, value) {\n        try {\n            return (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.compareValues)(previousData, data, { key: key, type: 'added', value: value });\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var changed = function (key, actual, previous) {\n        try {\n            var left = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.nested)(previousData, key);\n            var right = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.nested)(data, key);\n            var hasActual = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(actual);\n            var hasPrevious = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(previous);\n            if (hasActual || hasPrevious) {\n                var leftComparator = hasPrevious\n                    ? (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.includesOrEqualsTo)(previous, left)\n                    : !(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.includesOrEqualsTo)(actual, left);\n                var rightComparator = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.includesOrEqualsTo)(actual, right);\n                return leftComparator && rightComparator;\n            }\n            if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array) || [left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n                return !(0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(left, right);\n            }\n            return left !== right;\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var changedFrom = function (key, previous, actual) {\n        if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n            return false;\n        }\n        try {\n            var left = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.nested)(previousData, key);\n            var right = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.nested)(data, key);\n            var hasActual = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(actual);\n            return ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.includesOrEqualsTo)(previous, left) &&\n                (hasActual ? (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.includesOrEqualsTo)(actual, right) : !hasActual));\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    /**\n     * @deprecated\n     * Use \"changed\" instead\n     */\n    var changedTo = function (key, actual) {\n        if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n            return false;\n        }\n        /* istanbul ignore next */\n        if (true) {\n            // eslint-disable-next-line no-console\n            console.warn('`changedTo` is deprecated! Replace it with `change`');\n        }\n        return changed(key, actual);\n    };\n    var decreased = function (key, actual, previous) {\n        if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n            return false;\n        }\n        try {\n            return (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(previousData, data, { key: key, actual: actual, previous: previous, type: 'decreased' });\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var emptied = function (key) {\n        try {\n            var _a = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getIterables)(previousData, data, { key: key }), left = _a[0], right = _a[1];\n            return !!left.length && !right.length;\n        }\n        catch (_b) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var filled = function (key) {\n        try {\n            var _a = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getIterables)(previousData, data, { key: key }), left = _a[0], right = _a[1];\n            return !left.length && !!right.length;\n        }\n        catch (_b) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var increased = function (key, actual, previous) {\n        if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n            return false;\n        }\n        try {\n            return (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.compareNumbers)(previousData, data, { key: key, actual: actual, previous: previous, type: 'increased' });\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    var removed = function (key, value) {\n        try {\n            return (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.compareValues)(previousData, data, { key: key, type: 'removed', value: value });\n        }\n        catch (_a) {\n            /* istanbul ignore next */\n            return false;\n        }\n    };\n    return { added: added, changed: changed, changedFrom: changedFrom, changedTo: changedTo, decreased: decreased, emptied: emptied, filled: filled, increased: increased, removed: removed };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mbG9hdGVyL25vZGVfbW9kdWxlcy90cmVlLWNoYW5nZXMvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDbEI7QUFDMkU7QUFDckY7QUFDZixrQ0FBa0MsK0NBQUU7QUFDcEM7QUFDQTtBQUNBLG1EQUFtRCxPQUFPLCtDQUFFLG1CQUFtQiwrQ0FBRSxZQUFZO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFhLHVCQUF1Qix1Q0FBdUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBTTtBQUM3Qix3QkFBd0IsZ0RBQU07QUFDOUIsNEJBQTRCLCtDQUFFO0FBQzlCLDhCQUE4QiwrQ0FBRTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCLDREQUFrQjtBQUN4Qyx1QkFBdUIsNERBQWtCO0FBQ3pDLHNDQUFzQyw0REFBa0I7QUFDeEQ7QUFDQTtBQUNBLG9DQUFvQywrQ0FBRSwrQkFBK0IsK0NBQUU7QUFDdkUsd0JBQXdCLGtFQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU07QUFDN0Isd0JBQXdCLGdEQUFNO0FBQzlCLDRCQUE0QiwrQ0FBRTtBQUM5QixvQkFBb0IsNERBQWtCO0FBQ3RDLDZCQUE2Qiw0REFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWMsdUJBQXVCLGlFQUFpRTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFZLHVCQUF1QixVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBWSx1QkFBdUIsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBYyx1QkFBdUIsaUVBQWlFO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWEsdUJBQXVCLHlDQUF5QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWZsb2F0ZXIvbm9kZV9tb2R1bGVzL3RyZWUtY2hhbmdlcy9lc20vaW5kZXguanM/ZDhkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXF1YWwgZnJvbSAnQGdpbGJhcmJhcmEvZGVlcC1lcXVhbCc7XG5pbXBvcnQgaXMgZnJvbSAnaXMtbGl0ZSc7XG5pbXBvcnQgeyBjb21wYXJlTnVtYmVycywgY29tcGFyZVZhbHVlcywgZ2V0SXRlcmFibGVzLCBpbmNsdWRlc09yRXF1YWxzVG8sIG5lc3RlZCB9IGZyb20gJy4vaGVscGVycyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmVlQ2hhbmdlcyhwcmV2aW91c0RhdGEsIGRhdGEpIHtcbiAgICBpZiAoW3ByZXZpb3VzRGF0YSwgZGF0YV0uc29tZShpcy5udWxsT3JVbmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIGlmICghW3ByZXZpb3VzRGF0YSwgZGF0YV0uZXZlcnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGlzLnBsYWluT2JqZWN0KGQpIHx8IGlzLmFycmF5KGQpOyB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBsYWluIG9iamVjdHMgb3IgYXJyYXknKTtcbiAgICB9XG4gICAgdmFyIGFkZGVkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmFsdWVzKHByZXZpb3VzRGF0YSwgZGF0YSwgeyBrZXk6IGtleSwgdHlwZTogJ2FkZGVkJywgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNoYW5nZWQgPSBmdW5jdGlvbiAoa2V5LCBhY3R1YWwsIHByZXZpb3VzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IG5lc3RlZChwcmV2aW91c0RhdGEsIGtleSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBuZXN0ZWQoZGF0YSwga2V5KTtcbiAgICAgICAgICAgIHZhciBoYXNBY3R1YWwgPSBpcy5kZWZpbmVkKGFjdHVhbCk7XG4gICAgICAgICAgICB2YXIgaGFzUHJldmlvdXMgPSBpcy5kZWZpbmVkKHByZXZpb3VzKTtcbiAgICAgICAgICAgIGlmIChoYXNBY3R1YWwgfHwgaGFzUHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvbXBhcmF0b3IgPSBoYXNQcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICA/IGluY2x1ZGVzT3JFcXVhbHNUbyhwcmV2aW91cywgbGVmdClcbiAgICAgICAgICAgICAgICAgICAgOiAhaW5jbHVkZXNPckVxdWFsc1RvKGFjdHVhbCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29tcGFyYXRvciA9IGluY2x1ZGVzT3JFcXVhbHNUbyhhY3R1YWwsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdENvbXBhcmF0b3IgJiYgcmlnaHRDb21wYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFtsZWZ0LCByaWdodF0uZXZlcnkoaXMuYXJyYXkpIHx8IFtsZWZ0LCByaWdodF0uZXZlcnkoaXMucGxhaW5PYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlcXVhbChsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hhbmdlZEZyb20gPSBmdW5jdGlvbiAoa2V5LCBwcmV2aW91cywgYWN0dWFsKSB7XG4gICAgICAgIGlmICghaXMuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbmVzdGVkKHByZXZpb3VzRGF0YSwga2V5KTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICAgICAgICAgICAgdmFyIGhhc0FjdHVhbCA9IGlzLmRlZmluZWQoYWN0dWFsKTtcbiAgICAgICAgICAgIHJldHVybiAoaW5jbHVkZXNPckVxdWFsc1RvKHByZXZpb3VzLCBsZWZ0KSAmJlxuICAgICAgICAgICAgICAgIChoYXNBY3R1YWwgPyBpbmNsdWRlc09yRXF1YWxzVG8oYWN0dWFsLCByaWdodCkgOiAhaGFzQWN0dWFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFVzZSBcImNoYW5nZWRcIiBpbnN0ZWFkXG4gICAgICovXG4gICAgdmFyIGNoYW5nZWRUbyA9IGZ1bmN0aW9uIChrZXksIGFjdHVhbCkge1xuICAgICAgICBpZiAoIWlzLmRlZmluZWQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYGNoYW5nZWRUb2AgaXMgZGVwcmVjYXRlZCEgUmVwbGFjZSBpdCB3aXRoIGBjaGFuZ2VgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQoa2V5LCBhY3R1YWwpO1xuICAgIH07XG4gICAgdmFyIGRlY3JlYXNlZCA9IGZ1bmN0aW9uIChrZXksIGFjdHVhbCwgcHJldmlvdXMpIHtcbiAgICAgICAgaWYgKCFpcy5kZWZpbmVkKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKHByZXZpb3VzRGF0YSwgZGF0YSwgeyBrZXk6IGtleSwgYWN0dWFsOiBhY3R1YWwsIHByZXZpb3VzOiBwcmV2aW91cywgdHlwZTogJ2RlY3JlYXNlZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZW1wdGllZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldEl0ZXJhYmxlcyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5OiBrZXkgfSksIGxlZnQgPSBfYVswXSwgcmlnaHQgPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiAhIWxlZnQubGVuZ3RoICYmICFyaWdodC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZmlsbGVkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0SXRlcmFibGVzKHByZXZpb3VzRGF0YSwgZGF0YSwgeyBrZXk6IGtleSB9KSwgbGVmdCA9IF9hWzBdLCByaWdodCA9IF9hWzFdO1xuICAgICAgICAgICAgcmV0dXJuICFsZWZ0Lmxlbmd0aCAmJiAhIXJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbmNyZWFzZWQgPSBmdW5jdGlvbiAoa2V5LCBhY3R1YWwsIHByZXZpb3VzKSB7XG4gICAgICAgIGlmICghaXMuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTnVtYmVycyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5OiBrZXksIGFjdHVhbDogYWN0dWFsLCBwcmV2aW91czogcHJldmlvdXMsIHR5cGU6ICdpbmNyZWFzZWQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlbW92ZWQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWYWx1ZXMocHJldmlvdXNEYXRhLCBkYXRhLCB7IGtleToga2V5LCB0eXBlOiAncmVtb3ZlZCcsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IGFkZGVkOiBhZGRlZCwgY2hhbmdlZDogY2hhbmdlZCwgY2hhbmdlZEZyb206IGNoYW5nZWRGcm9tLCBjaGFuZ2VkVG86IGNoYW5nZWRUbywgZGVjcmVhc2VkOiBkZWNyZWFzZWQsIGVtcHRpZWQ6IGVtcHRpZWQsIGZpbGxlZDogZmlsbGVkLCBpbmNyZWFzZWQ6IGluY3JlYXNlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xufVxuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-floater/node_modules/tree-changes/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-innertext/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-innertext/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar hasProps = function (jsx) {\n    return Object.prototype.hasOwnProperty.call(jsx, 'props');\n};\nvar reduceJsxToString = function (previous, current) {\n    return previous + innerText(current);\n};\nvar innerText = function (jsx) {\n    if (jsx === null ||\n        typeof jsx === 'boolean' ||\n        typeof jsx === 'undefined') {\n        return '';\n    }\n    if (typeof jsx === 'number') {\n        return jsx.toString();\n    }\n    if (typeof jsx === 'string') {\n        return jsx;\n    }\n    if (Array.isArray(jsx)) {\n        return jsx.reduce(reduceJsxToString, '');\n    }\n    if (hasProps(jsx) &&\n        Object.prototype.hasOwnProperty.call(jsx.props, 'children')) {\n        return innerText(jsx.props.children);\n    }\n    return '';\n};\ninnerText.default = innerText;\nmodule.exports = innerText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbm5lcnRleHQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbm5lcnRleHQvaW5kZXguanM/Zjg2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBoYXNQcm9wcyA9IGZ1bmN0aW9uIChqc3gpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzeCwgJ3Byb3BzJyk7XG59O1xudmFyIHJlZHVjZUpzeFRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIHByZXZpb3VzICsgaW5uZXJUZXh0KGN1cnJlbnQpO1xufTtcbnZhciBpbm5lclRleHQgPSBmdW5jdGlvbiAoanN4KSB7XG4gICAgaWYgKGpzeCA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YganN4ID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZW9mIGpzeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGpzeC50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGpzeDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanN4KSkge1xuICAgICAgICByZXR1cm4ganN4LnJlZHVjZShyZWR1Y2VKc3hUb1N0cmluZywgJycpO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvcHMoanN4KSAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanN4LnByb3BzLCAnY2hpbGRyZW4nKSkge1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0KGpzeC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5pbm5lclRleHQuZGVmYXVsdCA9IGlubmVyVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gaW5uZXJUZXh0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-innertext/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz82NDM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0pBQXlEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz9lMDgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/scroll/index.js":
/*!**************************************!*\
  !*** ./node_modules/scroll/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var E_NOSCROLL = new Error('Element already at target scroll position')\nvar E_CANCELLED = new Error('Scroll cancelled')\nvar min = Math.min\nvar ms = Date.now\n\nmodule.exports = {\n  left: make('scrollLeft'),\n  top: make('scrollTop')\n}\n\nfunction make (prop) {\n  return function scroll (el, to, opts, cb) {\n    opts = opts || {}\n\n    if (typeof opts == 'function') cb = opts, opts = {}\n    if (typeof cb != 'function') cb = noop\n\n    var start = ms()\n    var from = el[prop]\n    var ease = opts.ease || inOutSine\n    var duration = !isNaN(opts.duration) ? +opts.duration : 350\n    var cancelled = false\n\n    return from === to ?\n      cb(E_NOSCROLL, el[prop]) :\n      requestAnimationFrame(animate), cancel\n\n    function cancel () {\n      cancelled = true\n    }\n\n    function animate (timestamp) {\n      if (cancelled) return cb(E_CANCELLED, el[prop])\n\n      var now = ms()\n      var time = min(1, ((now - start) / duration))\n      var eased = ease(time)\n\n      el[prop] = (eased * (to - from)) + from\n\n      time < 1 ?\n        requestAnimationFrame(animate) :\n        requestAnimationFrame(function () {\n          cb(null, el[prop])\n        })\n    }\n  }\n}\n\nfunction inOutSine (n) {\n  return 0.5 * (1 - Math.cos(Math.PI * n))\n}\n\nfunction noop () {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zY3JvbGwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Njcm9sbC9pbmRleC5qcz85YmI4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBFX05PU0NST0xMID0gbmV3IEVycm9yKCdFbGVtZW50IGFscmVhZHkgYXQgdGFyZ2V0IHNjcm9sbCBwb3NpdGlvbicpXG52YXIgRV9DQU5DRUxMRUQgPSBuZXcgRXJyb3IoJ1Njcm9sbCBjYW5jZWxsZWQnKVxudmFyIG1pbiA9IE1hdGgubWluXG52YXIgbXMgPSBEYXRlLm5vd1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGVmdDogbWFrZSgnc2Nyb2xsTGVmdCcpLFxuICB0b3A6IG1ha2UoJ3Njcm9sbFRvcCcpXG59XG5cbmZ1bmN0aW9uIG1ha2UgKHByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNjcm9sbCAoZWwsIHRvLCBvcHRzLCBjYikge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykgY2IgPSBvcHRzLCBvcHRzID0ge31cbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpIGNiID0gbm9vcFxuXG4gICAgdmFyIHN0YXJ0ID0gbXMoKVxuICAgIHZhciBmcm9tID0gZWxbcHJvcF1cbiAgICB2YXIgZWFzZSA9IG9wdHMuZWFzZSB8fCBpbk91dFNpbmVcbiAgICB2YXIgZHVyYXRpb24gPSAhaXNOYU4ob3B0cy5kdXJhdGlvbikgPyArb3B0cy5kdXJhdGlvbiA6IDM1MFxuICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIGZyb20gPT09IHRvID9cbiAgICAgIGNiKEVfTk9TQ1JPTEwsIGVsW3Byb3BdKSA6XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSksIGNhbmNlbFxuXG4gICAgZnVuY3Rpb24gY2FuY2VsICgpIHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlICh0aW1lc3RhbXApIHtcbiAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybiBjYihFX0NBTkNFTExFRCwgZWxbcHJvcF0pXG5cbiAgICAgIHZhciBub3cgPSBtcygpXG4gICAgICB2YXIgdGltZSA9IG1pbigxLCAoKG5vdyAtIHN0YXJ0KSAvIGR1cmF0aW9uKSlcbiAgICAgIHZhciBlYXNlZCA9IGVhc2UodGltZSlcblxuICAgICAgZWxbcHJvcF0gPSAoZWFzZWQgKiAodG8gLSBmcm9tKSkgKyBmcm9tXG5cbiAgICAgIHRpbWUgPCAxID9cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpIDpcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYihudWxsLCBlbFtwcm9wXSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5PdXRTaW5lIChuKSB7XG4gIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBuKSlcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/scroll/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/scrollparent/scrollparent.js":
/*!***************************************************!*\
  !*** ./node_modules/scrollparent/scrollparent.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function () {\n  function isScrolling(node) {\n    var overflow = getComputedStyle(node, null).getPropertyValue(\"overflow\");\n\n    return overflow.indexOf(\"scroll\") > -1 || overflow.indexOf(\"auto\") > - 1;\n  }\n\n  function scrollParent(node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return undefined;\n    }\n\n    var current = node.parentNode;\n    while (current.parentNode) {\n      if (isScrolling(current)) {\n        return current;\n      }\n\n      current = current.parentNode;\n    }\n\n    return document.scrollingElement || document.documentElement;\n  }\n\n  return scrollParent;\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zY3JvbGxwYXJlbnQvc2Nyb2xscGFyZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRCxJQUFJLGlDQUFPLEVBQUUsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUN2QixJQUFJLEtBQUssRUFJTjtBQUNILENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zY3JvbGxwYXJlbnQvc2Nyb2xscGFyZW50LmpzPzdlMDkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuU2Nyb2xscGFyZW50ID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gaXNTY3JvbGxpbmcobm9kZSkge1xuICAgIHZhciBvdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpO1xuXG4gICAgcmV0dXJuIG92ZXJmbG93LmluZGV4T2YoXCJzY3JvbGxcIikgPiAtMSB8fCBvdmVyZmxvdy5pbmRleE9mKFwiYXV0b1wiKSA+IC0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFBhcmVudChub2RlKSB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAoY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoaXNTY3JvbGxpbmcoY3VycmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIHNjcm9sbFBhcmVudDtcbn0pKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/scrollparent/scrollparent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/dashboard/components/DashboardShell.jsx":
/*!*****************************************************!*\
  !*** ./app/dashboard/components/DashboardShell.jsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DashboardShell; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react_joyride__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-joyride */ \"(app-pages-browser)/./node_modules/react-joyride/dist/index.mjs\");\n/* harmony import */ var _lib_supabase_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/supabase-browser */ \"(app-pages-browser)/./lib/supabase-browser.js\");\n/* harmony import */ var _Sidebar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Sidebar */ \"(app-pages-browser)/./app/dashboard/components/Sidebar.jsx\");\n/* harmony import */ var _Topbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Topbar */ \"(app-pages-browser)/./app/dashboard/components/Topbar.jsx\");\n/* harmony import */ var _CSVGenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CSVGenerator */ \"(app-pages-browser)/./app/dashboard/components/CSVGenerator.jsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction DashboardShell() {\n    _s();\n    const supabase = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>(0,_lib_supabase_browser__WEBPACK_IMPORTED_MODULE_3__.getBrowserClient)(), []);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [email, setEmail] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [hasNew, setHasNew] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // red dot on bell\n    const [runTour, setRunTour] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // joyride state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let mounted = true;\n        (async ()=>{\n            var _data_user_user_metadata;\n            const { data } = await supabase.auth.getUser();\n            if (!mounted) return;\n            if (!(data === null || data === void 0 ? void 0 : data.user)) {\n                router.replace(\"/auth\");\n                return;\n            }\n            var _data_user_email;\n            setEmail((_data_user_email = data.user.email) !== null && _data_user_email !== void 0 ? _data_user_email : \"\");\n            // show red dot if user hasn't seen the tour yet (metadata flag missing/false)\n            const seen = !!((_data_user_user_metadata = data.user.user_metadata) === null || _data_user_user_metadata === void 0 ? void 0 : _data_user_user_metadata.has_seen_tour);\n            setHasNew(!seen);\n            setLoading(false);\n        })();\n        return ()=>{\n            mounted = false;\n        };\n    }, [\n        supabase,\n        router\n    ]);\n    async function markTourSeen() {\n        try {\n            await supabase.auth.updateUser({\n                data: {\n                    has_seen_tour: true\n                }\n            });\n        } catch (_) {}\n        setHasNew(false);\n    }\n    function startTour() {\n        setRunTour(true);\n    }\n    function onTourEnd(data) {\n        const finished = [\n            react_joyride__WEBPACK_IMPORTED_MODULE_7__.STATUS.FINISHED,\n            react_joyride__WEBPACK_IMPORTED_MODULE_7__.STATUS.SKIPPED\n        ].includes(data.status);\n        if (finished) {\n            setRunTour(false);\n            // user accepted or skipped  stop showing badge\n            markTourSeen();\n        }\n    }\n    async function signOut() {\n        await supabase.auth.signOut();\n        router.replace(\"/auth\");\n    }\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen grid place-items-center bg-neutral-950 text-neutral-300\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"animate-pulse text-sm\",\n                children: \"Loading your workspace\"\n            }, void 0, false, {\n                fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                lineNumber: 66,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n            lineNumber: 65,\n            columnNumber: 7\n        }, this);\n    }\n    // Joyride steps: we target elements annotated in CSVGenerator with data-tour=\"...\"\n    const steps = [\n        {\n            target: '[data-tour=\"ids\"]',\n            title: \"Add employees\",\n            content: \"Paste or type employee IDs. Commas, spaces, or new lines are all fine.\",\n            disableBeacon: true\n        },\n        {\n            target: '[data-tour=\"dates\"]',\n            title: \"Pick your date range\",\n            content: \"Choose the first and last working day for this schedule.\"\n        },\n        {\n            target: '[data-tour=\"times\"]',\n            title: \"Set shift timings\",\n            content: \"Enter login and logout times. If its a night shift, turn on Next day logout.\"\n        },\n        {\n            target: '[data-tour=\"options\"]',\n            title: \"Skip days\",\n            content: \"Skip weekends or any weekdays you dont need. The preview updates instantly.\"\n        },\n        {\n            target: '[data-tour=\"export\"]',\n            title: \"Preview & export\",\n            content: \"Download the CSV or share it. On desktop, the live preview is on the right.\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-neutral-950 text-neutral-100\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_joyride__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                run: runTour,\n                steps: steps,\n                continuous: true,\n                showSkipButton: true,\n                showProgress: true,\n                disableOverlayClose: true,\n                styles: {\n                    options: {\n                        zIndex: 9999,\n                        primaryColor: \"#6366f1\",\n                        textColor: \"#e5e5e5\",\n                        backgroundColor: \"#0f0f10\",\n                        arrowColor: \"#0f0f10\"\n                    },\n                    tooltip: {\n                        border: \"1px solid #1f1f1f\",\n                        borderRadius: 12\n                    },\n                    buttonNext: {\n                        borderRadius: 10\n                    },\n                    buttonBack: {\n                        color: \"#a3a3a3\"\n                    },\n                    spotlight: {\n                        borderRadius: 12\n                    }\n                },\n                callback: onTourEnd\n            }, void 0, false, {\n                fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                lineNumber: 104,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 lg:grid-cols-[260px_1fr]\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Sidebar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                        fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                        lineNumber: 137,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                        className: \"min-h-screen border-l border-neutral-900 bg-neutral-950/60\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Topbar__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                email: email,\n                                onSignOut: signOut,\n                                hasNew: hasNew,\n                                onStartTour: ()=>{\n                                    setRunTour(true);\n                                },\n                                onDismissNew: markTourSeen\n                            }, void 0, false, {\n                                fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                                lineNumber: 139,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"px-6 sm:px-10 pb-12\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_CSVGenerator__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                                    fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                                    lineNumber: 149,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                                lineNumber: 148,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                        lineNumber: 138,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n                lineNumber: 136,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/workspaces/login-signup/app/dashboard/components/DashboardShell.jsx\",\n        lineNumber: 102,\n        columnNumber: 5\n    }, this);\n}\n_s(DashboardShell, \"Y1AydIPeNFGfRWPNcMsOqlE7+3o=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = DashboardShell;\nvar _c;\n$RefreshReg$(_c, \"DashboardShell\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXNoYm9hcmQvY29tcG9uZW50cy9EYXNoYm9hcmRTaGVsbC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRXFEO0FBQ1Q7QUFDSTtBQUNVO0FBQzFCO0FBQ0Y7QUFDWTtBQUUzQixTQUFTVTs7SUFDdEIsTUFBTUMsV0FBV1YsOENBQU9BLENBQUMsSUFBTUssdUVBQWdCQSxJQUFJLEVBQUU7SUFDckQsTUFBTU0sU0FBU1QsMERBQVNBO0lBQ3hCLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNhLE9BQU9DLFNBQVMsR0FBR2QsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDZSxRQUFRQyxVQUFVLEdBQUdoQiwrQ0FBUUEsQ0FBQyxRQUFVLGtCQUFrQjtJQUNqRSxNQUFNLENBQUNpQixTQUFTQyxXQUFXLEdBQUdsQiwrQ0FBUUEsQ0FBQyxRQUFRLGdCQUFnQjtJQUUvREYsZ0RBQVNBLENBQUM7UUFDUixJQUFJcUIsVUFBVTtRQUNiO2dCQVVnQkM7WUFUZixNQUFNLEVBQUVBLElBQUksRUFBRSxHQUFHLE1BQU1YLFNBQVNZLElBQUksQ0FBQ0MsT0FBTztZQUM1QyxJQUFJLENBQUNILFNBQVM7WUFFZCxJQUFJLEVBQUNDLGlCQUFBQSwyQkFBQUEsS0FBTUcsSUFBSSxHQUFFO2dCQUNmYixPQUFPYyxPQUFPLENBQUM7Z0JBQ2Y7WUFDRjtnQkFDU0o7WUFBVE4sU0FBU00sQ0FBQUEsbUJBQUFBLEtBQUtHLElBQUksQ0FBQ1YsS0FBSyxjQUFmTyw4QkFBQUEsbUJBQW1CO1lBQzVCLDhFQUE4RTtZQUM5RSxNQUFNSyxPQUFPLENBQUMsR0FBQ0wsMkJBQUFBLEtBQUtHLElBQUksQ0FBQ0csYUFBYSxjQUF2Qk4sK0NBQUFBLHlCQUF5Qk8sYUFBYTtZQUNyRFgsVUFBVSxDQUFDUztZQUNYYixXQUFXO1FBQ2I7UUFDQSxPQUFPO1lBQVFPLFVBQVU7UUFBTztJQUNsQyxHQUFHO1FBQUNWO1FBQVVDO0tBQU87SUFFckIsZUFBZWtCO1FBQ2IsSUFBSTtZQUNGLE1BQU1uQixTQUFTWSxJQUFJLENBQUNRLFVBQVUsQ0FBQztnQkFBRVQsTUFBTTtvQkFBRU8sZUFBZTtnQkFBSztZQUFFO1FBQ2pFLEVBQUUsT0FBT0csR0FBRyxDQUFDO1FBQ2JkLFVBQVU7SUFDWjtJQUVBLFNBQVNlO1FBQ1BiLFdBQVc7SUFDYjtJQUVBLFNBQVNjLFVBQVVaLElBQUk7UUFDckIsTUFBTWEsV0FBVztZQUFDOUIsaURBQU1BLENBQUMrQixRQUFRO1lBQUUvQixpREFBTUEsQ0FBQ2dDLE9BQU87U0FBQyxDQUFDQyxRQUFRLENBQUNoQixLQUFLaUIsTUFBTTtRQUN2RSxJQUFJSixVQUFVO1lBQ1pmLFdBQVc7WUFDWCxnREFBZ0Q7WUFDaERVO1FBQ0Y7SUFDRjtJQUVBLGVBQWVVO1FBQ2IsTUFBTTdCLFNBQVNZLElBQUksQ0FBQ2lCLE9BQU87UUFDM0I1QixPQUFPYyxPQUFPLENBQUM7SUFDakI7SUFFQSxJQUFJYixTQUFTO1FBQ1gscUJBQ0UsOERBQUM0QjtZQUFJQyxXQUFVO3NCQUNiLDRFQUFDRDtnQkFBSUMsV0FBVTswQkFBd0I7Ozs7Ozs7Ozs7O0lBRzdDO0lBRUEsbUZBQW1GO0lBQ25GLE1BQU1DLFFBQVE7UUFDWjtZQUNFQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsU0FBUztZQUNUQyxlQUFlO1FBQ2pCO1FBQ0E7WUFDRUgsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLFNBQVM7UUFDWDtRQUNBO1lBQ0VGLFFBQVE7WUFDUkMsT0FBTztZQUNQQyxTQUFTO1FBQ1g7UUFDQTtZQUNFRixRQUFRO1lBQ1JDLE9BQU87WUFDUEMsU0FBUztRQUNYO1FBQ0E7WUFDRUYsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLFNBQVM7UUFDWDtLQUNEO0lBRUQscUJBQ0UsOERBQUNMO1FBQUlDLFdBQVU7OzBCQUViLDhEQUFDdEMscURBQU9BO2dCQUNONEMsS0FBSzdCO2dCQUNMd0IsT0FBT0E7Z0JBQ1BNLFVBQVU7Z0JBQ1ZDLGNBQWM7Z0JBQ2RDLFlBQVk7Z0JBQ1pDLG1CQUFtQjtnQkFDbkJDLFFBQVE7b0JBQ05DLFNBQVM7d0JBQ1BDLFFBQVE7d0JBQ1JDLGNBQWM7d0JBQ2RDLFdBQVc7d0JBQ1hDLGlCQUFpQjt3QkFDakJDLFlBQVk7b0JBQ2Q7b0JBQ0FDLFNBQVM7d0JBQ1BDLFFBQVE7d0JBQ1JDLGNBQWM7b0JBQ2hCO29CQUNBQyxZQUFZO3dCQUNWRCxjQUFjO29CQUNoQjtvQkFDQUUsWUFBWTt3QkFDVkMsT0FBTztvQkFDVDtvQkFDQUMsV0FBVzt3QkFDVEosY0FBYztvQkFDaEI7Z0JBQ0Y7Z0JBQ0FLLFVBQVVqQzs7Ozs7OzBCQUdaLDhEQUFDTztnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNuQyxnREFBT0E7Ozs7O2tDQUNSLDhEQUFDNkQ7d0JBQUsxQixXQUFVOzswQ0FDZCw4REFBQ2xDLCtDQUFNQTtnQ0FDTE8sT0FBT0E7Z0NBQ1BzRCxXQUFXN0I7Z0NBQ1h2QixRQUFRQTtnQ0FDUnFELGFBQWE7b0NBQ1hsRCxXQUFXO2dDQUNiO2dDQUNBbUQsY0FBY3pDOzs7Ozs7MENBRWhCLDhEQUFDVztnQ0FBSUMsV0FBVTswQ0FDYiw0RUFBQ2pDLHFEQUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU16QjtHQWhKd0JDOztRQUVQUCxzREFBU0E7OztLQUZGTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvZGFzaGJvYXJkL2NvbXBvbmVudHMvRGFzaGJvYXJkU2hlbGwuanN4P2E4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCBKb3lyaWRlLCB7IFNUQVRVUyB9IGZyb20gXCJyZWFjdC1qb3lyaWRlXCI7XG5pbXBvcnQgeyBnZXRCcm93c2VyQ2xpZW50IH0gZnJvbSBcIkAvbGliL3N1cGFiYXNlLWJyb3dzZXJcIjtcbmltcG9ydCBTaWRlYmFyIGZyb20gXCIuL1NpZGViYXJcIjtcbmltcG9ydCBUb3BiYXIgZnJvbSBcIi4vVG9wYmFyXCI7XG5pbXBvcnQgQ1NWR2VuZXJhdG9yIGZyb20gXCIuL0NTVkdlbmVyYXRvclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmRTaGVsbCgpIHtcbiAgY29uc3Qgc3VwYWJhc2UgPSB1c2VNZW1vKCgpID0+IGdldEJyb3dzZXJDbGllbnQoKSwgW10pO1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlbWFpbCwgc2V0RW1haWxdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtoYXNOZXcsIHNldEhhc05ld10gPSB1c2VTdGF0ZShmYWxzZSk7ICAgLy8gcmVkIGRvdCBvbiBiZWxsXG4gIGNvbnN0IFtydW5Ub3VyLCBzZXRSdW5Ub3VyXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gam95cmlkZSBzdGF0ZVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG1vdW50ZWQgPSB0cnVlO1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghZGF0YT8udXNlcikge1xuICAgICAgICByb3V0ZXIucmVwbGFjZShcIi9hdXRoXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRFbWFpbChkYXRhLnVzZXIuZW1haWwgPz8gXCJcIik7XG4gICAgICAvLyBzaG93IHJlZCBkb3QgaWYgdXNlciBoYXNuJ3Qgc2VlbiB0aGUgdG91ciB5ZXQgKG1ldGFkYXRhIGZsYWcgbWlzc2luZy9mYWxzZSlcbiAgICAgIGNvbnN0IHNlZW4gPSAhIWRhdGEudXNlci51c2VyX21ldGFkYXRhPy5oYXNfc2Vlbl90b3VyO1xuICAgICAgc2V0SGFzTmV3KCFzZWVuKTtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuICgpID0+IHsgbW91bnRlZCA9IGZhbHNlOyB9O1xuICB9LCBbc3VwYWJhc2UsIHJvdXRlcl0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtUb3VyU2VlbigpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3VwYWJhc2UuYXV0aC51cGRhdGVVc2VyKHsgZGF0YTogeyBoYXNfc2Vlbl90b3VyOiB0cnVlIH0gfSk7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICBzZXRIYXNOZXcoZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRUb3VyKCkge1xuICAgIHNldFJ1blRvdXIodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdXJFbmQoZGF0YSkge1xuICAgIGNvbnN0IGZpbmlzaGVkID0gW1NUQVRVUy5GSU5JU0hFRCwgU1RBVFVTLlNLSVBQRURdLmluY2x1ZGVzKGRhdGEuc3RhdHVzKTtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHNldFJ1blRvdXIoZmFsc2UpO1xuICAgICAgLy8gdXNlciBhY2NlcHRlZCBvciBza2lwcGVkIOKGkiBzdG9wIHNob3dpbmcgYmFkZ2VcbiAgICAgIG1hcmtUb3VyU2VlbigpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNpZ25PdXQoKSB7XG4gICAgYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduT3V0KCk7XG4gICAgcm91dGVyLnJlcGxhY2UoXCIvYXV0aFwiKTtcbiAgfVxuXG4gIGlmIChsb2FkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGdyaWQgcGxhY2UtaXRlbXMtY2VudGVyIGJnLW5ldXRyYWwtOTUwIHRleHQtbmV1dHJhbC0zMDBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXB1bHNlIHRleHQtc21cIj5Mb2FkaW5nIHlvdXIgd29ya3NwYWNl4oCmPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLy8gSm95cmlkZSBzdGVwczogd2UgdGFyZ2V0IGVsZW1lbnRzIGFubm90YXRlZCBpbiBDU1ZHZW5lcmF0b3Igd2l0aCBkYXRhLXRvdXI9XCIuLi5cIlxuICBjb25zdCBzdGVwcyA9IFtcbiAgICB7XG4gICAgICB0YXJnZXQ6ICdbZGF0YS10b3VyPVwiaWRzXCJdJyxcbiAgICAgIHRpdGxlOiBcIkFkZCBlbXBsb3llZXNcIixcbiAgICAgIGNvbnRlbnQ6IFwiUGFzdGUgb3IgdHlwZSBlbXBsb3llZSBJRHMuIENvbW1hcywgc3BhY2VzLCBvciBuZXcgbGluZXMgYXJlIGFsbCBmaW5lLlwiLFxuICAgICAgZGlzYWJsZUJlYWNvbjogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhcmdldDogJ1tkYXRhLXRvdXI9XCJkYXRlc1wiXScsXG4gICAgICB0aXRsZTogXCJQaWNrIHlvdXIgZGF0ZSByYW5nZVwiLFxuICAgICAgY29udGVudDogXCJDaG9vc2UgdGhlIGZpcnN0IGFuZCBsYXN0IHdvcmtpbmcgZGF5IGZvciB0aGlzIHNjaGVkdWxlLlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdGFyZ2V0OiAnW2RhdGEtdG91cj1cInRpbWVzXCJdJyxcbiAgICAgIHRpdGxlOiBcIlNldCBzaGlmdCB0aW1pbmdzXCIsXG4gICAgICBjb250ZW50OiBcIkVudGVyIGxvZ2luIGFuZCBsb2dvdXQgdGltZXMuIElmIGl04oCZcyBhIG5pZ2h0IHNoaWZ0LCB0dXJuIG9uIE5leHQgZGF5IGxvZ291dC5cIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhcmdldDogJ1tkYXRhLXRvdXI9XCJvcHRpb25zXCJdJyxcbiAgICAgIHRpdGxlOiBcIlNraXAgZGF5c1wiLFxuICAgICAgY29udGVudDogXCJTa2lwIHdlZWtlbmRzIG9yIGFueSB3ZWVrZGF5cyB5b3UgZG9u4oCZdCBuZWVkLiBUaGUgcHJldmlldyB1cGRhdGVzIGluc3RhbnRseS5cIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhcmdldDogJ1tkYXRhLXRvdXI9XCJleHBvcnRcIl0nLFxuICAgICAgdGl0bGU6IFwiUHJldmlldyAmIGV4cG9ydFwiLFxuICAgICAgY29udGVudDogXCJEb3dubG9hZCB0aGUgQ1NWIG9yIHNoYXJlIGl0LiBPbiBkZXNrdG9wLCB0aGUgbGl2ZSBwcmV2aWV3IGlzIG9uIHRoZSByaWdodC5cIixcbiAgICB9LFxuICBdO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctbmV1dHJhbC05NTAgdGV4dC1uZXV0cmFsLTEwMFwiPlxuICAgICAgey8qIEd1aWRlZCB0b3VyICovfVxuICAgICAgPEpveXJpZGVcbiAgICAgICAgcnVuPXtydW5Ub3VyfVxuICAgICAgICBzdGVwcz17c3RlcHN9XG4gICAgICAgIGNvbnRpbnVvdXNcbiAgICAgICAgc2hvd1NraXBCdXR0b25cbiAgICAgICAgc2hvd1Byb2dyZXNzXG4gICAgICAgIGRpc2FibGVPdmVybGF5Q2xvc2VcbiAgICAgICAgc3R5bGVzPXt7XG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgICAgICAgcHJpbWFyeUNvbG9yOiBcIiM2MzY2ZjFcIixcbiAgICAgICAgICAgIHRleHRDb2xvcjogXCIjZTVlNWU1XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzBmMGYxMFwiLFxuICAgICAgICAgICAgYXJyb3dDb2xvcjogXCIjMGYwZjEwXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICMxZjFmMWZcIixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMTIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBidXR0b25OZXh0OiB7XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnV0dG9uQmFjazoge1xuICAgICAgICAgICAgY29sb3I6IFwiI2EzYTNhM1wiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3BvdGxpZ2h0OiB7XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDEyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH19XG4gICAgICAgIGNhbGxiYWNrPXtvblRvdXJFbmR9XG4gICAgICAvPlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbGc6Z3JpZC1jb2xzLVsyNjBweF8xZnJdXCI+XG4gICAgICAgIDxTaWRlYmFyIC8+XG4gICAgICAgIDxtYWluIGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBib3JkZXItbCBib3JkZXItbmV1dHJhbC05MDAgYmctbmV1dHJhbC05NTAvNjBcIj5cbiAgICAgICAgICA8VG9wYmFyXG4gICAgICAgICAgICBlbWFpbD17ZW1haWx9XG4gICAgICAgICAgICBvblNpZ25PdXQ9e3NpZ25PdXR9XG4gICAgICAgICAgICBoYXNOZXc9e2hhc05ld31cbiAgICAgICAgICAgIG9uU3RhcnRUb3VyPXsoKSA9PiB7XG4gICAgICAgICAgICAgIHNldFJ1blRvdXIodHJ1ZSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25EaXNtaXNzTmV3PXttYXJrVG91clNlZW59XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInB4LTYgc206cHgtMTAgcGItMTJcIj5cbiAgICAgICAgICAgIDxDU1ZHZW5lcmF0b3IgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9tYWluPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwidXNlUm91dGVyIiwiSm95cmlkZSIsIlNUQVRVUyIsImdldEJyb3dzZXJDbGllbnQiLCJTaWRlYmFyIiwiVG9wYmFyIiwiQ1NWR2VuZXJhdG9yIiwiRGFzaGJvYXJkU2hlbGwiLCJzdXBhYmFzZSIsInJvdXRlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZW1haWwiLCJzZXRFbWFpbCIsImhhc05ldyIsInNldEhhc05ldyIsInJ1blRvdXIiLCJzZXRSdW5Ub3VyIiwibW91bnRlZCIsImRhdGEiLCJhdXRoIiwiZ2V0VXNlciIsInVzZXIiLCJyZXBsYWNlIiwic2VlbiIsInVzZXJfbWV0YWRhdGEiLCJoYXNfc2Vlbl90b3VyIiwibWFya1RvdXJTZWVuIiwidXBkYXRlVXNlciIsIl8iLCJzdGFydFRvdXIiLCJvblRvdXJFbmQiLCJmaW5pc2hlZCIsIkZJTklTSEVEIiwiU0tJUFBFRCIsImluY2x1ZGVzIiwic3RhdHVzIiwic2lnbk91dCIsImRpdiIsImNsYXNzTmFtZSIsInN0ZXBzIiwidGFyZ2V0IiwidGl0bGUiLCJjb250ZW50IiwiZGlzYWJsZUJlYWNvbiIsInJ1biIsImNvbnRpbnVvdXMiLCJzaG93U2tpcEJ1dHRvbiIsInNob3dQcm9ncmVzcyIsImRpc2FibGVPdmVybGF5Q2xvc2UiLCJzdHlsZXMiLCJvcHRpb25zIiwiekluZGV4IiwicHJpbWFyeUNvbG9yIiwidGV4dENvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYXJyb3dDb2xvciIsInRvb2x0aXAiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJidXR0b25OZXh0IiwiYnV0dG9uQmFjayIsImNvbG9yIiwic3BvdGxpZ2h0IiwiY2FsbGJhY2siLCJtYWluIiwib25TaWduT3V0Iiwib25TdGFydFRvdXIiLCJvbkRpc21pc3NOZXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/dashboard/components/DashboardShell.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@gilbarbara/deep-equal/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@gilbarbara/deep-equal/dist/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ equal; }\n/* harmony export */ });\n// src/helpers.ts\nfunction isOfType(type) {\n  return (value) => typeof value === type;\n}\nvar isFunction = isOfType(\"function\");\nvar isNull = (value) => {\n  return value === null;\n};\nvar isRegex = (value) => {\n  return Object.prototype.toString.call(value).slice(8, -1) === \"RegExp\";\n};\nvar isObject = (value) => {\n  return !isUndefined(value) && !isNull(value) && (isFunction(value) || typeof value === \"object\");\n};\nvar isUndefined = isOfType(\"undefined\");\n\n// src/index.ts\nfunction equalArray(left, right) {\n  const { length } = left;\n  if (length !== right.length) {\n    return false;\n  }\n  for (let index = length; index-- !== 0; ) {\n    if (!equal(left[index], right[index])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalArrayBuffer(left, right) {\n  if (left.byteLength !== right.byteLength) {\n    return false;\n  }\n  const view1 = new DataView(left.buffer);\n  const view2 = new DataView(right.buffer);\n  let index = left.byteLength;\n  while (index--) {\n    if (view1.getUint8(index) !== view2.getUint8(index)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalMap(left, right) {\n  if (left.size !== right.size) {\n    return false;\n  }\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n  for (const index of left.entries()) {\n    if (!equal(index[1], right.get(index[0]))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalSet(left, right) {\n  if (left.size !== right.size) {\n    return false;\n  }\n  for (const index of left.entries()) {\n    if (!right.has(index[0])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equal(left, right) {\n  if (left === right) {\n    return true;\n  }\n  if (left && isObject(left) && right && isObject(right)) {\n    if (left.constructor !== right.constructor) {\n      return false;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n      return equalArray(left, right);\n    }\n    if (left instanceof Map && right instanceof Map) {\n      return equalMap(left, right);\n    }\n    if (left instanceof Set && right instanceof Set) {\n      return equalSet(left, right);\n    }\n    if (ArrayBuffer.isView(left) && ArrayBuffer.isView(right)) {\n      return equalArrayBuffer(left, right);\n    }\n    if (isRegex(left) && isRegex(right)) {\n      return left.source === right.source && left.flags === right.flags;\n    }\n    if (left.valueOf !== Object.prototype.valueOf) {\n      return left.valueOf() === right.valueOf();\n    }\n    if (left.toString !== Object.prototype.toString) {\n      return left.toString() === right.toString();\n    }\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) {\n      return false;\n    }\n    for (let index = leftKeys.length; index-- !== 0; ) {\n      if (!Object.prototype.hasOwnProperty.call(right, leftKeys[index])) {\n        return false;\n      }\n    }\n    for (let index = leftKeys.length; index-- !== 0; ) {\n      const key = leftKeys[index];\n      if (key === \"_owner\" && left.$$typeof) {\n        continue;\n      }\n      if (!equal(left[key], right[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (Number.isNaN(left) && Number.isNaN(right)) {\n    return true;\n  }\n  return left === right;\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ2lsYmFyYmFyYS9kZWVwLWVxdWFsL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BnaWxiYXJiYXJhL2RlZXAtZXF1YWwvZGlzdC9pbmRleC5tanM/ZDI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVscGVycy50c1xuZnVuY3Rpb24gaXNPZlR5cGUodHlwZSkge1xuICByZXR1cm4gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IHR5cGU7XG59XG52YXIgaXNGdW5jdGlvbiA9IGlzT2ZUeXBlKFwiZnVuY3Rpb25cIik7XG52YXIgaXNOdWxsID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn07XG52YXIgaXNSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgPT09IFwiUmVnRXhwXCI7XG59O1xudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhaXNVbmRlZmluZWQodmFsdWUpICYmICFpc051bGwodmFsdWUpICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpO1xufTtcbnZhciBpc1VuZGVmaW5lZCA9IGlzT2ZUeXBlKFwidW5kZWZpbmVkXCIpO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGVxdWFsQXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGxlZnQ7XG4gIGlmIChsZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IGxlbmd0aDsgaW5kZXgtLSAhPT0gMDsgKSB7XG4gICAgaWYgKCFlcXVhbChsZWZ0W2luZGV4XSwgcmlnaHRbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVxdWFsQXJyYXlCdWZmZXIobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQuYnl0ZUxlbmd0aCAhPT0gcmlnaHQuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2aWV3MSA9IG5ldyBEYXRhVmlldyhsZWZ0LmJ1ZmZlcik7XG4gIGNvbnN0IHZpZXcyID0gbmV3IERhdGFWaWV3KHJpZ2h0LmJ1ZmZlcik7XG4gIGxldCBpbmRleCA9IGxlZnQuYnl0ZUxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBpZiAodmlldzEuZ2V0VWludDgoaW5kZXgpICE9PSB2aWV3Mi5nZXRVaW50OChpbmRleCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlcXVhbE1hcChsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5zaXplICE9PSByaWdodC5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgaW5kZXggb2YgbGVmdC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXJpZ2h0LmhhcyhpbmRleFswXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiBsZWZ0LmVudHJpZXMoKSkge1xuICAgIGlmICghZXF1YWwoaW5kZXhbMV0sIHJpZ2h0LmdldChpbmRleFswXSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXF1YWxTZXQobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQuc2l6ZSAhPT0gcmlnaHQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGxlZnQuZW50cmllcygpKSB7XG4gICAgaWYgKCFyaWdodC5oYXMoaW5kZXhbMF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxlZnQgJiYgaXNPYmplY3QobGVmdCkgJiYgcmlnaHQgJiYgaXNPYmplY3QocmlnaHQpKSB7XG4gICAgaWYgKGxlZnQuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICByZXR1cm4gZXF1YWxBcnJheShsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgTWFwICYmIHJpZ2h0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICByZXR1cm4gZXF1YWxNYXAobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFNldCAmJiByaWdodCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgcmV0dXJuIGVxdWFsU2V0KGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhsZWZ0KSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcocmlnaHQpKSB7XG4gICAgICByZXR1cm4gZXF1YWxBcnJheUJ1ZmZlcihsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGlmIChpc1JlZ2V4KGxlZnQpICYmIGlzUmVnZXgocmlnaHQpKSB7XG4gICAgICByZXR1cm4gbGVmdC5zb3VyY2UgPT09IHJpZ2h0LnNvdXJjZSAmJiBsZWZ0LmZsYWdzID09PSByaWdodC5mbGFncztcbiAgICB9XG4gICAgaWYgKGxlZnQudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICByZXR1cm4gbGVmdC52YWx1ZU9mKCkgPT09IHJpZ2h0LnZhbHVlT2YoKTtcbiAgICB9XG4gICAgaWYgKGxlZnQudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkgPT09IHJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdCk7XG4gICAgY29uc3QgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHQpO1xuICAgIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSBsZWZ0S2V5cy5sZW5ndGg7IGluZGV4LS0gIT09IDA7ICkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmlnaHQsIGxlZnRLZXlzW2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IGxlZnRLZXlzLmxlbmd0aDsgaW5kZXgtLSAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBrZXkgPSBsZWZ0S2V5c1tpbmRleF07XG4gICAgICBpZiAoa2V5ID09PSBcIl9vd25lclwiICYmIGxlZnQuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWVxdWFsKGxlZnRba2V5XSwgcmlnaHRba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKGxlZnQpICYmIE51bWJlci5pc05hTihyaWdodCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG59XG5leHBvcnQge1xuICBlcXVhbCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@gilbarbara/deep-equal/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/is-lite/dist/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/is-lite/dist/index.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ src_default; }\n/* harmony export */ });\n// src/helpers.ts\nvar objectTypes = [\n  \"Array\",\n  \"ArrayBuffer\",\n  \"AsyncFunction\",\n  \"AsyncGenerator\",\n  \"AsyncGeneratorFunction\",\n  \"Date\",\n  \"Error\",\n  \"Function\",\n  \"Generator\",\n  \"GeneratorFunction\",\n  \"HTMLElement\",\n  \"Map\",\n  \"Object\",\n  \"Promise\",\n  \"RegExp\",\n  \"Set\",\n  \"WeakMap\",\n  \"WeakSet\"\n];\nvar primitiveTypes = [\n  \"bigint\",\n  \"boolean\",\n  \"null\",\n  \"number\",\n  \"string\",\n  \"symbol\",\n  \"undefined\"\n];\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (/HTML\\w+Element/.test(objectTypeName)) {\n    return \"HTMLElement\";\n  }\n  if (isObjectType(objectTypeName)) {\n    return objectTypeName;\n  }\n  return void 0;\n}\nfunction isObjectOfType(type) {\n  return (value) => getObjectType(value) === type;\n}\nfunction isObjectType(name) {\n  return objectTypes.includes(name);\n}\nfunction isOfType(type) {\n  return (value) => typeof value === type;\n}\nfunction isPrimitiveType(name) {\n  return primitiveTypes.includes(name);\n}\n\n// src/index.ts\nvar DOM_PROPERTIES_TO_CHECK = [\n  \"innerHTML\",\n  \"ownerDocument\",\n  \"style\",\n  \"attributes\",\n  \"nodeValue\"\n];\nfunction is(value) {\n  if (value === null) {\n    return \"null\";\n  }\n  switch (typeof value) {\n    case \"bigint\":\n      return \"bigint\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n    case \"string\":\n      return \"string\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"undefined\":\n      return \"undefined\";\n    default:\n  }\n  if (is.array(value)) {\n    return \"Array\";\n  }\n  if (is.plainFunction(value)) {\n    return \"Function\";\n  }\n  const tagType = getObjectType(value);\n  if (tagType) {\n    return tagType;\n  }\n  return \"Object\";\n}\nis.array = Array.isArray;\nis.arrayOf = (target, predicate) => {\n  if (!is.array(target) && !is.function(predicate)) {\n    return false;\n  }\n  return target.every((d) => predicate(d));\n};\nis.asyncGeneratorFunction = (value) => getObjectType(value) === \"AsyncGeneratorFunction\";\nis.asyncFunction = isObjectOfType(\"AsyncFunction\");\nis.bigint = isOfType(\"bigint\");\nis.boolean = (value) => {\n  return value === true || value === false;\n};\nis.date = isObjectOfType(\"Date\");\nis.defined = (value) => !is.undefined(value);\nis.domElement = (value) => {\n  return is.object(value) && !is.plainObject(value) && value.nodeType === 1 && is.string(value.nodeName) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);\n};\nis.empty = (value) => {\n  return is.string(value) && value.length === 0 || is.array(value) && value.length === 0 || is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0 || is.set(value) && value.size === 0 || is.map(value) && value.size === 0;\n};\nis.error = isObjectOfType(\"Error\");\nis.function = isOfType(\"function\");\nis.generator = (value) => {\n  return is.iterable(value) && is.function(value.next) && is.function(value.throw);\n};\nis.generatorFunction = isObjectOfType(\"GeneratorFunction\");\nis.instanceOf = (instance, class_) => {\n  if (!instance || !class_) {\n    return false;\n  }\n  return Object.getPrototypeOf(instance) === class_.prototype;\n};\nis.iterable = (value) => {\n  return !is.nullOrUndefined(value) && is.function(value[Symbol.iterator]);\n};\nis.map = isObjectOfType(\"Map\");\nis.nan = (value) => {\n  return Number.isNaN(value);\n};\nis.null = (value) => {\n  return value === null;\n};\nis.nullOrUndefined = (value) => {\n  return is.null(value) || is.undefined(value);\n};\nis.number = (value) => {\n  return isOfType(\"number\")(value) && !is.nan(value);\n};\nis.numericString = (value) => {\n  return is.string(value) && value.length > 0 && !Number.isNaN(Number(value));\n};\nis.object = (value) => {\n  return !is.nullOrUndefined(value) && (is.function(value) || typeof value === \"object\");\n};\nis.oneOf = (target, value) => {\n  if (!is.array(target)) {\n    return false;\n  }\n  return target.indexOf(value) > -1;\n};\nis.plainFunction = isObjectOfType(\"Function\");\nis.plainObject = (value) => {\n  if (getObjectType(value) !== \"Object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.getPrototypeOf({});\n};\nis.primitive = (value) => is.null(value) || isPrimitiveType(typeof value);\nis.promise = isObjectOfType(\"Promise\");\nis.propertyOf = (target, key, predicate) => {\n  if (!is.object(target) || !key) {\n    return false;\n  }\n  const value = target[key];\n  if (is.function(predicate)) {\n    return predicate(value);\n  }\n  return is.defined(value);\n};\nis.regexp = isObjectOfType(\"RegExp\");\nis.set = isObjectOfType(\"Set\");\nis.string = isOfType(\"string\");\nis.symbol = isOfType(\"symbol\");\nis.undefined = isOfType(\"undefined\");\nis.weakMap = isObjectOfType(\"WeakMap\");\nis.weakSet = isObjectOfType(\"WeakSet\");\nvar src_default = is;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcy1saXRlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pcy1saXRlL2Rpc3QvaW5kZXgubWpzP2ZiNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hlbHBlcnMudHNcbnZhciBvYmplY3RUeXBlcyA9IFtcbiAgXCJBcnJheVwiLFxuICBcIkFycmF5QnVmZmVyXCIsXG4gIFwiQXN5bmNGdW5jdGlvblwiLFxuICBcIkFzeW5jR2VuZXJhdG9yXCIsXG4gIFwiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFxuICBcIkRhdGVcIixcbiAgXCJFcnJvclwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiR2VuZXJhdG9yXCIsXG4gIFwiR2VuZXJhdG9yRnVuY3Rpb25cIixcbiAgXCJIVE1MRWxlbWVudFwiLFxuICBcIk1hcFwiLFxuICBcIk9iamVjdFwiLFxuICBcIlByb21pc2VcIixcbiAgXCJSZWdFeHBcIixcbiAgXCJTZXRcIixcbiAgXCJXZWFrTWFwXCIsXG4gIFwiV2Vha1NldFwiXG5dO1xudmFyIHByaW1pdGl2ZVR5cGVzID0gW1xuICBcImJpZ2ludFwiLFxuICBcImJvb2xlYW5cIixcbiAgXCJudWxsXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwic3RyaW5nXCIsXG4gIFwic3ltYm9sXCIsXG4gIFwidW5kZWZpbmVkXCJcbl07XG5mdW5jdGlvbiBnZXRPYmplY3RUeXBlKHZhbHVlKSB7XG4gIGNvbnN0IG9iamVjdFR5cGVOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG4gIGlmICgvSFRNTFxcdytFbGVtZW50Ly50ZXN0KG9iamVjdFR5cGVOYW1lKSkge1xuICAgIHJldHVybiBcIkhUTUxFbGVtZW50XCI7XG4gIH1cbiAgaWYgKGlzT2JqZWN0VHlwZShvYmplY3RUeXBlTmFtZSkpIHtcbiAgICByZXR1cm4gb2JqZWN0VHlwZU5hbWU7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0T2ZUeXBlKHR5cGUpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4gZ2V0T2JqZWN0VHlwZSh2YWx1ZSkgPT09IHR5cGU7XG59XG5mdW5jdGlvbiBpc09iamVjdFR5cGUobmFtZSkge1xuICByZXR1cm4gb2JqZWN0VHlwZXMuaW5jbHVkZXMobmFtZSk7XG59XG5mdW5jdGlvbiBpc09mVHlwZSh0eXBlKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZShuYW1lKSB7XG4gIHJldHVybiBwcmltaXRpdmVUeXBlcy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0sgPSBbXG4gIFwiaW5uZXJIVE1MXCIsXG4gIFwib3duZXJEb2N1bWVudFwiLFxuICBcInN0eWxlXCIsXG4gIFwiYXR0cmlidXRlc1wiLFxuICBcIm5vZGVWYWx1ZVwiXG5dO1xuZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJzeW1ib2xcIjtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBkZWZhdWx0OlxuICB9XG4gIGlmIChpcy5hcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJBcnJheVwiO1xuICB9XG4gIGlmIChpcy5wbGFpbkZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBcIkZ1bmN0aW9uXCI7XG4gIH1cbiAgY29uc3QgdGFnVHlwZSA9IGdldE9iamVjdFR5cGUodmFsdWUpO1xuICBpZiAodGFnVHlwZSkge1xuICAgIHJldHVybiB0YWdUeXBlO1xuICB9XG4gIHJldHVybiBcIk9iamVjdFwiO1xufVxuaXMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaXMuYXJyYXlPZiA9ICh0YXJnZXQsIHByZWRpY2F0ZSkgPT4ge1xuICBpZiAoIWlzLmFycmF5KHRhcmdldCkgJiYgIWlzLmZ1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC5ldmVyeSgoZCkgPT4gcHJlZGljYXRlKGQpKTtcbn07XG5pcy5hc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gKHZhbHVlKSA9PiBnZXRPYmplY3RUeXBlKHZhbHVlKSA9PT0gXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCI7XG5pcy5hc3luY0Z1bmN0aW9uID0gaXNPYmplY3RPZlR5cGUoXCJBc3luY0Z1bmN0aW9uXCIpO1xuaXMuYmlnaW50ID0gaXNPZlR5cGUoXCJiaWdpbnRcIik7XG5pcy5ib29sZWFuID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59O1xuaXMuZGF0ZSA9IGlzT2JqZWN0T2ZUeXBlKFwiRGF0ZVwiKTtcbmlzLmRlZmluZWQgPSAodmFsdWUpID0+ICFpcy51bmRlZmluZWQodmFsdWUpO1xuaXMuZG9tRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gaXMub2JqZWN0KHZhbHVlKSAmJiAhaXMucGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzLnN0cmluZyh2YWx1ZS5ub2RlTmFtZSkgJiYgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0suZXZlcnkoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eSBpbiB2YWx1ZSk7XG59O1xuaXMuZW1wdHkgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwIHx8IGlzLmFycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgfHwgaXMub2JqZWN0KHZhbHVlKSAmJiAhaXMubWFwKHZhbHVlKSAmJiAhaXMuc2V0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwIHx8IGlzLnNldCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA9PT0gMCB8fCBpcy5tYXAodmFsdWUpICYmIHZhbHVlLnNpemUgPT09IDA7XG59O1xuaXMuZXJyb3IgPSBpc09iamVjdE9mVHlwZShcIkVycm9yXCIpO1xuaXMuZnVuY3Rpb24gPSBpc09mVHlwZShcImZ1bmN0aW9uXCIpO1xuaXMuZ2VuZXJhdG9yID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpcy5pdGVyYWJsZSh2YWx1ZSkgJiYgaXMuZnVuY3Rpb24odmFsdWUubmV4dCkgJiYgaXMuZnVuY3Rpb24odmFsdWUudGhyb3cpO1xufTtcbmlzLmdlbmVyYXRvckZ1bmN0aW9uID0gaXNPYmplY3RPZlR5cGUoXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbmlzLmluc3RhbmNlT2YgPSAoaW5zdGFuY2UsIGNsYXNzXykgPT4ge1xuICBpZiAoIWluc3RhbmNlIHx8ICFjbGFzc18pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSkgPT09IGNsYXNzXy5wcm90b3R5cGU7XG59O1xuaXMuaXRlcmFibGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmIGlzLmZ1bmN0aW9uKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pO1xufTtcbmlzLm1hcCA9IGlzT2JqZWN0T2ZUeXBlKFwiTWFwXCIpO1xuaXMubmFuID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4odmFsdWUpO1xufTtcbmlzLm51bGwgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufTtcbmlzLm51bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gaXMubnVsbCh2YWx1ZSkgfHwgaXMudW5kZWZpbmVkKHZhbHVlKTtcbn07XG5pcy5udW1iZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzT2ZUeXBlKFwibnVtYmVyXCIpKHZhbHVlKSAmJiAhaXMubmFuKHZhbHVlKTtcbn07XG5pcy5udW1lcmljU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpcy5zdHJpbmcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDAgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKTtcbn07XG5pcy5vYmplY3QgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmIChpcy5mdW5jdGlvbih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKTtcbn07XG5pcy5vbmVPZiA9ICh0YXJnZXQsIHZhbHVlKSA9PiB7XG4gIGlmICghaXMuYXJyYXkodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0LmluZGV4T2YodmFsdWUpID4gLTE7XG59O1xuaXMucGxhaW5GdW5jdGlvbiA9IGlzT2JqZWN0T2ZUeXBlKFwiRnVuY3Rpb25cIik7XG5pcy5wbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoZ2V0T2JqZWN0VHlwZSh2YWx1ZSkgIT09IFwiT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG59O1xuaXMucHJpbWl0aXZlID0gKHZhbHVlKSA9PiBpcy5udWxsKHZhbHVlKSB8fCBpc1ByaW1pdGl2ZVR5cGUodHlwZW9mIHZhbHVlKTtcbmlzLnByb21pc2UgPSBpc09iamVjdE9mVHlwZShcIlByb21pc2VcIik7XG5pcy5wcm9wZXJ0eU9mID0gKHRhcmdldCwga2V5LCBwcmVkaWNhdGUpID0+IHtcbiAgaWYgKCFpcy5vYmplY3QodGFyZ2V0KSB8fCAha2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gdGFyZ2V0W2tleV07XG4gIGlmIChpcy5mdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGlzLmRlZmluZWQodmFsdWUpO1xufTtcbmlzLnJlZ2V4cCA9IGlzT2JqZWN0T2ZUeXBlKFwiUmVnRXhwXCIpO1xuaXMuc2V0ID0gaXNPYmplY3RPZlR5cGUoXCJTZXRcIik7XG5pcy5zdHJpbmcgPSBpc09mVHlwZShcInN0cmluZ1wiKTtcbmlzLnN5bWJvbCA9IGlzT2ZUeXBlKFwic3ltYm9sXCIpO1xuaXMudW5kZWZpbmVkID0gaXNPZlR5cGUoXCJ1bmRlZmluZWRcIik7XG5pcy53ZWFrTWFwID0gaXNPYmplY3RPZlR5cGUoXCJXZWFrTWFwXCIpO1xuaXMud2Vha1NldCA9IGlzT2JqZWN0T2ZUeXBlKFwiV2Vha1NldFwiKTtcbnZhciBzcmNfZGVmYXVsdCA9IGlzO1xuZXhwb3J0IHtcbiAgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/is-lite/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-joyride/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/react-joyride/dist/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTIONS: function() { return /* binding */ ACTIONS; },\n/* harmony export */   EVENTS: function() { return /* binding */ EVENTS; },\n/* harmony export */   LIFECYCLE: function() { return /* binding */ LIFECYCLE; },\n/* harmony export */   ORIGIN: function() { return /* binding */ ORIGIN; },\n/* harmony export */   STATUS: function() { return /* binding */ STATUS; },\n/* harmony export */   \"default\": function() { return /* binding */ components_default; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @gilbarbara/deep-equal */ \"(app-pages-browser)/./node_modules/@gilbarbara/deep-equal/dist/index.mjs\");\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-lite */ \"(app-pages-browser)/./node_modules/is-lite/dist/index.mjs\");\n/* harmony import */ var tree_changes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tree-changes */ \"(app-pages-browser)/./node_modules/tree-changes/dist/index.mjs\");\n/* harmony import */ var scroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! scroll */ \"(app-pages-browser)/./node_modules/scroll/index.js\");\n/* harmony import */ var scrollparent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! scrollparent */ \"(app-pages-browser)/./node_modules/scrollparent/scrollparent.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var react_innertext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-innertext */ \"(app-pages-browser)/./node_modules/react-innertext/index.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! deepmerge */ \"(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var react_floater__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-floater */ \"(app-pages-browser)/./node_modules/react-floater/es/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/literals/index.ts\nvar ACTIONS = {\n  INIT: \"init\",\n  START: \"start\",\n  STOP: \"stop\",\n  RESET: \"reset\",\n  PREV: \"prev\",\n  NEXT: \"next\",\n  GO: \"go\",\n  CLOSE: \"close\",\n  SKIP: \"skip\",\n  UPDATE: \"update\"\n};\nvar EVENTS = {\n  TOUR_START: \"tour:start\",\n  STEP_BEFORE: \"step:before\",\n  BEACON: \"beacon\",\n  TOOLTIP: \"tooltip\",\n  STEP_AFTER: \"step:after\",\n  TOUR_END: \"tour:end\",\n  TOUR_STATUS: \"tour:status\",\n  TARGET_NOT_FOUND: \"error:target_not_found\",\n  ERROR: \"error\"\n};\nvar LIFECYCLE = {\n  INIT: \"init\",\n  READY: \"ready\",\n  BEACON: \"beacon\",\n  TOOLTIP: \"tooltip\",\n  COMPLETE: \"complete\",\n  ERROR: \"error\"\n};\nvar ORIGIN = {\n  BUTTON_CLOSE: \"button_close\",\n  BUTTON_PRIMARY: \"button_primary\",\n  KEYBOARD: \"keyboard\",\n  OVERLAY: \"overlay\"\n};\nvar STATUS = {\n  IDLE: \"idle\",\n  READY: \"ready\",\n  WAITING: \"waiting\",\n  RUNNING: \"running\",\n  PAUSED: \"paused\",\n  SKIPPED: \"skipped\",\n  FINISHED: \"finished\",\n  ERROR: \"error\"\n};\n\n// src/components/index.tsx\n\n\n\n\n\n// src/modules/dom.ts\n\n\nfunction canUseDOM() {\n  var _a;\n  return !!(typeof window !== \"undefined\" && ((_a = window.document) == null ? void 0 : _a.createElement));\n}\nfunction getClientRect(element) {\n  if (!element) {\n    return null;\n  }\n  return element.getBoundingClientRect();\n}\nfunction getDocumentHeight(median = false) {\n  const { body, documentElement } = document;\n  if (!body || !documentElement) {\n    return 0;\n  }\n  if (median) {\n    const heights = [\n      body.scrollHeight,\n      body.offsetHeight,\n      documentElement.clientHeight,\n      documentElement.scrollHeight,\n      documentElement.offsetHeight\n    ].sort((a, b) => a - b);\n    const middle = Math.floor(heights.length / 2);\n    if (heights.length % 2 === 0) {\n      return (heights[middle - 1] + heights[middle]) / 2;\n    }\n    return heights[middle];\n  }\n  return Math.max(\n    body.scrollHeight,\n    body.offsetHeight,\n    documentElement.clientHeight,\n    documentElement.scrollHeight,\n    documentElement.offsetHeight\n  );\n}\nfunction getElement(element) {\n  if (typeof element === \"string\") {\n    try {\n      return document.querySelector(element);\n    } catch (error) {\n      if (true) {\n        console.error(error);\n      }\n      return null;\n    }\n  }\n  return element;\n}\nfunction getStyleComputedProperty(el) {\n  if (!el || el.nodeType !== 1) {\n    return null;\n  }\n  return getComputedStyle(el);\n}\nfunction getScrollParent(element, skipFix, forListener) {\n  if (!element) {\n    return scrollDocument();\n  }\n  const parent = scrollparent__WEBPACK_IMPORTED_MODULE_2__(element);\n  if (parent) {\n    if (parent.isSameNode(scrollDocument())) {\n      if (forListener) {\n        return document;\n      }\n      return scrollDocument();\n    }\n    const hasScrolling = parent.scrollHeight > parent.offsetHeight;\n    if (!hasScrolling && !skipFix) {\n      parent.style.overflow = \"initial\";\n      return scrollDocument();\n    }\n  }\n  return parent;\n}\nfunction hasCustomScrollParent(element, skipFix) {\n  if (!element) {\n    return false;\n  }\n  const parent = getScrollParent(element, skipFix);\n  return parent ? !parent.isSameNode(scrollDocument()) : false;\n}\nfunction hasCustomOffsetParent(element) {\n  return element.offsetParent !== document.body;\n}\nfunction hasPosition(el, type = \"fixed\") {\n  if (!el || !(el instanceof HTMLElement)) {\n    return false;\n  }\n  const { nodeName } = el;\n  const styles = getStyleComputedProperty(el);\n  if (nodeName === \"BODY\" || nodeName === \"HTML\") {\n    return false;\n  }\n  if (styles && styles.position === type) {\n    return true;\n  }\n  if (!el.parentNode) {\n    return false;\n  }\n  return hasPosition(el.parentNode, type);\n}\nfunction isElementVisible(element) {\n  var _a;\n  if (!element) {\n    return false;\n  }\n  let parentElement = element;\n  while (parentElement) {\n    if (parentElement === document.body) {\n      break;\n    }\n    if (parentElement instanceof HTMLElement) {\n      const { display, visibility } = getComputedStyle(parentElement);\n      if (display === \"none\" || visibility === \"hidden\") {\n        return false;\n      }\n    }\n    parentElement = (_a = parentElement.parentElement) != null ? _a : null;\n  }\n  return true;\n}\nfunction getElementPosition(element, offset, skipFix) {\n  var _a, _b, _c;\n  const elementRect = getClientRect(element);\n  const parent = getScrollParent(element, skipFix);\n  const hasScrollParent = hasCustomScrollParent(element, skipFix);\n  const isFixedTarget = hasPosition(element);\n  let parentTop = 0;\n  let top = (_a = elementRect == null ? void 0 : elementRect.top) != null ? _a : 0;\n  if (hasScrollParent && isFixedTarget) {\n    const offsetTop = (_b = element == null ? void 0 : element.offsetTop) != null ? _b : 0;\n    const parentScrollTop = (_c = parent == null ? void 0 : parent.scrollTop) != null ? _c : 0;\n    top = offsetTop - parentScrollTop;\n  } else if (parent instanceof HTMLElement) {\n    parentTop = parent.scrollTop;\n    if (!hasScrollParent && !hasPosition(element)) {\n      top += parentTop;\n    }\n    if (!parent.isSameNode(scrollDocument())) {\n      top += scrollDocument().scrollTop;\n    }\n  }\n  return Math.floor(top - offset);\n}\nfunction getScrollTo(element, offset, skipFix) {\n  var _a;\n  if (!element) {\n    return 0;\n  }\n  const { offsetTop = 0, scrollTop = 0 } = (_a = scrollparent__WEBPACK_IMPORTED_MODULE_2__(element)) != null ? _a : {};\n  let top = element.getBoundingClientRect().top + scrollTop;\n  if (!!offsetTop && (hasCustomScrollParent(element, skipFix) || hasCustomOffsetParent(element))) {\n    top -= offsetTop;\n  }\n  const output = Math.floor(top - offset);\n  return output < 0 ? 0 : output;\n}\nfunction scrollDocument() {\n  var _a;\n  return (_a = document.scrollingElement) != null ? _a : document.documentElement;\n}\nfunction scrollTo(value, options) {\n  const { duration, element } = options;\n  return new Promise((resolve, reject) => {\n    const { scrollTop } = element;\n    const limit = value > scrollTop ? value - scrollTop : scrollTop - value;\n    scroll__WEBPACK_IMPORTED_MODULE_1__.top(element, value, { duration: limit < 100 ? 50 : duration }, (error) => {\n      if (error && error.message !== \"Element already at target scroll position\") {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n}\n\n// src/modules/helpers.tsx\n\n\n\n\nvar isReact16 = react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal !== void 0;\nfunction getBrowser(userAgent = navigator.userAgent) {\n  let browser = userAgent;\n  if (typeof window === \"undefined\") {\n    browser = \"node\";\n  } else if (document.documentMode) {\n    browser = \"ie\";\n  } else if (/Edge/.test(userAgent)) {\n    browser = \"edge\";\n  } else if (Boolean(window.opera) || userAgent.includes(\" OPR/\")) {\n    browser = \"opera\";\n  } else if (typeof window.InstallTrigger !== \"undefined\") {\n    browser = \"firefox\";\n  } else if (window.chrome) {\n    browser = \"chrome\";\n  } else if (/(Version\\/([\\d._]+).*Safari|CriOS|FxiOS| Mobile\\/)/.test(userAgent)) {\n    browser = \"safari\";\n  }\n  return browser;\n}\nfunction getObjectType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n}\nfunction getReactNodeText(input, options = {}) {\n  const { defaultValue, step, steps } = options;\n  let text = react_innertext__WEBPACK_IMPORTED_MODULE_4__(input);\n  if (!text) {\n    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(input) && !Object.values(input.props).length && getObjectType(input.type) === \"function\") {\n      const component = input.type({});\n      text = getReactNodeText(component, options);\n    } else {\n      text = react_innertext__WEBPACK_IMPORTED_MODULE_4__(defaultValue);\n    }\n  } else if ((text.includes(\"{step}\") || text.includes(\"{steps}\")) && step && steps) {\n    text = text.replace(\"{step}\", step.toString()).replace(\"{steps}\", steps.toString());\n  }\n  return text;\n}\nfunction hasValidKeys(object, keys) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject(object) || !is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].array(keys)) {\n    return false;\n  }\n  return Object.keys(object).every((d) => keys.includes(d));\n}\nfunction hexToRGB(hex) {\n  const shorthandRegex = /^#?([\\da-f])([\\da-f])([\\da-f])$/i;\n  const properHex = hex.replace(shorthandRegex, (_m, r, g, b) => r + r + g + g + b + b);\n  const result = /^#?([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/i.exec(properHex);\n  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [];\n}\nfunction hideBeacon(step) {\n  return step.disableBeacon || step.placement === \"center\";\n}\nfunction isLegacy() {\n  return ![\"chrome\", \"safari\", \"firefox\", \"opera\"].includes(getBrowser());\n}\nfunction log({ data, debug = false, title, warn = false }) {\n  const logFn = warn ? console.warn || console.error : console.log;\n  if (debug) {\n    if (title && data) {\n      console.groupCollapsed(\n        `%creact-joyride: ${title}`,\n        \"color: #ff0044; font-weight: bold; font-size: 12px;\"\n      );\n      if (Array.isArray(data)) {\n        data.forEach((d) => {\n          if (is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject(d) && d.key) {\n            logFn.apply(console, [d.key, d.value]);\n          } else {\n            logFn.apply(console, [d]);\n          }\n        });\n      } else {\n        logFn.apply(console, [data]);\n      }\n      console.groupEnd();\n    } else {\n      console.error(\"Missing title or data props\");\n    }\n  }\n}\nfunction noop() {\n  return void 0;\n}\nfunction objectKeys(input) {\n  return Object.keys(input);\n}\nfunction omit(input, ...filter) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject(input)) {\n    throw new TypeError(\"Expected an object\");\n  }\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\nfunction pick(input, ...filter) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject(input)) {\n    throw new TypeError(\"Expected an object\");\n  }\n  if (!filter.length) {\n    return input;\n  }\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\nfunction replaceLocaleContent(input, step, steps) {\n  const replacer = (text) => text.replace(\"{step}\", String(step)).replace(\"{steps}\", String(steps));\n  if (getObjectType(input) === \"string\") {\n    return replacer(input);\n  }\n  if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(input)) {\n    return input;\n  }\n  const { children } = input.props;\n  if (getObjectType(children) === \"string\" && children.includes(\"{step}\")) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(input, {\n      children: replacer(children)\n    });\n  }\n  if (Array.isArray(children)) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(input, {\n      children: children.map((child) => {\n        if (typeof child === \"string\") {\n          return replacer(child);\n        }\n        return replaceLocaleContent(child, step, steps);\n      })\n    });\n  }\n  if (getObjectType(input.type) === \"function\" && !Object.values(input.props).length) {\n    const component = input.type({});\n    return replaceLocaleContent(component, step, steps);\n  }\n  return input;\n}\nfunction shouldScroll(options) {\n  const { isFirstStep, lifecycle, previousLifecycle, scrollToFirstStep, step, target } = options;\n  return !step.disableScrolling && (!isFirstStep || scrollToFirstStep || lifecycle === LIFECYCLE.TOOLTIP) && step.placement !== \"center\" && (!step.isFixed || !hasPosition(target)) && // fixed steps don't need to scroll\n  previousLifecycle !== lifecycle && [LIFECYCLE.BEACON, LIFECYCLE.TOOLTIP].includes(lifecycle);\n}\n\n// src/modules/step.ts\n\n\n\n// src/defaults.ts\nvar defaultFloaterProps = {\n  options: {\n    preventOverflow: {\n      boundariesElement: \"scrollParent\"\n    }\n  },\n  wrapperOptions: {\n    offset: -18,\n    position: true\n  }\n};\nvar defaultLocale = {\n  back: \"Back\",\n  close: \"Close\",\n  last: \"Last\",\n  next: \"Next\",\n  nextLabelWithProgress: \"Next (Step {step} of {steps})\",\n  open: \"Open the dialog\",\n  skip: \"Skip\"\n};\nvar defaultStep = {\n  event: \"click\",\n  placement: \"bottom\",\n  offset: 10,\n  disableBeacon: false,\n  disableCloseOnEsc: false,\n  disableOverlay: false,\n  disableOverlayClose: false,\n  disableScrollParentFix: false,\n  disableScrolling: false,\n  hideBackButton: false,\n  hideCloseButton: false,\n  hideFooter: false,\n  isFixed: false,\n  locale: defaultLocale,\n  showProgress: false,\n  showSkipButton: false,\n  spotlightClicks: false,\n  spotlightPadding: 10\n};\nvar defaultProps = {\n  continuous: false,\n  debug: false,\n  disableCloseOnEsc: false,\n  disableOverlay: false,\n  disableOverlayClose: false,\n  disableScrolling: false,\n  disableScrollParentFix: false,\n  getHelpers: noop(),\n  hideBackButton: false,\n  run: true,\n  scrollOffset: 20,\n  scrollDuration: 300,\n  scrollToFirstStep: false,\n  showSkipButton: false,\n  showProgress: false,\n  spotlightClicks: false,\n  spotlightPadding: 10,\n  steps: []\n};\n\n// src/styles.ts\n\nvar defaultOptions = {\n  arrowColor: \"#fff\",\n  backgroundColor: \"#fff\",\n  beaconSize: 36,\n  overlayColor: \"rgba(0, 0, 0, 0.5)\",\n  primaryColor: \"#f04\",\n  spotlightShadow: \"0 0 15px rgba(0, 0, 0, 0.5)\",\n  textColor: \"#333\",\n  width: 380,\n  zIndex: 100\n};\nvar buttonBase = {\n  backgroundColor: \"transparent\",\n  border: 0,\n  borderRadius: 0,\n  color: \"#555\",\n  cursor: \"pointer\",\n  fontSize: 16,\n  lineHeight: 1,\n  padding: 8,\n  WebkitAppearance: \"none\"\n};\nvar spotlight = {\n  borderRadius: 4,\n  position: \"absolute\"\n};\nfunction getStyles(props, step) {\n  var _a, _b, _c, _d, _e;\n  const { floaterProps, styles } = props;\n  const mergedFloaterProps = deepmerge__WEBPACK_IMPORTED_MODULE_6__((_a = step.floaterProps) != null ? _a : {}, floaterProps != null ? floaterProps : {});\n  const mergedStyles = deepmerge__WEBPACK_IMPORTED_MODULE_6__(styles != null ? styles : {}, (_b = step.styles) != null ? _b : {});\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_6__(defaultOptions, mergedStyles.options || {});\n  const hideBeacon2 = step.placement === \"center\" || step.disableBeacon;\n  let { width } = options;\n  if (window.innerWidth > 480) {\n    width = 380;\n  }\n  if (\"width\" in options) {\n    width = typeof options.width === \"number\" && window.innerWidth < options.width ? window.innerWidth - 30 : options.width;\n  }\n  const overlay = {\n    bottom: 0,\n    left: 0,\n    overflow: \"hidden\",\n    position: \"absolute\",\n    right: 0,\n    top: 0,\n    zIndex: options.zIndex\n  };\n  const defaultStyles = {\n    beacon: {\n      ...buttonBase,\n      display: hideBeacon2 ? \"none\" : \"inline-block\",\n      height: options.beaconSize,\n      position: \"relative\",\n      width: options.beaconSize,\n      zIndex: options.zIndex\n    },\n    beaconInner: {\n      animation: \"joyride-beacon-inner 1.2s infinite ease-in-out\",\n      backgroundColor: options.primaryColor,\n      borderRadius: \"50%\",\n      display: \"block\",\n      height: \"50%\",\n      left: \"50%\",\n      opacity: 0.7,\n      position: \"absolute\",\n      top: \"50%\",\n      transform: \"translate(-50%, -50%)\",\n      width: \"50%\"\n    },\n    beaconOuter: {\n      animation: \"joyride-beacon-outer 1.2s infinite ease-in-out\",\n      backgroundColor: `rgba(${hexToRGB(options.primaryColor).join(\",\")}, 0.2)`,\n      border: `2px solid ${options.primaryColor}`,\n      borderRadius: \"50%\",\n      boxSizing: \"border-box\",\n      display: \"block\",\n      height: \"100%\",\n      left: 0,\n      opacity: 0.9,\n      position: \"absolute\",\n      top: 0,\n      transformOrigin: \"center\",\n      width: \"100%\"\n    },\n    tooltip: {\n      backgroundColor: options.backgroundColor,\n      borderRadius: 5,\n      boxSizing: \"border-box\",\n      color: options.textColor,\n      fontSize: 16,\n      maxWidth: \"100%\",\n      padding: 15,\n      position: \"relative\",\n      width\n    },\n    tooltipContainer: {\n      lineHeight: 1.4,\n      textAlign: \"center\"\n    },\n    tooltipTitle: {\n      fontSize: 18,\n      margin: 0\n    },\n    tooltipContent: {\n      padding: \"20px 10px\"\n    },\n    tooltipFooter: {\n      alignItems: \"center\",\n      display: \"flex\",\n      justifyContent: \"flex-end\",\n      marginTop: 15\n    },\n    tooltipFooterSpacer: {\n      flex: 1\n    },\n    buttonNext: {\n      ...buttonBase,\n      backgroundColor: options.primaryColor,\n      borderRadius: 4,\n      color: \"#fff\"\n    },\n    buttonBack: {\n      ...buttonBase,\n      color: options.primaryColor,\n      marginLeft: \"auto\",\n      marginRight: 5\n    },\n    buttonClose: {\n      ...buttonBase,\n      color: options.textColor,\n      height: 14,\n      padding: 15,\n      position: \"absolute\",\n      right: 0,\n      top: 0,\n      width: 14\n    },\n    buttonSkip: {\n      ...buttonBase,\n      color: options.textColor,\n      fontSize: 14\n    },\n    overlay: {\n      ...overlay,\n      backgroundColor: options.overlayColor,\n      mixBlendMode: \"hard-light\"\n    },\n    overlayLegacy: {\n      ...overlay\n    },\n    overlayLegacyCenter: {\n      ...overlay,\n      backgroundColor: options.overlayColor\n    },\n    spotlight: {\n      ...spotlight,\n      backgroundColor: \"gray\"\n    },\n    spotlightLegacy: {\n      ...spotlight,\n      boxShadow: `0 0 0 9999px ${options.overlayColor}, ${options.spotlightShadow}`\n    },\n    floaterStyles: {\n      arrow: {\n        color: (_e = (_d = (_c = mergedFloaterProps == null ? void 0 : mergedFloaterProps.styles) == null ? void 0 : _c.arrow) == null ? void 0 : _d.color) != null ? _e : options.arrowColor\n      },\n      options: {\n        zIndex: options.zIndex + 100\n      }\n    },\n    options\n  };\n  return deepmerge__WEBPACK_IMPORTED_MODULE_6__(defaultStyles, mergedStyles);\n}\n\n// src/modules/step.ts\nfunction getTourProps(props) {\n  return pick(\n    props,\n    \"beaconComponent\",\n    \"disableCloseOnEsc\",\n    \"disableOverlay\",\n    \"disableOverlayClose\",\n    \"disableScrolling\",\n    \"disableScrollParentFix\",\n    \"floaterProps\",\n    \"hideBackButton\",\n    \"hideCloseButton\",\n    \"locale\",\n    \"showProgress\",\n    \"showSkipButton\",\n    \"spotlightClicks\",\n    \"spotlightPadding\",\n    \"styles\",\n    \"tooltipComponent\"\n  );\n}\nfunction getMergedStep(props, currentStep) {\n  var _a, _b, _c, _d, _e, _f;\n  const step = currentStep != null ? currentStep : {};\n  const mergedStep = deepmerge__WEBPACK_IMPORTED_MODULE_6__.all([defaultStep, getTourProps(props), step], {\n    isMergeableObject: is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject\n  });\n  const mergedStyles = getStyles(props, mergedStep);\n  const scrollParent2 = hasCustomScrollParent(\n    getElement(mergedStep.target),\n    mergedStep.disableScrollParentFix\n  );\n  const floaterProps = deepmerge__WEBPACK_IMPORTED_MODULE_6__.all([\n    defaultFloaterProps,\n    (_a = props.floaterProps) != null ? _a : {},\n    (_b = mergedStep.floaterProps) != null ? _b : {}\n  ]);\n  floaterProps.offset = mergedStep.offset;\n  floaterProps.styles = deepmerge__WEBPACK_IMPORTED_MODULE_6__((_c = floaterProps.styles) != null ? _c : {}, mergedStyles.floaterStyles);\n  floaterProps.offset += (_e = (_d = props.spotlightPadding) != null ? _d : mergedStep.spotlightPadding) != null ? _e : 0;\n  if (mergedStep.placementBeacon && floaterProps.wrapperOptions) {\n    floaterProps.wrapperOptions.placement = mergedStep.placementBeacon;\n  }\n  if (scrollParent2 && floaterProps.options.preventOverflow) {\n    floaterProps.options.preventOverflow.boundariesElement = \"window\";\n  }\n  return {\n    ...mergedStep,\n    locale: deepmerge__WEBPACK_IMPORTED_MODULE_6__.all([defaultLocale, (_f = props.locale) != null ? _f : {}, mergedStep.locale || {}]),\n    floaterProps,\n    styles: omit(mergedStyles, \"floaterStyles\")\n  };\n}\nfunction validateStep(step, debug = false) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].plainObject(step)) {\n    log({\n      title: \"validateStep\",\n      data: \"step must be an object\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  if (!step.target) {\n    log({\n      title: \"validateStep\",\n      data: \"target is missing from the step\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  return true;\n}\nfunction validateSteps(steps, debug = false) {\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].array(steps)) {\n    log({\n      title: \"validateSteps\",\n      data: \"steps must be an array\",\n      warn: true,\n      debug\n    });\n    return false;\n  }\n  return steps.every((d) => validateStep(d, debug));\n}\n\n// src/modules/store.ts\n\nvar defaultState = {\n  action: \"init\",\n  controlled: false,\n  index: 0,\n  lifecycle: LIFECYCLE.INIT,\n  origin: null,\n  size: 0,\n  status: STATUS.IDLE\n};\nvar validKeys = objectKeys(omit(defaultState, \"controlled\", \"size\"));\nvar Store = class {\n  constructor(options) {\n    __publicField(this, \"beaconPopper\");\n    __publicField(this, \"tooltipPopper\");\n    __publicField(this, \"data\", /* @__PURE__ */ new Map());\n    __publicField(this, \"listener\");\n    __publicField(this, \"store\", /* @__PURE__ */ new Map());\n    __publicField(this, \"addListener\", (listener) => {\n      this.listener = listener;\n    });\n    __publicField(this, \"setSteps\", (steps) => {\n      const { size, status } = this.getState();\n      const state = {\n        size: steps.length,\n        status\n      };\n      this.data.set(\"steps\", steps);\n      if (status === STATUS.WAITING && !size && steps.length) {\n        state.status = STATUS.RUNNING;\n      }\n      this.setState(state);\n    });\n    __publicField(this, \"getPopper\", (name) => {\n      if (name === \"beacon\") {\n        return this.beaconPopper;\n      }\n      return this.tooltipPopper;\n    });\n    __publicField(this, \"setPopper\", (name, popper) => {\n      if (name === \"beacon\") {\n        this.beaconPopper = popper;\n      } else {\n        this.tooltipPopper = popper;\n      }\n    });\n    __publicField(this, \"cleanupPoppers\", () => {\n      this.beaconPopper = null;\n      this.tooltipPopper = null;\n    });\n    __publicField(this, \"close\", (origin = null) => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.CLOSE, index: index + 1, origin })\n      });\n    });\n    __publicField(this, \"go\", (nextIndex) => {\n      const { controlled, status } = this.getState();\n      if (controlled || status !== STATUS.RUNNING) {\n        return;\n      }\n      const step = this.getSteps()[nextIndex];\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.GO, index: nextIndex }),\n        status: step ? status : STATUS.FINISHED\n      });\n    });\n    __publicField(this, \"info\", () => this.getState());\n    __publicField(this, \"next\", () => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.setState(this.getNextState({ action: ACTIONS.NEXT, index: index + 1 }));\n    });\n    __publicField(this, \"open\", () => {\n      const { status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.UPDATE, lifecycle: LIFECYCLE.TOOLTIP })\n      });\n    });\n    __publicField(this, \"prev\", () => {\n      const { index, status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.PREV, index: index - 1 })\n      });\n    });\n    __publicField(this, \"reset\", (restart = false) => {\n      const { controlled } = this.getState();\n      if (controlled) {\n        return;\n      }\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.RESET, index: 0 }),\n        status: restart ? STATUS.RUNNING : STATUS.READY\n      });\n    });\n    __publicField(this, \"skip\", () => {\n      const { status } = this.getState();\n      if (status !== STATUS.RUNNING) {\n        return;\n      }\n      this.setState({\n        action: ACTIONS.SKIP,\n        lifecycle: LIFECYCLE.INIT,\n        status: STATUS.SKIPPED\n      });\n    });\n    __publicField(this, \"start\", (nextIndex) => {\n      const { index, size } = this.getState();\n      this.setState({\n        ...this.getNextState(\n          {\n            action: ACTIONS.START,\n            index: is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(nextIndex) ? nextIndex : index\n          },\n          true\n        ),\n        status: size ? STATUS.RUNNING : STATUS.WAITING\n      });\n    });\n    __publicField(this, \"stop\", (advance = false) => {\n      const { index, status } = this.getState();\n      if ([STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {\n        return;\n      }\n      this.setState({\n        ...this.getNextState({ action: ACTIONS.STOP, index: index + (advance ? 1 : 0) }),\n        status: STATUS.PAUSED\n      });\n    });\n    __publicField(this, \"update\", (state) => {\n      var _a, _b;\n      if (!hasValidKeys(state, validKeys)) {\n        throw new Error(`State is not valid. Valid keys: ${validKeys.join(\", \")}`);\n      }\n      this.setState({\n        ...this.getNextState(\n          {\n            ...this.getState(),\n            ...state,\n            action: (_a = state.action) != null ? _a : ACTIONS.UPDATE,\n            origin: (_b = state.origin) != null ? _b : null\n          },\n          true\n        )\n      });\n    });\n    const { continuous = false, stepIndex, steps = [] } = options != null ? options : {};\n    this.setState(\n      {\n        action: ACTIONS.INIT,\n        controlled: is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(stepIndex),\n        continuous,\n        index: is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(stepIndex) ? stepIndex : 0,\n        lifecycle: LIFECYCLE.INIT,\n        origin: null,\n        status: steps.length ? STATUS.READY : STATUS.IDLE\n      },\n      true\n    );\n    this.beaconPopper = null;\n    this.tooltipPopper = null;\n    this.listener = null;\n    this.setSteps(steps);\n  }\n  getState() {\n    if (!this.store.size) {\n      return { ...defaultState };\n    }\n    return {\n      action: this.store.get(\"action\") || \"\",\n      controlled: this.store.get(\"controlled\") || false,\n      index: parseInt(this.store.get(\"index\"), 10),\n      lifecycle: this.store.get(\"lifecycle\") || \"\",\n      origin: this.store.get(\"origin\") || null,\n      size: this.store.get(\"size\") || 0,\n      status: this.store.get(\"status\") || \"\"\n    };\n  }\n  getNextState(state, force = false) {\n    var _a, _b, _c, _d, _e;\n    const { action, controlled, index, size, status } = this.getState();\n    const newIndex = is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(state.index) ? state.index : index;\n    const nextIndex = controlled && !force ? index : Math.min(Math.max(newIndex, 0), size);\n    return {\n      action: (_a = state.action) != null ? _a : action,\n      controlled,\n      index: nextIndex,\n      lifecycle: (_b = state.lifecycle) != null ? _b : LIFECYCLE.INIT,\n      origin: (_c = state.origin) != null ? _c : null,\n      size: (_d = state.size) != null ? _d : size,\n      status: nextIndex === size ? STATUS.FINISHED : (_e = state.status) != null ? _e : status\n    };\n  }\n  getSteps() {\n    const steps = this.data.get(\"steps\");\n    return Array.isArray(steps) ? steps : [];\n  }\n  hasUpdatedState(oldState) {\n    const before = JSON.stringify(oldState);\n    const after = JSON.stringify(this.getState());\n    return before !== after;\n  }\n  setState(nextState, initial = false) {\n    const state = this.getState();\n    const {\n      action,\n      index,\n      lifecycle,\n      origin = null,\n      size,\n      status\n    } = {\n      ...state,\n      ...nextState\n    };\n    this.store.set(\"action\", action);\n    this.store.set(\"index\", index);\n    this.store.set(\"lifecycle\", lifecycle);\n    this.store.set(\"origin\", origin);\n    this.store.set(\"size\", size);\n    this.store.set(\"status\", status);\n    if (initial) {\n      this.store.set(\"controlled\", nextState.controlled);\n      this.store.set(\"continuous\", nextState.continuous);\n    }\n    if (this.listener && this.hasUpdatedState(state)) {\n      this.listener(this.getState());\n    }\n  }\n  getHelpers() {\n    return {\n      close: this.close,\n      go: this.go,\n      info: this.info,\n      next: this.next,\n      open: this.open,\n      prev: this.prev,\n      reset: this.reset,\n      skip: this.skip\n    };\n  }\n};\nfunction createStore(options) {\n  return new Store(options);\n}\n\n// src/components/Overlay.tsx\n\n\n\n// src/components/Spotlight.tsx\n\nfunction JoyrideSpotlight({ styles }) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"div\",\n    {\n      key: \"JoyrideSpotlight\",\n      className: \"react-joyride__spotlight\",\n      \"data-test-id\": \"spotlight\",\n      style: styles\n    }\n  );\n}\nvar Spotlight_default = JoyrideSpotlight;\n\n// src/components/Overlay.tsx\nvar JoyrideOverlay = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"isActive\", false);\n    __publicField(this, \"resizeTimeout\");\n    __publicField(this, \"scrollTimeout\");\n    __publicField(this, \"scrollParent\");\n    __publicField(this, \"state\", {\n      isScrolling: false,\n      mouseOverSpotlight: false,\n      showSpotlight: true\n    });\n    __publicField(this, \"hideSpotlight\", () => {\n      const { continuous, disableOverlay, lifecycle } = this.props;\n      const hiddenLifecycles = [\n        LIFECYCLE.INIT,\n        LIFECYCLE.BEACON,\n        LIFECYCLE.COMPLETE,\n        LIFECYCLE.ERROR\n      ];\n      return disableOverlay || (continuous ? hiddenLifecycles.includes(lifecycle) : lifecycle !== LIFECYCLE.TOOLTIP);\n    });\n    __publicField(this, \"handleMouseMove\", (event) => {\n      const { mouseOverSpotlight } = this.state;\n      const { height, left, position, top, width } = this.spotlightStyles;\n      const offsetY = position === \"fixed\" ? event.clientY : event.pageY;\n      const offsetX = position === \"fixed\" ? event.clientX : event.pageX;\n      const inSpotlightHeight = offsetY >= top && offsetY <= top + height;\n      const inSpotlightWidth = offsetX >= left && offsetX <= left + width;\n      const inSpotlight = inSpotlightWidth && inSpotlightHeight;\n      if (inSpotlight !== mouseOverSpotlight) {\n        this.updateState({ mouseOverSpotlight: inSpotlight });\n      }\n    });\n    __publicField(this, \"handleScroll\", () => {\n      const { target } = this.props;\n      const element = getElement(target);\n      if (this.scrollParent !== document) {\n        const { isScrolling } = this.state;\n        if (!isScrolling) {\n          this.updateState({ isScrolling: true, showSpotlight: false });\n        }\n        clearTimeout(this.scrollTimeout);\n        this.scrollTimeout = window.setTimeout(() => {\n          this.updateState({ isScrolling: false, showSpotlight: true });\n        }, 50);\n      } else if (hasPosition(element, \"sticky\")) {\n        this.updateState({});\n      }\n    });\n    __publicField(this, \"handleResize\", () => {\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = window.setTimeout(() => {\n        if (!this.isActive) {\n          return;\n        }\n        this.forceUpdate();\n      }, 100);\n    });\n  }\n  componentDidMount() {\n    const { debug, disableScrolling, disableScrollParentFix = false, target } = this.props;\n    const element = getElement(target);\n    this.scrollParent = getScrollParent(element != null ? element : document.body, disableScrollParentFix, true);\n    this.isActive = true;\n    if (true) {\n      if (!disableScrolling && hasCustomScrollParent(element, true)) {\n        log({\n          title: \"step has a custom scroll parent and can cause trouble with scrolling\",\n          data: [{ key: \"parent\", value: this.scrollParent }],\n          debug\n        });\n      }\n    }\n    window.addEventListener(\"resize\", this.handleResize);\n  }\n  componentDidUpdate(previousProps) {\n    var _a;\n    const { disableScrollParentFix, lifecycle, spotlightClicks, target } = this.props;\n    const { changed } = (0,tree_changes__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(previousProps, this.props);\n    if (changed(\"target\") || changed(\"disableScrollParentFix\")) {\n      const element = getElement(target);\n      this.scrollParent = getScrollParent(element != null ? element : document.body, disableScrollParentFix, true);\n    }\n    if (changed(\"lifecycle\", LIFECYCLE.TOOLTIP)) {\n      (_a = this.scrollParent) == null ? void 0 : _a.addEventListener(\"scroll\", this.handleScroll, { passive: true });\n      setTimeout(() => {\n        const { isScrolling } = this.state;\n        if (!isScrolling) {\n          this.updateState({ showSpotlight: true });\n        }\n      }, 100);\n    }\n    if (changed(\"spotlightClicks\") || changed(\"disableOverlay\") || changed(\"lifecycle\")) {\n      if (spotlightClicks && lifecycle === LIFECYCLE.TOOLTIP) {\n        window.addEventListener(\"mousemove\", this.handleMouseMove, false);\n      } else if (lifecycle !== LIFECYCLE.TOOLTIP) {\n        window.removeEventListener(\"mousemove\", this.handleMouseMove);\n      }\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    this.isActive = false;\n    window.removeEventListener(\"mousemove\", this.handleMouseMove);\n    window.removeEventListener(\"resize\", this.handleResize);\n    clearTimeout(this.resizeTimeout);\n    clearTimeout(this.scrollTimeout);\n    (_a = this.scrollParent) == null ? void 0 : _a.removeEventListener(\"scroll\", this.handleScroll);\n  }\n  get overlayStyles() {\n    const { mouseOverSpotlight } = this.state;\n    const { disableOverlayClose, placement, styles } = this.props;\n    let baseStyles = styles.overlay;\n    if (isLegacy()) {\n      baseStyles = placement === \"center\" ? styles.overlayLegacyCenter : styles.overlayLegacy;\n    }\n    return {\n      cursor: disableOverlayClose ? \"default\" : \"pointer\",\n      height: getDocumentHeight(),\n      pointerEvents: mouseOverSpotlight ? \"none\" : \"auto\",\n      ...baseStyles\n    };\n  }\n  get spotlightStyles() {\n    var _a, _b, _c;\n    const { showSpotlight } = this.state;\n    const {\n      disableScrollParentFix = false,\n      spotlightClicks,\n      spotlightPadding = 0,\n      styles,\n      target\n    } = this.props;\n    const element = getElement(target);\n    const elementRect = getClientRect(element);\n    const isFixedTarget = hasPosition(element);\n    const top = getElementPosition(element, spotlightPadding, disableScrollParentFix);\n    return {\n      ...isLegacy() ? styles.spotlightLegacy : styles.spotlight,\n      height: Math.round(((_a = elementRect == null ? void 0 : elementRect.height) != null ? _a : 0) + spotlightPadding * 2),\n      left: Math.round(((_b = elementRect == null ? void 0 : elementRect.left) != null ? _b : 0) - spotlightPadding),\n      opacity: showSpotlight ? 1 : 0,\n      pointerEvents: spotlightClicks ? \"none\" : \"auto\",\n      position: isFixedTarget ? \"fixed\" : \"absolute\",\n      top,\n      transition: \"opacity 0.2s\",\n      width: Math.round(((_c = elementRect == null ? void 0 : elementRect.width) != null ? _c : 0) + spotlightPadding * 2)\n    };\n  }\n  updateState(state) {\n    if (!this.isActive) {\n      return;\n    }\n    this.setState((previousState) => ({ ...previousState, ...state }));\n  }\n  render() {\n    const { showSpotlight } = this.state;\n    const { onClickOverlay, placement } = this.props;\n    const { hideSpotlight, overlayStyles, spotlightStyles } = this;\n    if (hideSpotlight()) {\n      return null;\n    }\n    let spotlight2 = placement !== \"center\" && showSpotlight && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Spotlight_default, { styles: spotlightStyles });\n    if (getBrowser() === \"safari\") {\n      const { mixBlendMode, zIndex, ...safariOverlay } = overlayStyles;\n      spotlight2 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { ...safariOverlay } }, spotlight2);\n      delete overlayStyles.backgroundColor;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"div\",\n      {\n        className: \"react-joyride__overlay\",\n        \"data-test-id\": \"overlay\",\n        onClick: onClickOverlay,\n        role: \"presentation\",\n        style: overlayStyles\n      },\n      spotlight2\n    );\n  }\n};\n\n// src/components/Portal.tsx\n\n\nvar JoyridePortal = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"node\", null);\n  }\n  componentDidMount() {\n    const { id } = this.props;\n    if (!canUseDOM()) {\n      return;\n    }\n    this.node = document.createElement(\"div\");\n    this.node.id = id;\n    document.body.appendChild(this.node);\n    if (!isReact16) {\n      this.renderReact15();\n    }\n  }\n  componentDidUpdate() {\n    if (!canUseDOM()) {\n      return;\n    }\n    if (!isReact16) {\n      this.renderReact15();\n    }\n  }\n  componentWillUnmount() {\n    if (!canUseDOM() || !this.node) {\n      return;\n    }\n    if (!isReact16) {\n      react_dom__WEBPACK_IMPORTED_MODULE_3__.unmountComponentAtNode(this.node);\n    }\n    if (this.node.parentNode === document.body) {\n      document.body.removeChild(this.node);\n      this.node = null;\n    }\n  }\n  renderReact15() {\n    if (!canUseDOM()) {\n      return;\n    }\n    const { children } = this.props;\n    if (this.node) {\n      react_dom__WEBPACK_IMPORTED_MODULE_3__.unstable_renderSubtreeIntoContainer(this, children, this.node);\n    }\n  }\n  renderReact16() {\n    if (!canUseDOM() || !isReact16) {\n      return null;\n    }\n    const { children } = this.props;\n    if (!this.node) {\n      return null;\n    }\n    return react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(children, this.node);\n  }\n  render() {\n    if (!isReact16) {\n      return null;\n    }\n    return this.renderReact16();\n  }\n};\n\n// src/components/Step.tsx\n\n\n\n\n\n// src/modules/scope.ts\nvar Scope = class {\n  constructor(element, options) {\n    __publicField(this, \"element\");\n    __publicField(this, \"options\");\n    __publicField(this, \"canBeTabbed\", (element) => {\n      const { tabIndex } = element;\n      if (tabIndex === null || tabIndex < 0) {\n        return false;\n      }\n      return this.canHaveFocus(element);\n    });\n    __publicField(this, \"canHaveFocus\", (element) => {\n      const validTabNodes = /input|select|textarea|button|object/;\n      const nodeName = element.nodeName.toLowerCase();\n      const isValid = validTabNodes.test(nodeName) && !element.getAttribute(\"disabled\") || nodeName === \"a\" && !!element.getAttribute(\"href\");\n      return isValid && this.isVisible(element);\n    });\n    __publicField(this, \"findValidTabElements\", () => [].slice.call(this.element.querySelectorAll(\"*\"), 0).filter(this.canBeTabbed));\n    __publicField(this, \"handleKeyDown\", (event) => {\n      const { code = \"Tab\" } = this.options;\n      if (event.code === code) {\n        this.interceptTab(event);\n      }\n    });\n    __publicField(this, \"interceptTab\", (event) => {\n      event.preventDefault();\n      const elements = this.findValidTabElements();\n      const { shiftKey } = event;\n      if (!elements.length) {\n        return;\n      }\n      let x = document.activeElement ? elements.indexOf(document.activeElement) : 0;\n      if (x === -1 || !shiftKey && x + 1 === elements.length) {\n        x = 0;\n      } else if (shiftKey && x === 0) {\n        x = elements.length - 1;\n      } else {\n        x += shiftKey ? -1 : 1;\n      }\n      elements[x].focus();\n    });\n    // eslint-disable-next-line class-methods-use-this\n    __publicField(this, \"isHidden\", (element) => {\n      const noSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n      const style = window.getComputedStyle(element);\n      if (noSize && !element.innerHTML) {\n        return true;\n      }\n      return noSize && style.getPropertyValue(\"overflow\") !== \"visible\" || style.getPropertyValue(\"display\") === \"none\";\n    });\n    __publicField(this, \"isVisible\", (element) => {\n      let parentElement = element;\n      while (parentElement) {\n        if (parentElement instanceof HTMLElement) {\n          if (parentElement === document.body) {\n            break;\n          }\n          if (this.isHidden(parentElement)) {\n            return false;\n          }\n          parentElement = parentElement.parentNode;\n        }\n      }\n      return true;\n    });\n    __publicField(this, \"removeScope\", () => {\n      window.removeEventListener(\"keydown\", this.handleKeyDown);\n    });\n    __publicField(this, \"checkFocus\", (target) => {\n      if (document.activeElement !== target) {\n        target.focus();\n        window.requestAnimationFrame(() => this.checkFocus(target));\n      }\n    });\n    __publicField(this, \"setFocus\", () => {\n      const { selector } = this.options;\n      if (!selector) {\n        return;\n      }\n      const target = this.element.querySelector(selector);\n      if (target) {\n        window.requestAnimationFrame(() => this.checkFocus(target));\n      }\n    });\n    if (!(element instanceof HTMLElement)) {\n      throw new TypeError(\"Invalid parameter: element must be an HTMLElement\");\n    }\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"keydown\", this.handleKeyDown, false);\n    this.setFocus();\n  }\n};\n\n// src/components/Beacon.tsx\n\n\nvar JoyrideBeacon = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    __publicField(this, \"beacon\", null);\n    __publicField(this, \"setBeaconRef\", (c) => {\n      this.beacon = c;\n    });\n    if (props.beaconComponent) {\n      return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.id = \"joyride-beacon-animation\";\n    if (props.nonce) {\n      style.setAttribute(\"nonce\", props.nonce);\n    }\n    const css = `\n        @keyframes joyride-beacon-inner {\n          20% {\n            opacity: 0.9;\n          }\n        \n          90% {\n            opacity: 0.7;\n          }\n        }\n        \n        @keyframes joyride-beacon-outer {\n          0% {\n            transform: scale(1);\n          }\n        \n          45% {\n            opacity: 0.7;\n            transform: scale(0.75);\n          }\n        \n          100% {\n            opacity: 0.9;\n            transform: scale(1);\n          }\n        }\n      `;\n    style.appendChild(document.createTextNode(css));\n    head.appendChild(style);\n  }\n  componentDidMount() {\n    const { shouldFocus } = this.props;\n    if (true) {\n      if (!is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].domElement(this.beacon)) {\n        console.warn(\"beacon is not a valid DOM element\");\n      }\n    }\n    setTimeout(() => {\n      if (is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].domElement(this.beacon) && shouldFocus) {\n        this.beacon.focus();\n      }\n    }, 0);\n  }\n  componentWillUnmount() {\n    const style = document.getElementById(\"joyride-beacon-animation\");\n    if (style == null ? void 0 : style.parentNode) {\n      style.parentNode.removeChild(style);\n    }\n  }\n  render() {\n    const {\n      beaconComponent,\n      continuous,\n      index,\n      isLastStep,\n      locale,\n      onClickOrHover,\n      size,\n      step,\n      styles\n    } = this.props;\n    const title = getReactNodeText(locale.open);\n    const sharedProps = {\n      \"aria-label\": title,\n      onClick: onClickOrHover,\n      onMouseEnter: onClickOrHover,\n      ref: this.setBeaconRef,\n      title\n    };\n    let component;\n    if (beaconComponent) {\n      const BeaconComponent = beaconComponent;\n      component = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        BeaconComponent,\n        {\n          continuous,\n          index,\n          isLastStep,\n          size,\n          step,\n          ...sharedProps\n        }\n      );\n    } else {\n      component = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"button\",\n        {\n          key: \"JoyrideBeacon\",\n          className: \"react-joyride__beacon\",\n          \"data-test-id\": \"button-beacon\",\n          style: styles.beacon,\n          type: \"button\",\n          ...sharedProps\n        },\n        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { style: styles.beaconInner }),\n        /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { style: styles.beaconOuter })\n      );\n    }\n    return component;\n  }\n};\n\n// src/components/Tooltip/index.tsx\n\n\n// src/components/Tooltip/Container.tsx\n\n\n// src/components/Tooltip/CloseButton.tsx\n\nfunction JoyrideTooltipCloseButton({ styles, ...props }) {\n  const { color, height, width, ...style } = styles;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { style, type: \"button\", ...props }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"svg\",\n    {\n      height: typeof height === \"number\" ? `${height}px` : height,\n      preserveAspectRatio: \"xMidYMid\",\n      version: \"1.1\",\n      viewBox: \"0 0 18 18\",\n      width: typeof width === \"number\" ? `${width}px` : width,\n      xmlns: \"http://www.w3.org/2000/svg\"\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"path\",\n      {\n        d: \"M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z\",\n        fill: color\n      }\n    ))\n  ));\n}\nvar CloseButton_default = JoyrideTooltipCloseButton;\n\n// src/components/Tooltip/Container.tsx\nfunction JoyrideTooltipContainer(props) {\n  const { backProps, closeProps, index, isLastStep, primaryProps, skipProps, step, tooltipProps } = props;\n  const { content, hideBackButton, hideCloseButton, hideFooter, showSkipButton, styles, title } = step;\n  const output = {};\n  output.primary = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"button\",\n    {\n      \"data-test-id\": \"button-primary\",\n      style: styles.buttonNext,\n      type: \"button\",\n      ...primaryProps\n    }\n  );\n  if (showSkipButton && !isLastStep) {\n    output.skip = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"button\",\n      {\n        \"aria-live\": \"off\",\n        \"data-test-id\": \"button-skip\",\n        style: styles.buttonSkip,\n        type: \"button\",\n        ...skipProps\n      }\n    );\n  }\n  if (!hideBackButton && index > 0) {\n    output.back = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { \"data-test-id\": \"button-back\", style: styles.buttonBack, type: \"button\", ...backProps });\n  }\n  output.close = !hideCloseButton && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CloseButton_default, { \"data-test-id\": \"button-close\", styles: styles.buttonClose, ...closeProps });\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"div\",\n    {\n      key: \"JoyrideTooltip\",\n      \"aria-label\": getReactNodeText(title != null ? title : content),\n      className: \"react-joyride__tooltip\",\n      style: styles.tooltip,\n      ...tooltipProps\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: styles.tooltipContainer }, title && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { \"aria-label\": getReactNodeText(title), style: styles.tooltipTitle }, title), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: styles.tooltipContent }, content)),\n    !hideFooter && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: styles.tooltipFooter }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: styles.tooltipFooterSpacer }, output.skip), output.back, output.primary),\n    output.close\n  );\n}\nvar Container_default = JoyrideTooltipContainer;\n\n// src/components/Tooltip/index.tsx\nvar JoyrideTooltip = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"handleClickBack\", (event) => {\n      event.preventDefault();\n      const { helpers } = this.props;\n      helpers.prev();\n    });\n    __publicField(this, \"handleClickClose\", (event) => {\n      event.preventDefault();\n      const { helpers } = this.props;\n      helpers.close(\"button_close\");\n    });\n    __publicField(this, \"handleClickPrimary\", (event) => {\n      event.preventDefault();\n      const { continuous, helpers } = this.props;\n      if (!continuous) {\n        helpers.close(\"button_primary\");\n        return;\n      }\n      helpers.next();\n    });\n    __publicField(this, \"handleClickSkip\", (event) => {\n      event.preventDefault();\n      const { helpers } = this.props;\n      helpers.skip();\n    });\n    __publicField(this, \"getElementsProps\", () => {\n      const { continuous, index, isLastStep, setTooltipRef, size, step } = this.props;\n      const { back, close, last, next, nextLabelWithProgress, skip } = step.locale;\n      const backText = getReactNodeText(back);\n      const closeText = getReactNodeText(close);\n      const lastText = getReactNodeText(last);\n      const nextText = getReactNodeText(next);\n      const skipText = getReactNodeText(skip);\n      let primary = close;\n      let primaryText = closeText;\n      if (continuous) {\n        primary = next;\n        primaryText = nextText;\n        if (step.showProgress && !isLastStep) {\n          const labelWithProgress = getReactNodeText(nextLabelWithProgress, {\n            step: index + 1,\n            steps: size\n          });\n          primary = replaceLocaleContent(nextLabelWithProgress, index + 1, size);\n          primaryText = labelWithProgress;\n        }\n        if (isLastStep) {\n          primary = last;\n          primaryText = lastText;\n        }\n      }\n      return {\n        backProps: {\n          \"aria-label\": backText,\n          children: back,\n          \"data-action\": \"back\",\n          onClick: this.handleClickBack,\n          role: \"button\",\n          title: backText\n        },\n        closeProps: {\n          \"aria-label\": closeText,\n          children: close,\n          \"data-action\": \"close\",\n          onClick: this.handleClickClose,\n          role: \"button\",\n          title: closeText\n        },\n        primaryProps: {\n          \"aria-label\": primaryText,\n          children: primary,\n          \"data-action\": \"primary\",\n          onClick: this.handleClickPrimary,\n          role: \"button\",\n          title: primaryText\n        },\n        skipProps: {\n          \"aria-label\": skipText,\n          children: skip,\n          \"data-action\": \"skip\",\n          onClick: this.handleClickSkip,\n          role: \"button\",\n          title: skipText\n        },\n        tooltipProps: {\n          \"aria-modal\": true,\n          ref: setTooltipRef,\n          role: \"alertdialog\"\n        }\n      };\n    });\n  }\n  render() {\n    const { continuous, index, isLastStep, setTooltipRef, size, step } = this.props;\n    const { beaconComponent, tooltipComponent, ...cleanStep } = step;\n    let component;\n    if (tooltipComponent) {\n      const renderProps = {\n        ...this.getElementsProps(),\n        continuous,\n        index,\n        isLastStep,\n        size,\n        step: cleanStep,\n        setTooltipRef\n      };\n      const TooltipComponent = tooltipComponent;\n      component = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TooltipComponent, { ...renderProps });\n    } else {\n      component = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        Container_default,\n        {\n          ...this.getElementsProps(),\n          continuous,\n          index,\n          isLastStep,\n          size,\n          step\n        }\n      );\n    }\n    return component;\n  }\n};\n\n// src/components/Step.tsx\nvar JoyrideStep = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"scope\", null);\n    __publicField(this, \"tooltip\", null);\n    /**\n     * Beacon click/hover event listener\n     */\n    __publicField(this, \"handleClickHoverBeacon\", (event) => {\n      const { step, store } = this.props;\n      if (event.type === \"mouseenter\" && step.event !== \"hover\") {\n        return;\n      }\n      store.update({ lifecycle: LIFECYCLE.TOOLTIP });\n    });\n    __publicField(this, \"setTooltipRef\", (element) => {\n      this.tooltip = element;\n    });\n    __publicField(this, \"setPopper\", (popper, type) => {\n      var _a;\n      const { action, lifecycle, step, store } = this.props;\n      if (type === \"wrapper\") {\n        store.setPopper(\"beacon\", popper);\n      } else {\n        store.setPopper(\"tooltip\", popper);\n      }\n      if (store.getPopper(\"beacon\") && (store.getPopper(\"tooltip\") || step.placement === \"center\") && lifecycle === LIFECYCLE.INIT) {\n        store.update({\n          action,\n          lifecycle: LIFECYCLE.READY\n        });\n      }\n      if ((_a = step.floaterProps) == null ? void 0 : _a.getPopper) {\n        step.floaterProps.getPopper(popper, type);\n      }\n    });\n    __publicField(this, \"renderTooltip\", (renderProps) => {\n      const { continuous, helpers, index, size, step } = this.props;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        JoyrideTooltip,\n        {\n          continuous,\n          helpers,\n          index,\n          isLastStep: index + 1 === size,\n          setTooltipRef: this.setTooltipRef,\n          size,\n          step,\n          ...renderProps\n        }\n      );\n    });\n  }\n  componentDidMount() {\n    const { debug, index } = this.props;\n    log({\n      title: `step:${index}`,\n      data: [{ key: \"props\", value: this.props }],\n      debug\n    });\n  }\n  componentDidUpdate(previousProps) {\n    var _a;\n    const {\n      action,\n      callback,\n      continuous,\n      controlled,\n      debug,\n      helpers,\n      index,\n      lifecycle,\n      shouldScroll: shouldScroll2,\n      status,\n      step,\n      store\n    } = this.props;\n    const { changed, changedFrom } = (0,tree_changes__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(previousProps, this.props);\n    const state = helpers.info();\n    const skipBeacon = continuous && action !== ACTIONS.CLOSE && (index > 0 || action === ACTIONS.PREV);\n    const hasStoreChanged = changed(\"action\") || changed(\"index\") || changed(\"lifecycle\") || changed(\"status\");\n    const isInitial = changedFrom(\"lifecycle\", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT);\n    const isAfterAction = changed(\"action\", [\n      ACTIONS.NEXT,\n      ACTIONS.PREV,\n      ACTIONS.SKIP,\n      ACTIONS.CLOSE\n    ]);\n    const isControlled = controlled && index === previousProps.index;\n    if (isAfterAction && (isInitial || isControlled)) {\n      callback({\n        ...state,\n        index: previousProps.index,\n        lifecycle: LIFECYCLE.COMPLETE,\n        step: previousProps.step,\n        type: EVENTS.STEP_AFTER\n      });\n    }\n    if (step.placement === \"center\" && status === STATUS.RUNNING && changed(\"index\") && action !== ACTIONS.START && lifecycle === LIFECYCLE.INIT) {\n      store.update({ lifecycle: LIFECYCLE.READY });\n    }\n    if (hasStoreChanged) {\n      const element = getElement(step.target);\n      const elementExists = !!element;\n      const hasRenderedTarget = elementExists && isElementVisible(element);\n      if (hasRenderedTarget) {\n        if (changedFrom(\"status\", STATUS.READY, STATUS.RUNNING) || changedFrom(\"lifecycle\", LIFECYCLE.INIT, LIFECYCLE.READY)) {\n          callback({\n            ...state,\n            step,\n            type: EVENTS.STEP_BEFORE\n          });\n        }\n      } else {\n        console.warn(elementExists ? \"Target not visible\" : \"Target not mounted\", step);\n        callback({\n          ...state,\n          type: EVENTS.TARGET_NOT_FOUND,\n          step\n        });\n        if (!controlled) {\n          store.update({ index: index + (action === ACTIONS.PREV ? -1 : 1) });\n        }\n      }\n    }\n    if (changedFrom(\"lifecycle\", LIFECYCLE.INIT, LIFECYCLE.READY)) {\n      store.update({\n        lifecycle: hideBeacon(step) || skipBeacon ? LIFECYCLE.TOOLTIP : LIFECYCLE.BEACON\n      });\n    }\n    if (changed(\"index\")) {\n      log({\n        title: `step:${lifecycle}`,\n        data: [{ key: \"props\", value: this.props }],\n        debug\n      });\n    }\n    if (changed(\"lifecycle\", LIFECYCLE.BEACON)) {\n      callback({\n        ...state,\n        step,\n        type: EVENTS.BEACON\n      });\n    }\n    if (changed(\"lifecycle\", LIFECYCLE.TOOLTIP)) {\n      callback({\n        ...state,\n        step,\n        type: EVENTS.TOOLTIP\n      });\n      if (shouldScroll2 && this.tooltip) {\n        this.scope = new Scope(this.tooltip, { selector: \"[data-action=primary]\" });\n        this.scope.setFocus();\n      }\n    }\n    if (changedFrom(\"lifecycle\", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT)) {\n      (_a = this.scope) == null ? void 0 : _a.removeScope();\n      store.cleanupPoppers();\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    (_a = this.scope) == null ? void 0 : _a.removeScope();\n  }\n  get open() {\n    const { lifecycle, step } = this.props;\n    return hideBeacon(step) || lifecycle === LIFECYCLE.TOOLTIP;\n  }\n  render() {\n    const { continuous, debug, index, nonce, shouldScroll: shouldScroll2, size, step } = this.props;\n    const target = getElement(step.target);\n    if (!validateStep(step) || !is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].domElement(target)) {\n      return null;\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: `JoyrideStep-${index}`, className: \"react-joyride__step\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      react_floater__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n      {\n        ...step.floaterProps,\n        component: this.renderTooltip,\n        debug,\n        getPopper: this.setPopper,\n        id: `react-joyride-step-${index}`,\n        open: this.open,\n        placement: step.placement,\n        target: step.target\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        JoyrideBeacon,\n        {\n          beaconComponent: step.beaconComponent,\n          continuous,\n          index,\n          isLastStep: index + 1 === size,\n          locale: step.locale,\n          nonce,\n          onClickOrHover: this.handleClickHoverBeacon,\n          shouldFocus: shouldScroll2,\n          size,\n          step,\n          styles: step.styles\n        }\n      )\n    ));\n  }\n};\n\n// src/components/index.tsx\nvar Joyride = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    __publicField(this, \"helpers\");\n    __publicField(this, \"store\");\n    /**\n     * Trigger the callback.\n     */\n    __publicField(this, \"callback\", (data) => {\n      const { callback } = this.props;\n      if (is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].function(callback)) {\n        callback(data);\n      }\n    });\n    /**\n     * Keydown event listener\n     */\n    __publicField(this, \"handleKeyboard\", (event) => {\n      const { index, lifecycle } = this.state;\n      const { steps } = this.props;\n      const step = steps[index];\n      if (lifecycle === LIFECYCLE.TOOLTIP) {\n        if (event.code === \"Escape\" && step && !step.disableCloseOnEsc) {\n          this.store.close(\"keyboard\");\n        }\n      }\n    });\n    __publicField(this, \"handleClickOverlay\", () => {\n      const { index } = this.state;\n      const { steps } = this.props;\n      const step = getMergedStep(this.props, steps[index]);\n      if (!step.disableOverlayClose) {\n        this.helpers.close(\"overlay\");\n      }\n    });\n    /**\n     * Sync the store with the component's state\n     */\n    __publicField(this, \"syncState\", (state) => {\n      this.setState(state);\n    });\n    const { debug, getHelpers, run = true, stepIndex } = props;\n    this.store = createStore({\n      ...props,\n      controlled: run && is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(stepIndex)\n    });\n    this.helpers = this.store.getHelpers();\n    const { addListener } = this.store;\n    log({\n      title: \"init\",\n      data: [\n        { key: \"props\", value: this.props },\n        { key: \"state\", value: this.state }\n      ],\n      debug\n    });\n    addListener(this.syncState);\n    if (getHelpers) {\n      getHelpers(this.helpers);\n    }\n    this.state = this.store.getState();\n  }\n  componentDidMount() {\n    if (!canUseDOM()) {\n      return;\n    }\n    const { debug, disableCloseOnEsc, run, steps } = this.props;\n    const { start } = this.store;\n    if (validateSteps(steps, debug) && run) {\n      start();\n    }\n    if (!disableCloseOnEsc) {\n      document.body.addEventListener(\"keydown\", this.handleKeyboard, { passive: true });\n    }\n  }\n  componentDidUpdate(previousProps, previousState) {\n    if (!canUseDOM()) {\n      return;\n    }\n    const { action, controlled, index, status } = this.state;\n    const { debug, run, stepIndex, steps } = this.props;\n    const { stepIndex: previousStepIndex, steps: previousSteps } = previousProps;\n    const { reset, setSteps, start, stop, update } = this.store;\n    const { changed: changedProps } = (0,tree_changes__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(previousProps, this.props);\n    const { changed, changedFrom } = (0,tree_changes__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(previousState, this.state);\n    const step = getMergedStep(this.props, steps[index]);\n    const stepsChanged = !(0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(previousSteps, steps);\n    const stepIndexChanged = is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(stepIndex) && changedProps(\"stepIndex\");\n    const target = getElement(step.target);\n    if (stepsChanged) {\n      if (validateSteps(steps, debug)) {\n        setSteps(steps);\n      } else {\n        console.warn(\"Steps are not valid\", steps);\n      }\n    }\n    if (changedProps(\"run\")) {\n      if (run) {\n        start(stepIndex);\n      } else {\n        stop();\n      }\n    }\n    if (stepIndexChanged) {\n      let nextAction = is_lite__WEBPACK_IMPORTED_MODULE_5__[\"default\"].number(previousStepIndex) && previousStepIndex < stepIndex ? ACTIONS.NEXT : ACTIONS.PREV;\n      if (action === ACTIONS.STOP) {\n        nextAction = ACTIONS.START;\n      }\n      if (![STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {\n        update({\n          action: action === ACTIONS.CLOSE ? ACTIONS.CLOSE : nextAction,\n          index: stepIndex,\n          lifecycle: LIFECYCLE.INIT\n        });\n      }\n    }\n    if (!controlled && status === STATUS.RUNNING && index === 0 && !target) {\n      this.store.update({ index: index + 1 });\n      this.callback({\n        ...this.state,\n        type: EVENTS.TARGET_NOT_FOUND,\n        step\n      });\n    }\n    const callbackData = {\n      ...this.state,\n      index,\n      step\n    };\n    const isAfterAction = changed(\"action\", [\n      ACTIONS.NEXT,\n      ACTIONS.PREV,\n      ACTIONS.SKIP,\n      ACTIONS.CLOSE\n    ]);\n    if (isAfterAction && changed(\"status\", STATUS.PAUSED)) {\n      const previousStep = getMergedStep(this.props, steps[previousState.index]);\n      this.callback({\n        ...callbackData,\n        index: previousState.index,\n        lifecycle: LIFECYCLE.COMPLETE,\n        step: previousStep,\n        type: EVENTS.STEP_AFTER\n      });\n    }\n    if (changed(\"status\", [STATUS.FINISHED, STATUS.SKIPPED])) {\n      const previousStep = getMergedStep(this.props, steps[previousState.index]);\n      if (!controlled) {\n        this.callback({\n          ...callbackData,\n          index: previousState.index,\n          lifecycle: LIFECYCLE.COMPLETE,\n          step: previousStep,\n          type: EVENTS.STEP_AFTER\n        });\n      }\n      this.callback({\n        ...callbackData,\n        type: EVENTS.TOUR_END,\n        // Return the last step when the tour is finished\n        step: previousStep,\n        index: previousState.index\n      });\n      reset();\n    } else if (changedFrom(\"status\", [STATUS.IDLE, STATUS.READY], STATUS.RUNNING)) {\n      this.callback({\n        ...callbackData,\n        type: EVENTS.TOUR_START\n      });\n    } else if (changed(\"status\") || changed(\"action\", ACTIONS.RESET)) {\n      this.callback({\n        ...callbackData,\n        type: EVENTS.TOUR_STATUS\n      });\n    }\n    this.scrollToStep(previousState);\n  }\n  componentWillUnmount() {\n    const { disableCloseOnEsc } = this.props;\n    if (!disableCloseOnEsc) {\n      document.body.removeEventListener(\"keydown\", this.handleKeyboard);\n    }\n  }\n  scrollToStep(previousState) {\n    const { index, lifecycle, status } = this.state;\n    const {\n      debug,\n      disableScrollParentFix = false,\n      scrollDuration,\n      scrollOffset = 20,\n      scrollToFirstStep = false,\n      steps\n    } = this.props;\n    const step = getMergedStep(this.props, steps[index]);\n    const target = getElement(step.target);\n    const shouldScrollToStep = shouldScroll({\n      isFirstStep: index === 0,\n      lifecycle,\n      previousLifecycle: previousState.lifecycle,\n      scrollToFirstStep,\n      step,\n      target\n    });\n    if (status === STATUS.RUNNING && shouldScrollToStep) {\n      const hasCustomScroll = hasCustomScrollParent(target, disableScrollParentFix);\n      const scrollParent2 = getScrollParent(target, disableScrollParentFix);\n      let scrollY = Math.floor(getScrollTo(target, scrollOffset, disableScrollParentFix)) || 0;\n      log({\n        title: \"scrollToStep\",\n        data: [\n          { key: \"index\", value: index },\n          { key: \"lifecycle\", value: lifecycle },\n          { key: \"status\", value: status }\n        ],\n        debug\n      });\n      const beaconPopper = this.store.getPopper(\"beacon\");\n      const tooltipPopper = this.store.getPopper(\"tooltip\");\n      if (lifecycle === LIFECYCLE.BEACON && beaconPopper) {\n        const { offsets, placement } = beaconPopper;\n        if (![\"bottom\"].includes(placement) && !hasCustomScroll) {\n          scrollY = Math.floor(offsets.popper.top - scrollOffset);\n        }\n      } else if (lifecycle === LIFECYCLE.TOOLTIP && tooltipPopper) {\n        const { flipped, offsets, placement } = tooltipPopper;\n        if ([\"top\", \"right\", \"left\"].includes(placement) && !flipped && !hasCustomScroll) {\n          scrollY = Math.floor(offsets.popper.top - scrollOffset);\n        } else {\n          scrollY -= step.spotlightPadding;\n        }\n      }\n      scrollY = scrollY >= 0 ? scrollY : 0;\n      if (status === STATUS.RUNNING) {\n        scrollTo(scrollY, { element: scrollParent2, duration: scrollDuration }).then(\n          () => {\n            setTimeout(() => {\n              var _a;\n              (_a = this.store.getPopper(\"tooltip\")) == null ? void 0 : _a.instance.update();\n            }, 10);\n          }\n        );\n      }\n    }\n  }\n  render() {\n    if (!canUseDOM()) {\n      return null;\n    }\n    const { index, lifecycle, status } = this.state;\n    const {\n      continuous = false,\n      debug = false,\n      nonce,\n      scrollToFirstStep = false,\n      steps\n    } = this.props;\n    const isRunning = status === STATUS.RUNNING;\n    const content = {};\n    if (isRunning && steps[index]) {\n      const step = getMergedStep(this.props, steps[index]);\n      content.step = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        JoyrideStep,\n        {\n          ...this.state,\n          callback: this.callback,\n          continuous,\n          debug,\n          helpers: this.helpers,\n          nonce,\n          shouldScroll: !step.disableScrolling && (index !== 0 || scrollToFirstStep),\n          step,\n          store: this.store\n        }\n      );\n      content.overlay = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(JoyridePortal, { id: \"react-joyride-portal\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        JoyrideOverlay,\n        {\n          ...step,\n          continuous,\n          debug,\n          lifecycle,\n          onClickOverlay: this.handleClickOverlay\n        }\n      ));\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"react-joyride\" }, content.step, content.overlay);\n  }\n};\n__publicField(Joyride, \"defaultProps\", defaultProps);\nvar components_default = Joyride;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qb3lyaWRlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDO0FBQ2E7QUFDbkI7QUFDYzs7QUFFeEM7QUFDNEI7QUFDWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQixRQUFRLHlDQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsSUFBSSx1Q0FBVSxtQkFBbUIsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNxRDtBQUNaO0FBQ0Q7QUFDZjtBQUN6QixnQkFBZ0IsbURBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsVUFBVSw0QkFBNEI7QUFDdEMsYUFBYSw0Q0FBUztBQUN0QjtBQUNBLFFBQVEscURBQWM7QUFDdEIscUNBQXFDO0FBQ3JDO0FBQ0EsTUFBTTtBQUNOLGFBQWEsNENBQVM7QUFDdEI7QUFDQSxJQUFJLDBCQUEwQixLQUFLLHNCQUFzQixNQUFNO0FBQy9ELDBCQUEwQixLQUFLLDhCQUE4QixNQUFNO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBRSx5QkFBeUIsK0NBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUEwQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDLHlCQUF5QixtQkFBbUIsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQUU7QUFDaEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLCtDQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sK0NBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUssMkJBQTJCLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxREFBYztBQUNyQjtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCLGtFQUFrRSxLQUFLO0FBQ3ZFLFdBQVcsbURBQVk7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsbURBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2RUFBNkU7QUFDdkY7QUFDQTtBQUNBOztBQUVBO0FBQ21DO0FBQ1Q7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNLElBQUksTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLDZCQUE2QixzQ0FBUywyQ0FBMkMsMENBQTBDO0FBQzNILHVCQUF1QixzQ0FBUyw2QkFBNkIsc0NBQXNDO0FBQ25HLGtCQUFrQixzQ0FBUywyQ0FBMkM7QUFDdEU7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEUsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCLElBQUksd0JBQXdCO0FBQ2xGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLHNDQUFTO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFjO0FBQ25DLHVCQUF1QiwrQ0FBRztBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBYztBQUNyQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQVUsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQWMsc0RBQXNELHlCQUF5QjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBRztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBRztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNDQUFzQztBQUNyRTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3Q0FBd0M7QUFDaEYsS0FBSztBQUNMO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFzRDtBQUNyRixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQUc7QUFDdEIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBd0Q7QUFDdkY7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxZQUFZLDRDQUE0QztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQUc7QUFDdkI7QUFDQSxlQUFlLCtDQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RCxxQkFBcUIsK0NBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0M7QUFDTzs7QUFFdkM7QUFDK0I7QUFDL0IsNEJBQTRCLFFBQVE7QUFDcEMseUJBQXlCLGdEQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyw0Q0FBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDO0FBQ3RFLFNBQVM7QUFDVCxRQUFRO0FBQ1IsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxrRUFBa0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFLFlBQVksVUFBVSxFQUFFLHdEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsZUFBZTtBQUNwSDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksNEJBQTRCO0FBQ3hDLFlBQVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixnREFBb0Isc0JBQXNCLHlCQUF5QjtBQUNuSjtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELG1DQUFtQyxnREFBb0IsVUFBVSxTQUFTLG9CQUFvQjtBQUM5RjtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnQztBQUNNO0FBQ3RDLGtDQUFrQyw0Q0FBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxNQUFNLDBFQUE0QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnQztBQUNJO0FBQ1Y7QUFDYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0M7QUFDTjtBQUMxQixrQ0FBa0MsNENBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsUUFBUSxJQUFxQztBQUM3QyxXQUFXLCtDQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtDQUFHO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnREFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDLGdEQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QixnREFBb0IsV0FBVywyQkFBMkI7QUFDbEYsd0JBQXdCLGdEQUFvQixXQUFXLDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDOztBQUVoQztBQUNnQzs7QUFFaEM7QUFDMkI7QUFDM0IscUNBQXFDLGtCQUFrQjtBQUN2RCxVQUFVLGlDQUFpQztBQUMzQyx5QkFBeUIsZ0RBQW9CLGFBQWEsaUNBQWlDLGtCQUFrQixnREFBb0I7QUFDakk7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixnREFBb0IsNEJBQTRCLGdEQUFvQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsd0ZBQXdGO0FBQ2xHLFVBQVUsc0ZBQXNGO0FBQ2hHO0FBQ0EsbUNBQW1DLGdEQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW9CLGFBQWEsdUZBQXVGO0FBQzFKO0FBQ0EscURBQXFELGdEQUFvQix3QkFBd0IsMkVBQTJFO0FBQzVLLHlCQUF5QixnREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGdEQUFvQixVQUFVLGdDQUFnQywyQkFBMkIsZ0RBQW9CLFNBQVMsbUVBQW1FLDBCQUEwQixnREFBb0IsVUFBVSw4QkFBOEI7QUFDblMsbUNBQW1DLGdEQUFvQixVQUFVLDZCQUE2QixrQkFBa0IsZ0RBQW9CLFVBQVUsbUNBQW1DO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDRDQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLHVEQUF1RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBMkQ7QUFDdkUsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdEQUFvQixxQkFBcUIsZ0JBQWdCO0FBQzNGLE1BQU07QUFDTixrQ0FBa0MsZ0RBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsNENBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCw2QkFBNkIsZ0RBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSx1QkFBdUIsRUFBRSx3REFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLG1EQUFtRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakMsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQTJFO0FBQ3ZGO0FBQ0EsZ0NBQWdDLCtDQUFHO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CLFVBQVUsb0JBQW9CLE1BQU0scUNBQXFDLGtCQUFrQixnREFBb0I7QUFDOUosTUFBTSxxREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLGdEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsNENBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsVUFBVSwrQ0FBRztBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQUc7QUFDNUIsS0FBSztBQUNMO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQsWUFBWSwrQkFBK0I7QUFDM0MsWUFBWSxxREFBcUQ7QUFDakUsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSx3QkFBd0IsRUFBRSx3REFBWTtBQUNsRCxZQUFZLHVCQUF1QixFQUFFLHdEQUFZO0FBQ2pEO0FBQ0EsMEJBQTBCLGtFQUFPO0FBQ2pDLDZCQUE2QiwrQ0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSxvQ0FBb0M7QUFDaEQsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0RBQW9CLGtCQUFrQiw0QkFBNEIsa0JBQWtCLGdEQUFvQjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBb0IsVUFBVSw0QkFBNEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFRRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qb3lyaWRlL2Rpc3QvaW5kZXgubWpzPzJjNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcblxuLy8gc3JjL2xpdGVyYWxzL2luZGV4LnRzXG52YXIgQUNUSU9OUyA9IHtcbiAgSU5JVDogXCJpbml0XCIsXG4gIFNUQVJUOiBcInN0YXJ0XCIsXG4gIFNUT1A6IFwic3RvcFwiLFxuICBSRVNFVDogXCJyZXNldFwiLFxuICBQUkVWOiBcInByZXZcIixcbiAgTkVYVDogXCJuZXh0XCIsXG4gIEdPOiBcImdvXCIsXG4gIENMT1NFOiBcImNsb3NlXCIsXG4gIFNLSVA6IFwic2tpcFwiLFxuICBVUERBVEU6IFwidXBkYXRlXCJcbn07XG52YXIgRVZFTlRTID0ge1xuICBUT1VSX1NUQVJUOiBcInRvdXI6c3RhcnRcIixcbiAgU1RFUF9CRUZPUkU6IFwic3RlcDpiZWZvcmVcIixcbiAgQkVBQ09OOiBcImJlYWNvblwiLFxuICBUT09MVElQOiBcInRvb2x0aXBcIixcbiAgU1RFUF9BRlRFUjogXCJzdGVwOmFmdGVyXCIsXG4gIFRPVVJfRU5EOiBcInRvdXI6ZW5kXCIsXG4gIFRPVVJfU1RBVFVTOiBcInRvdXI6c3RhdHVzXCIsXG4gIFRBUkdFVF9OT1RfRk9VTkQ6IFwiZXJyb3I6dGFyZ2V0X25vdF9mb3VuZFwiLFxuICBFUlJPUjogXCJlcnJvclwiXG59O1xudmFyIExJRkVDWUNMRSA9IHtcbiAgSU5JVDogXCJpbml0XCIsXG4gIFJFQURZOiBcInJlYWR5XCIsXG4gIEJFQUNPTjogXCJiZWFjb25cIixcbiAgVE9PTFRJUDogXCJ0b29sdGlwXCIsXG4gIENPTVBMRVRFOiBcImNvbXBsZXRlXCIsXG4gIEVSUk9SOiBcImVycm9yXCJcbn07XG52YXIgT1JJR0lOID0ge1xuICBCVVRUT05fQ0xPU0U6IFwiYnV0dG9uX2Nsb3NlXCIsXG4gIEJVVFRPTl9QUklNQVJZOiBcImJ1dHRvbl9wcmltYXJ5XCIsXG4gIEtFWUJPQVJEOiBcImtleWJvYXJkXCIsXG4gIE9WRVJMQVk6IFwib3ZlcmxheVwiXG59O1xudmFyIFNUQVRVUyA9IHtcbiAgSURMRTogXCJpZGxlXCIsXG4gIFJFQURZOiBcInJlYWR5XCIsXG4gIFdBSVRJTkc6IFwid2FpdGluZ1wiLFxuICBSVU5OSU5HOiBcInJ1bm5pbmdcIixcbiAgUEFVU0VEOiBcInBhdXNlZFwiLFxuICBTS0lQUEVEOiBcInNraXBwZWRcIixcbiAgRklOSVNIRUQ6IFwiZmluaXNoZWRcIixcbiAgRVJST1I6IFwiZXJyb3JcIlxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvaW5kZXgudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDkgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwiQGdpbGJhcmJhcmEvZGVlcC1lcXVhbFwiO1xuaW1wb3J0IGlzNiBmcm9tIFwiaXMtbGl0ZVwiO1xuaW1wb3J0IHRyZWVDaGFuZ2VzMyBmcm9tIFwidHJlZS1jaGFuZ2VzXCI7XG5cbi8vIHNyYy9tb2R1bGVzL2RvbS50c1xuaW1wb3J0IHNjcm9sbCBmcm9tIFwic2Nyb2xsXCI7XG5pbXBvcnQgc2Nyb2xsUGFyZW50IGZyb20gXCJzY3JvbGxwYXJlbnRcIjtcbmZ1bmN0aW9uIGNhblVzZURPTSgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3JlYXRlRWxlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWlnaHQobWVkaWFuID0gZmFsc2UpIHtcbiAgY29uc3QgeyBib2R5LCBkb2N1bWVudEVsZW1lbnQgfSA9IGRvY3VtZW50O1xuICBpZiAoIWJvZHkgfHwgIWRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChtZWRpYW4pIHtcbiAgICBjb25zdCBoZWlnaHRzID0gW1xuICAgICAgYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICBib2R5Lm9mZnNldEhlaWdodCxcbiAgICAgIGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodFxuICAgIF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoaGVpZ2h0cy5sZW5ndGggLyAyKTtcbiAgICBpZiAoaGVpZ2h0cy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICByZXR1cm4gKGhlaWdodHNbbWlkZGxlIC0gMV0gKyBoZWlnaHRzW21pZGRsZV0pIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodHNbbWlkZGxlXTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoXG4gICAgYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgYm9keS5vZmZzZXRIZWlnaHQsXG4gICAgZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgIGRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwpIHtcbiAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4LCBmb3JMaXN0ZW5lcikge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsRG9jdW1lbnQoKTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBzY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmlzU2FtZU5vZGUoc2Nyb2xsRG9jdW1lbnQoKSkpIHtcbiAgICAgIGlmIChmb3JMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2Nyb2xsRG9jdW1lbnQoKTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2Nyb2xsaW5nID0gcGFyZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKCFoYXNTY3JvbGxpbmcgJiYgIXNraXBGaXgpIHtcbiAgICAgIHBhcmVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaW5pdGlhbFwiO1xuICAgICAgcmV0dXJuIHNjcm9sbERvY3VtZW50KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBoYXNDdXN0b21TY3JvbGxQYXJlbnQoZWxlbWVudCwgc2tpcEZpeCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgpO1xuICByZXR1cm4gcGFyZW50ID8gIXBhcmVudC5pc1NhbWVOb2RlKHNjcm9sbERvY3VtZW50KCkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNDdXN0b21PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQgIT09IGRvY3VtZW50LmJvZHk7XG59XG5mdW5jdGlvbiBoYXNQb3NpdGlvbihlbCwgdHlwZSA9IFwiZml4ZWRcIikge1xuICBpZiAoIWVsIHx8ICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZWw7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCk7XG4gIGlmIChub2RlTmFtZSA9PT0gXCJCT0RZXCIgfHwgbm9kZU5hbWUgPT09IFwiSFRNTFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzdHlsZXMgJiYgc3R5bGVzLnBvc2l0aW9uID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBoYXNQb3NpdGlvbihlbC5wYXJlbnROb2RlLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudFZpc2libGUoZWxlbWVudCkge1xuICB2YXIgX2E7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHdoaWxlIChwYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBjb25zdCB7IGRpc3BsYXksIHZpc2liaWxpdHkgfSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50RWxlbWVudCk7XG4gICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIgfHwgdmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmVudEVsZW1lbnQgPSAoX2EgPSBwYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgb2Zmc2V0LCBza2lwRml4KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBlbGVtZW50UmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gIGNvbnN0IHBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KTtcbiAgY29uc3QgaGFzU2Nyb2xsUGFyZW50ID0gaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgpO1xuICBjb25zdCBpc0ZpeGVkVGFyZ2V0ID0gaGFzUG9zaXRpb24oZWxlbWVudCk7XG4gIGxldCBwYXJlbnRUb3AgPSAwO1xuICBsZXQgdG9wID0gKF9hID0gZWxlbWVudFJlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRSZWN0LnRvcCkgIT0gbnVsbCA/IF9hIDogMDtcbiAgaWYgKGhhc1Njcm9sbFBhcmVudCAmJiBpc0ZpeGVkVGFyZ2V0KSB7XG4gICAgY29uc3Qgb2Zmc2V0VG9wID0gKF9iID0gZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5vZmZzZXRUb3ApICE9IG51bGwgPyBfYiA6IDA7XG4gICAgY29uc3QgcGFyZW50U2Nyb2xsVG9wID0gKF9jID0gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuc2Nyb2xsVG9wKSAhPSBudWxsID8gX2MgOiAwO1xuICAgIHRvcCA9IG9mZnNldFRvcCAtIHBhcmVudFNjcm9sbFRvcDtcbiAgfSBlbHNlIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHBhcmVudFRvcCA9IHBhcmVudC5zY3JvbGxUb3A7XG4gICAgaWYgKCFoYXNTY3JvbGxQYXJlbnQgJiYgIWhhc1Bvc2l0aW9uKGVsZW1lbnQpKSB7XG4gICAgICB0b3AgKz0gcGFyZW50VG9wO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudC5pc1NhbWVOb2RlKHNjcm9sbERvY3VtZW50KCkpKSB7XG4gICAgICB0b3AgKz0gc2Nyb2xsRG9jdW1lbnQoKS5zY3JvbGxUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKHRvcCAtIG9mZnNldCk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxUbyhlbGVtZW50LCBvZmZzZXQsIHNraXBGaXgpIHtcbiAgdmFyIF9hO1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCB7IG9mZnNldFRvcCA9IDAsIHNjcm9sbFRvcCA9IDAgfSA9IChfYSA9IHNjcm9sbFBhcmVudChlbGVtZW50KSkgIT0gbnVsbCA/IF9hIDoge307XG4gIGxldCB0b3AgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHNjcm9sbFRvcDtcbiAgaWYgKCEhb2Zmc2V0VG9wICYmIChoYXNDdXN0b21TY3JvbGxQYXJlbnQoZWxlbWVudCwgc2tpcEZpeCkgfHwgaGFzQ3VzdG9tT2Zmc2V0UGFyZW50KGVsZW1lbnQpKSkge1xuICAgIHRvcCAtPSBvZmZzZXRUb3A7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gTWF0aC5mbG9vcih0b3AgLSBvZmZzZXQpO1xuICByZXR1cm4gb3V0cHV0IDwgMCA/IDAgOiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBzY3JvbGxEb2N1bWVudCgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gc2Nyb2xsVG8odmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBkdXJhdGlvbiwgZWxlbWVudCB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB7IHNjcm9sbFRvcCB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlID4gc2Nyb2xsVG9wID8gdmFsdWUgLSBzY3JvbGxUb3AgOiBzY3JvbGxUb3AgLSB2YWx1ZTtcbiAgICBzY3JvbGwudG9wKGVsZW1lbnQsIHZhbHVlLCB7IGR1cmF0aW9uOiBsaW1pdCA8IDEwMCA/IDUwIDogZHVyYXRpb24gfSwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSAhPT0gXCJFbGVtZW50IGFscmVhZHkgYXQgdGFyZ2V0IHNjcm9sbCBwb3NpdGlvblwiKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIHNyYy9tb2R1bGVzL2hlbHBlcnMudHN4XG5pbXBvcnQgeyBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgaW5uZXJUZXh0IGZyb20gXCJyZWFjdC1pbm5lcnRleHRcIjtcbmltcG9ydCBpcyBmcm9tIFwiaXMtbGl0ZVwiO1xudmFyIGlzUmVhY3QxNiA9IGNyZWF0ZVBvcnRhbCAhPT0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gIGxldCBicm93c2VyID0gdXNlckFnZW50O1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJyb3dzZXIgPSBcIm5vZGVcIjtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICBicm93c2VyID0gXCJpZVwiO1xuICB9IGVsc2UgaWYgKC9FZGdlLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBicm93c2VyID0gXCJlZGdlXCI7XG4gIH0gZWxzZSBpZiAoQm9vbGVhbih3aW5kb3cub3BlcmEpIHx8IHVzZXJBZ2VudC5pbmNsdWRlcyhcIiBPUFIvXCIpKSB7XG4gICAgYnJvd3NlciA9IFwib3BlcmFcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lkluc3RhbGxUcmlnZ2VyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYnJvd3NlciA9IFwiZmlyZWZveFwiO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5jaHJvbWUpIHtcbiAgICBicm93c2VyID0gXCJjaHJvbWVcIjtcbiAgfSBlbHNlIGlmICgvKFZlcnNpb25cXC8oW1xcZC5fXSspLipTYWZhcml8Q3JpT1N8RnhpT1N8IE1vYmlsZVxcLykvLnRlc3QodXNlckFnZW50KSkge1xuICAgIGJyb3dzZXIgPSBcInNhZmFyaVwiO1xuICB9XG4gIHJldHVybiBicm93c2VyO1xufVxuZnVuY3Rpb24gZ2V0T2JqZWN0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0Tm9kZVRleHQoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRlZmF1bHRWYWx1ZSwgc3RlcCwgc3RlcHMgfSA9IG9wdGlvbnM7XG4gIGxldCB0ZXh0ID0gaW5uZXJUZXh0KGlucHV0KTtcbiAgaWYgKCF0ZXh0KSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KGlucHV0KSAmJiAhT2JqZWN0LnZhbHVlcyhpbnB1dC5wcm9wcykubGVuZ3RoICYmIGdldE9iamVjdFR5cGUoaW5wdXQudHlwZSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gaW5wdXQudHlwZSh7fSk7XG4gICAgICB0ZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChjb21wb25lbnQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gaW5uZXJUZXh0KGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCh0ZXh0LmluY2x1ZGVzKFwie3N0ZXB9XCIpIHx8IHRleHQuaW5jbHVkZXMoXCJ7c3RlcHN9XCIpKSAmJiBzdGVwICYmIHN0ZXBzKSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZShcIntzdGVwfVwiLCBzdGVwLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7c3RlcHN9XCIsIHN0ZXBzLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gaGFzVmFsaWRLZXlzKG9iamVjdCwga2V5cykge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KG9iamVjdCkgfHwgIWlzLmFycmF5KGtleXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLmV2ZXJ5KChkKSA9PiBrZXlzLmluY2x1ZGVzKGQpKTtcbn1cbmZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICBjb25zdCBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSkkL2k7XG4gIGNvbnN0IHByb3BlckhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCAoX20sIHIsIGcsIGIpID0+IHIgKyByICsgZyArIGcgKyBiICsgYik7XG4gIGNvbnN0IHJlc3VsdCA9IC9eIz8oW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkkL2kuZXhlYyhwcm9wZXJIZXgpO1xuICByZXR1cm4gcmVzdWx0ID8gW3BhcnNlSW50KHJlc3VsdFsxXSwgMTYpLCBwYXJzZUludChyZXN1bHRbMl0sIDE2KSwgcGFyc2VJbnQocmVzdWx0WzNdLCAxNildIDogW107XG59XG5mdW5jdGlvbiBoaWRlQmVhY29uKHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAuZGlzYWJsZUJlYWNvbiB8fCBzdGVwLnBsYWNlbWVudCA9PT0gXCJjZW50ZXJcIjtcbn1cbmZ1bmN0aW9uIGlzTGVnYWN5KCkge1xuICByZXR1cm4gIVtcImNocm9tZVwiLCBcInNhZmFyaVwiLCBcImZpcmVmb3hcIiwgXCJvcGVyYVwiXS5pbmNsdWRlcyhnZXRCcm93c2VyKCkpO1xufVxuZnVuY3Rpb24gbG9nKHsgZGF0YSwgZGVidWcgPSBmYWxzZSwgdGl0bGUsIHdhcm4gPSBmYWxzZSB9KSB7XG4gIGNvbnN0IGxvZ0ZuID0gd2FybiA/IGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmVycm9yIDogY29uc29sZS5sb2c7XG4gIGlmIChkZWJ1Zykge1xuICAgIGlmICh0aXRsZSAmJiBkYXRhKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICBgJWNyZWFjdC1qb3lyaWRlOiAke3RpdGxlfWAsXG4gICAgICAgIFwiY29sb3I6ICNmZjAwNDQ7IGZvbnQtd2VpZ2h0OiBib2xkOyBmb250LXNpemU6IDEycHg7XCJcbiAgICAgICk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICBpZiAoaXMucGxhaW5PYmplY3QoZCkgJiYgZC5rZXkpIHtcbiAgICAgICAgICAgIGxvZ0ZuLmFwcGx5KGNvbnNvbGUsIFtkLmtleSwgZC52YWx1ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZGF0YV0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyB0aXRsZSBvciBkYXRhIHByb3BzXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXMoaW5wdXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KTtcbn1cbmZ1bmN0aW9uIG9taXQoaW5wdXQsIC4uLmZpbHRlcikge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbiBvYmplY3RcIik7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaW5wdXQsIGtleSkpIHtcbiAgICAgIGlmICghZmlsdGVyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gcGljayhpbnB1dCwgLi4uZmlsdGVyKSB7XG4gIGlmICghaXMucGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFuIG9iamVjdFwiKTtcbiAgfVxuICBpZiAoIWZpbHRlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaW5wdXQsIGtleSkpIHtcbiAgICAgIGlmIChmaWx0ZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiByZXBsYWNlTG9jYWxlQ29udGVudChpbnB1dCwgc3RlcCwgc3RlcHMpIHtcbiAgY29uc3QgcmVwbGFjZXIgPSAodGV4dCkgPT4gdGV4dC5yZXBsYWNlKFwie3N0ZXB9XCIsIFN0cmluZyhzdGVwKSkucmVwbGFjZShcIntzdGVwc31cIiwgU3RyaW5nKHN0ZXBzKSk7XG4gIGlmIChnZXRPYmplY3RUeXBlKGlucHV0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlcihpbnB1dCk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gaW5wdXQucHJvcHM7XG4gIGlmIChnZXRPYmplY3RUeXBlKGNoaWxkcmVuKSA9PT0gXCJzdHJpbmdcIiAmJiBjaGlsZHJlbi5pbmNsdWRlcyhcIntzdGVwfVwiKSkge1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoaW5wdXQsIHtcbiAgICAgIGNoaWxkcmVuOiByZXBsYWNlcihjaGlsZHJlbilcbiAgICB9KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGlucHV0LCB7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGFjZUxvY2FsZUNvbnRlbnQoY2hpbGQsIHN0ZXAsIHN0ZXBzKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKGdldE9iamVjdFR5cGUoaW5wdXQudHlwZSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhT2JqZWN0LnZhbHVlcyhpbnB1dC5wcm9wcykubGVuZ3RoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gaW5wdXQudHlwZSh7fSk7XG4gICAgcmV0dXJuIHJlcGxhY2VMb2NhbGVDb250ZW50KGNvbXBvbmVudCwgc3RlcCwgc3RlcHMpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cbmZ1bmN0aW9uIHNob3VsZFNjcm9sbChvcHRpb25zKSB7XG4gIGNvbnN0IHsgaXNGaXJzdFN0ZXAsIGxpZmVjeWNsZSwgcHJldmlvdXNMaWZlY3ljbGUsIHNjcm9sbFRvRmlyc3RTdGVwLCBzdGVwLCB0YXJnZXQgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAhc3RlcC5kaXNhYmxlU2Nyb2xsaW5nICYmICghaXNGaXJzdFN0ZXAgfHwgc2Nyb2xsVG9GaXJzdFN0ZXAgfHwgbGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuVE9PTFRJUCkgJiYgc3RlcC5wbGFjZW1lbnQgIT09IFwiY2VudGVyXCIgJiYgKCFzdGVwLmlzRml4ZWQgfHwgIWhhc1Bvc2l0aW9uKHRhcmdldCkpICYmIC8vIGZpeGVkIHN0ZXBzIGRvbid0IG5lZWQgdG8gc2Nyb2xsXG4gIHByZXZpb3VzTGlmZWN5Y2xlICE9PSBsaWZlY3ljbGUgJiYgW0xJRkVDWUNMRS5CRUFDT04sIExJRkVDWUNMRS5UT09MVElQXS5pbmNsdWRlcyhsaWZlY3ljbGUpO1xufVxuXG4vLyBzcmMvbW9kdWxlcy9zdGVwLnRzXG5pbXBvcnQgZGVlcG1lcmdlMiBmcm9tIFwiZGVlcG1lcmdlXCI7XG5pbXBvcnQgaXMyIGZyb20gXCJpcy1saXRlXCI7XG5cbi8vIHNyYy9kZWZhdWx0cy50c1xudmFyIGRlZmF1bHRGbG9hdGVyUHJvcHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiBcInNjcm9sbFBhcmVudFwiXG4gICAgfVxuICB9LFxuICB3cmFwcGVyT3B0aW9uczoge1xuICAgIG9mZnNldDogLTE4LFxuICAgIHBvc2l0aW9uOiB0cnVlXG4gIH1cbn07XG52YXIgZGVmYXVsdExvY2FsZSA9IHtcbiAgYmFjazogXCJCYWNrXCIsXG4gIGNsb3NlOiBcIkNsb3NlXCIsXG4gIGxhc3Q6IFwiTGFzdFwiLFxuICBuZXh0OiBcIk5leHRcIixcbiAgbmV4dExhYmVsV2l0aFByb2dyZXNzOiBcIk5leHQgKFN0ZXAge3N0ZXB9IG9mIHtzdGVwc30pXCIsXG4gIG9wZW46IFwiT3BlbiB0aGUgZGlhbG9nXCIsXG4gIHNraXA6IFwiU2tpcFwiXG59O1xudmFyIGRlZmF1bHRTdGVwID0ge1xuICBldmVudDogXCJjbGlja1wiLFxuICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gIG9mZnNldDogMTAsXG4gIGRpc2FibGVCZWFjb246IGZhbHNlLFxuICBkaXNhYmxlQ2xvc2VPbkVzYzogZmFsc2UsXG4gIGRpc2FibGVPdmVybGF5OiBmYWxzZSxcbiAgZGlzYWJsZU92ZXJsYXlDbG9zZTogZmFsc2UsXG4gIGRpc2FibGVTY3JvbGxQYXJlbnRGaXg6IGZhbHNlLFxuICBkaXNhYmxlU2Nyb2xsaW5nOiBmYWxzZSxcbiAgaGlkZUJhY2tCdXR0b246IGZhbHNlLFxuICBoaWRlQ2xvc2VCdXR0b246IGZhbHNlLFxuICBoaWRlRm9vdGVyOiBmYWxzZSxcbiAgaXNGaXhlZDogZmFsc2UsXG4gIGxvY2FsZTogZGVmYXVsdExvY2FsZSxcbiAgc2hvd1Byb2dyZXNzOiBmYWxzZSxcbiAgc2hvd1NraXBCdXR0b246IGZhbHNlLFxuICBzcG90bGlnaHRDbGlja3M6IGZhbHNlLFxuICBzcG90bGlnaHRQYWRkaW5nOiAxMFxufTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRpbnVvdXM6IGZhbHNlLFxuICBkZWJ1ZzogZmFsc2UsXG4gIGRpc2FibGVDbG9zZU9uRXNjOiBmYWxzZSxcbiAgZGlzYWJsZU92ZXJsYXk6IGZhbHNlLFxuICBkaXNhYmxlT3ZlcmxheUNsb3NlOiBmYWxzZSxcbiAgZGlzYWJsZVNjcm9sbGluZzogZmFsc2UsXG4gIGRpc2FibGVTY3JvbGxQYXJlbnRGaXg6IGZhbHNlLFxuICBnZXRIZWxwZXJzOiBub29wKCksXG4gIGhpZGVCYWNrQnV0dG9uOiBmYWxzZSxcbiAgcnVuOiB0cnVlLFxuICBzY3JvbGxPZmZzZXQ6IDIwLFxuICBzY3JvbGxEdXJhdGlvbjogMzAwLFxuICBzY3JvbGxUb0ZpcnN0U3RlcDogZmFsc2UsXG4gIHNob3dTa2lwQnV0dG9uOiBmYWxzZSxcbiAgc2hvd1Byb2dyZXNzOiBmYWxzZSxcbiAgc3BvdGxpZ2h0Q2xpY2tzOiBmYWxzZSxcbiAgc3BvdGxpZ2h0UGFkZGluZzogMTAsXG4gIHN0ZXBzOiBbXVxufTtcblxuLy8gc3JjL3N0eWxlcy50c1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tIFwiZGVlcG1lcmdlXCI7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFycm93Q29sb3I6IFwiI2ZmZlwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZlwiLFxuICBiZWFjb25TaXplOiAzNixcbiAgb3ZlcmxheUNvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC41KVwiLFxuICBwcmltYXJ5Q29sb3I6IFwiI2YwNFwiLFxuICBzcG90bGlnaHRTaGFkb3c6IFwiMCAwIDE1cHggcmdiYSgwLCAwLCAwLCAwLjUpXCIsXG4gIHRleHRDb2xvcjogXCIjMzMzXCIsXG4gIHdpZHRoOiAzODAsXG4gIHpJbmRleDogMTAwXG59O1xudmFyIGJ1dHRvbkJhc2UgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICBib3JkZXI6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgY29sb3I6IFwiIzU1NVwiLFxuICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICBmb250U2l6ZTogMTYsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIHBhZGRpbmc6IDgsXG4gIFdlYmtpdEFwcGVhcmFuY2U6IFwibm9uZVwiXG59O1xudmFyIHNwb3RsaWdodCA9IHtcbiAgYm9yZGVyUmFkaXVzOiA0LFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG59O1xuZnVuY3Rpb24gZ2V0U3R5bGVzKHByb3BzLCBzdGVwKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGNvbnN0IHsgZmxvYXRlclByb3BzLCBzdHlsZXMgfSA9IHByb3BzO1xuICBjb25zdCBtZXJnZWRGbG9hdGVyUHJvcHMgPSBkZWVwbWVyZ2UoKF9hID0gc3RlcC5mbG9hdGVyUHJvcHMpICE9IG51bGwgPyBfYSA6IHt9LCBmbG9hdGVyUHJvcHMgIT0gbnVsbCA/IGZsb2F0ZXJQcm9wcyA6IHt9KTtcbiAgY29uc3QgbWVyZ2VkU3R5bGVzID0gZGVlcG1lcmdlKHN0eWxlcyAhPSBudWxsID8gc3R5bGVzIDoge30sIChfYiA9IHN0ZXAuc3R5bGVzKSAhPSBudWxsID8gX2IgOiB7fSk7XG4gIGNvbnN0IG9wdGlvbnMgPSBkZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG1lcmdlZFN0eWxlcy5vcHRpb25zIHx8IHt9KTtcbiAgY29uc3QgaGlkZUJlYWNvbjIgPSBzdGVwLnBsYWNlbWVudCA9PT0gXCJjZW50ZXJcIiB8fCBzdGVwLmRpc2FibGVCZWFjb247XG4gIGxldCB7IHdpZHRoIH0gPSBvcHRpb25zO1xuICBpZiAod2luZG93LmlubmVyV2lkdGggPiA0ODApIHtcbiAgICB3aWR0aCA9IDM4MDtcbiAgfVxuICBpZiAoXCJ3aWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICB3aWR0aCA9IHR5cGVvZiBvcHRpb25zLndpZHRoID09PSBcIm51bWJlclwiICYmIHdpbmRvdy5pbm5lcldpZHRoIDwgb3B0aW9ucy53aWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIC0gMzAgOiBvcHRpb25zLndpZHRoO1xuICB9XG4gIGNvbnN0IG92ZXJsYXkgPSB7XG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICByaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgekluZGV4OiBvcHRpb25zLnpJbmRleFxuICB9O1xuICBjb25zdCBkZWZhdWx0U3R5bGVzID0ge1xuICAgIGJlYWNvbjoge1xuICAgICAgLi4uYnV0dG9uQmFzZSxcbiAgICAgIGRpc3BsYXk6IGhpZGVCZWFjb24yID8gXCJub25lXCIgOiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgaGVpZ2h0OiBvcHRpb25zLmJlYWNvblNpemUsXG4gICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgd2lkdGg6IG9wdGlvbnMuYmVhY29uU2l6ZSxcbiAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXhcbiAgICB9LFxuICAgIGJlYWNvbklubmVyOiB7XG4gICAgICBhbmltYXRpb246IFwiam95cmlkZS1iZWFjb24taW5uZXIgMS4ycyBpbmZpbml0ZSBlYXNlLWluLW91dFwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLnByaW1hcnlDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIixcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgIGhlaWdodDogXCI1MCVcIixcbiAgICAgIGxlZnQ6IFwiNTAlXCIsXG4gICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiBcIjUwJVwiLFxuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiLFxuICAgICAgd2lkdGg6IFwiNTAlXCJcbiAgICB9LFxuICAgIGJlYWNvbk91dGVyOiB7XG4gICAgICBhbmltYXRpb246IFwiam95cmlkZS1iZWFjb24tb3V0ZXIgMS4ycyBpbmZpbml0ZSBlYXNlLWluLW91dFwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBgcmdiYSgke2hleFRvUkdCKG9wdGlvbnMucHJpbWFyeUNvbG9yKS5qb2luKFwiLFwiKX0sIDAuMilgLFxuICAgICAgYm9yZGVyOiBgMnB4IHNvbGlkICR7b3B0aW9ucy5wcmltYXJ5Q29sb3J9YCxcbiAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIixcbiAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG9wYWNpdHk6IDAuOSxcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB0b3A6IDAsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiY2VudGVyXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCJcbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJSYWRpdXM6IDUsXG4gICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgY29sb3I6IG9wdGlvbnMudGV4dENvbG9yLFxuICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgICAgcGFkZGluZzogMTUsXG4gICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgd2lkdGhcbiAgICB9LFxuICAgIHRvb2x0aXBDb250YWluZXI6IHtcbiAgICAgIGxpbmVIZWlnaHQ6IDEuNCxcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgIH0sXG4gICAgdG9vbHRpcFRpdGxlOiB7XG4gICAgICBmb250U2l6ZTogMTgsXG4gICAgICBtYXJnaW46IDBcbiAgICB9LFxuICAgIHRvb2x0aXBDb250ZW50OiB7XG4gICAgICBwYWRkaW5nOiBcIjIwcHggMTBweFwiXG4gICAgfSxcbiAgICB0b29sdGlwRm9vdGVyOiB7XG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJmbGV4LWVuZFwiLFxuICAgICAgbWFyZ2luVG9wOiAxNVxuICAgIH0sXG4gICAgdG9vbHRpcEZvb3RlclNwYWNlcjoge1xuICAgICAgZmxleDogMVxuICAgIH0sXG4gICAgYnV0dG9uTmV4dDoge1xuICAgICAgLi4uYnV0dG9uQmFzZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5wcmltYXJ5Q29sb3IsXG4gICAgICBib3JkZXJSYWRpdXM6IDQsXG4gICAgICBjb2xvcjogXCIjZmZmXCJcbiAgICB9LFxuICAgIGJ1dHRvbkJhY2s6IHtcbiAgICAgIC4uLmJ1dHRvbkJhc2UsXG4gICAgICBjb2xvcjogb3B0aW9ucy5wcmltYXJ5Q29sb3IsXG4gICAgICBtYXJnaW5MZWZ0OiBcImF1dG9cIixcbiAgICAgIG1hcmdpblJpZ2h0OiA1XG4gICAgfSxcbiAgICBidXR0b25DbG9zZToge1xuICAgICAgLi4uYnV0dG9uQmFzZSxcbiAgICAgIGNvbG9yOiBvcHRpb25zLnRleHRDb2xvcixcbiAgICAgIGhlaWdodDogMTQsXG4gICAgICBwYWRkaW5nOiAxNSxcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHdpZHRoOiAxNFxuICAgIH0sXG4gICAgYnV0dG9uU2tpcDoge1xuICAgICAgLi4uYnV0dG9uQmFzZSxcbiAgICAgIGNvbG9yOiBvcHRpb25zLnRleHRDb2xvcixcbiAgICAgIGZvbnRTaXplOiAxNFxuICAgIH0sXG4gICAgb3ZlcmxheToge1xuICAgICAgLi4ub3ZlcmxheSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5vdmVybGF5Q29sb3IsXG4gICAgICBtaXhCbGVuZE1vZGU6IFwiaGFyZC1saWdodFwiXG4gICAgfSxcbiAgICBvdmVybGF5TGVnYWN5OiB7XG4gICAgICAuLi5vdmVybGF5XG4gICAgfSxcbiAgICBvdmVybGF5TGVnYWN5Q2VudGVyOiB7XG4gICAgICAuLi5vdmVybGF5LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLm92ZXJsYXlDb2xvclxuICAgIH0sXG4gICAgc3BvdGxpZ2h0OiB7XG4gICAgICAuLi5zcG90bGlnaHQsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiZ3JheVwiXG4gICAgfSxcbiAgICBzcG90bGlnaHRMZWdhY3k6IHtcbiAgICAgIC4uLnNwb3RsaWdodCxcbiAgICAgIGJveFNoYWRvdzogYDAgMCAwIDk5OTlweCAke29wdGlvbnMub3ZlcmxheUNvbG9yfSwgJHtvcHRpb25zLnNwb3RsaWdodFNoYWRvd31gXG4gICAgfSxcbiAgICBmbG9hdGVyU3R5bGVzOiB7XG4gICAgICBhcnJvdzoge1xuICAgICAgICBjb2xvcjogKF9lID0gKF9kID0gKF9jID0gbWVyZ2VkRmxvYXRlclByb3BzID09IG51bGwgPyB2b2lkIDAgOiBtZXJnZWRGbG9hdGVyUHJvcHMuc3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuYXJyb3cpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jb2xvcikgIT0gbnVsbCA/IF9lIDogb3B0aW9ucy5hcnJvd0NvbG9yXG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4ICsgMTAwXG4gICAgICB9XG4gICAgfSxcbiAgICBvcHRpb25zXG4gIH07XG4gIHJldHVybiBkZWVwbWVyZ2UoZGVmYXVsdFN0eWxlcywgbWVyZ2VkU3R5bGVzKTtcbn1cblxuLy8gc3JjL21vZHVsZXMvc3RlcC50c1xuZnVuY3Rpb24gZ2V0VG91clByb3BzKHByb3BzKSB7XG4gIHJldHVybiBwaWNrKFxuICAgIHByb3BzLFxuICAgIFwiYmVhY29uQ29tcG9uZW50XCIsXG4gICAgXCJkaXNhYmxlQ2xvc2VPbkVzY1wiLFxuICAgIFwiZGlzYWJsZU92ZXJsYXlcIixcbiAgICBcImRpc2FibGVPdmVybGF5Q2xvc2VcIixcbiAgICBcImRpc2FibGVTY3JvbGxpbmdcIixcbiAgICBcImRpc2FibGVTY3JvbGxQYXJlbnRGaXhcIixcbiAgICBcImZsb2F0ZXJQcm9wc1wiLFxuICAgIFwiaGlkZUJhY2tCdXR0b25cIixcbiAgICBcImhpZGVDbG9zZUJ1dHRvblwiLFxuICAgIFwibG9jYWxlXCIsXG4gICAgXCJzaG93UHJvZ3Jlc3NcIixcbiAgICBcInNob3dTa2lwQnV0dG9uXCIsXG4gICAgXCJzcG90bGlnaHRDbGlja3NcIixcbiAgICBcInNwb3RsaWdodFBhZGRpbmdcIixcbiAgICBcInN0eWxlc1wiLFxuICAgIFwidG9vbHRpcENvbXBvbmVudFwiXG4gICk7XG59XG5mdW5jdGlvbiBnZXRNZXJnZWRTdGVwKHByb3BzLCBjdXJyZW50U3RlcCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3Qgc3RlcCA9IGN1cnJlbnRTdGVwICE9IG51bGwgPyBjdXJyZW50U3RlcCA6IHt9O1xuICBjb25zdCBtZXJnZWRTdGVwID0gZGVlcG1lcmdlMi5hbGwoW2RlZmF1bHRTdGVwLCBnZXRUb3VyUHJvcHMocHJvcHMpLCBzdGVwXSwge1xuICAgIGlzTWVyZ2VhYmxlT2JqZWN0OiBpczIucGxhaW5PYmplY3RcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZFN0eWxlcyA9IGdldFN0eWxlcyhwcm9wcywgbWVyZ2VkU3RlcCk7XG4gIGNvbnN0IHNjcm9sbFBhcmVudDIgPSBoYXNDdXN0b21TY3JvbGxQYXJlbnQoXG4gICAgZ2V0RWxlbWVudChtZXJnZWRTdGVwLnRhcmdldCksXG4gICAgbWVyZ2VkU3RlcC5kaXNhYmxlU2Nyb2xsUGFyZW50Rml4XG4gICk7XG4gIGNvbnN0IGZsb2F0ZXJQcm9wcyA9IGRlZXBtZXJnZTIuYWxsKFtcbiAgICBkZWZhdWx0RmxvYXRlclByb3BzLFxuICAgIChfYSA9IHByb3BzLmZsb2F0ZXJQcm9wcykgIT0gbnVsbCA/IF9hIDoge30sXG4gICAgKF9iID0gbWVyZ2VkU3RlcC5mbG9hdGVyUHJvcHMpICE9IG51bGwgPyBfYiA6IHt9XG4gIF0pO1xuICBmbG9hdGVyUHJvcHMub2Zmc2V0ID0gbWVyZ2VkU3RlcC5vZmZzZXQ7XG4gIGZsb2F0ZXJQcm9wcy5zdHlsZXMgPSBkZWVwbWVyZ2UyKChfYyA9IGZsb2F0ZXJQcm9wcy5zdHlsZXMpICE9IG51bGwgPyBfYyA6IHt9LCBtZXJnZWRTdHlsZXMuZmxvYXRlclN0eWxlcyk7XG4gIGZsb2F0ZXJQcm9wcy5vZmZzZXQgKz0gKF9lID0gKF9kID0gcHJvcHMuc3BvdGxpZ2h0UGFkZGluZykgIT0gbnVsbCA/IF9kIDogbWVyZ2VkU3RlcC5zcG90bGlnaHRQYWRkaW5nKSAhPSBudWxsID8gX2UgOiAwO1xuICBpZiAobWVyZ2VkU3RlcC5wbGFjZW1lbnRCZWFjb24gJiYgZmxvYXRlclByb3BzLndyYXBwZXJPcHRpb25zKSB7XG4gICAgZmxvYXRlclByb3BzLndyYXBwZXJPcHRpb25zLnBsYWNlbWVudCA9IG1lcmdlZFN0ZXAucGxhY2VtZW50QmVhY29uO1xuICB9XG4gIGlmIChzY3JvbGxQYXJlbnQyICYmIGZsb2F0ZXJQcm9wcy5vcHRpb25zLnByZXZlbnRPdmVyZmxvdykge1xuICAgIGZsb2F0ZXJQcm9wcy5vcHRpb25zLnByZXZlbnRPdmVyZmxvdy5ib3VuZGFyaWVzRWxlbWVudCA9IFwid2luZG93XCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tZXJnZWRTdGVwLFxuICAgIGxvY2FsZTogZGVlcG1lcmdlMi5hbGwoW2RlZmF1bHRMb2NhbGUsIChfZiA9IHByb3BzLmxvY2FsZSkgIT0gbnVsbCA/IF9mIDoge30sIG1lcmdlZFN0ZXAubG9jYWxlIHx8IHt9XSksXG4gICAgZmxvYXRlclByb3BzLFxuICAgIHN0eWxlczogb21pdChtZXJnZWRTdHlsZXMsIFwiZmxvYXRlclN0eWxlc1wiKVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTdGVwKHN0ZXAsIGRlYnVnID0gZmFsc2UpIHtcbiAgaWYgKCFpczIucGxhaW5PYmplY3Qoc3RlcCkpIHtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6IFwidmFsaWRhdGVTdGVwXCIsXG4gICAgICBkYXRhOiBcInN0ZXAgbXVzdCBiZSBhbiBvYmplY3RcIixcbiAgICAgIHdhcm46IHRydWUsXG4gICAgICBkZWJ1Z1xuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXN0ZXAudGFyZ2V0KSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcInZhbGlkYXRlU3RlcFwiLFxuICAgICAgZGF0YTogXCJ0YXJnZXQgaXMgbWlzc2luZyBmcm9tIHRoZSBzdGVwXCIsXG4gICAgICB3YXJuOiB0cnVlLFxuICAgICAgZGVidWdcbiAgICB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0ZXBzKHN0ZXBzLCBkZWJ1ZyA9IGZhbHNlKSB7XG4gIGlmICghaXMyLmFycmF5KHN0ZXBzKSkge1xuICAgIGxvZyh7XG4gICAgICB0aXRsZTogXCJ2YWxpZGF0ZVN0ZXBzXCIsXG4gICAgICBkYXRhOiBcInN0ZXBzIG11c3QgYmUgYW4gYXJyYXlcIixcbiAgICAgIHdhcm46IHRydWUsXG4gICAgICBkZWJ1Z1xuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RlcHMuZXZlcnkoKGQpID0+IHZhbGlkYXRlU3RlcChkLCBkZWJ1ZykpO1xufVxuXG4vLyBzcmMvbW9kdWxlcy9zdG9yZS50c1xuaW1wb3J0IGlzMyBmcm9tIFwiaXMtbGl0ZVwiO1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgYWN0aW9uOiBcImluaXRcIixcbiAgY29udHJvbGxlZDogZmFsc2UsXG4gIGluZGV4OiAwLFxuICBsaWZlY3ljbGU6IExJRkVDWUNMRS5JTklULFxuICBvcmlnaW46IG51bGwsXG4gIHNpemU6IDAsXG4gIHN0YXR1czogU1RBVFVTLklETEVcbn07XG52YXIgdmFsaWRLZXlzID0gb2JqZWN0S2V5cyhvbWl0KGRlZmF1bHRTdGF0ZSwgXCJjb250cm9sbGVkXCIsIFwic2l6ZVwiKSk7XG52YXIgU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmVhY29uUG9wcGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0b29sdGlwUG9wcGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaXN0ZW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcmVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkZExpc3RlbmVyXCIsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRTdGVwc1wiLCAoc3RlcHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2l6ZSwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc2l6ZTogc3RlcHMubGVuZ3RoLFxuICAgICAgICBzdGF0dXNcbiAgICAgIH07XG4gICAgICB0aGlzLmRhdGEuc2V0KFwic3RlcHNcIiwgc3RlcHMpO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLldBSVRJTkcgJiYgIXNpemUgJiYgc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLnN0YXR1cyA9IFNUQVRVUy5SVU5OSU5HO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFBvcHBlclwiLCAobmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUgPT09IFwiYmVhY29uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVhY29uUG9wcGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFBvcHBlcjtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0UG9wcGVyXCIsIChuYW1lLCBwb3BwZXIpID0+IHtcbiAgICAgIGlmIChuYW1lID09PSBcImJlYWNvblwiKSB7XG4gICAgICAgIHRoaXMuYmVhY29uUG9wcGVyID0gcG9wcGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b29sdGlwUG9wcGVyID0gcG9wcGVyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbGVhbnVwUG9wcGVyc1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmJlYWNvblBvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLnRvb2x0aXBQb3BwZXIgPSBudWxsO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjbG9zZVwiLCAob3JpZ2luID0gbnVsbCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBTVEFUVVMuUlVOTklORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLi4udGhpcy5nZXROZXh0U3RhdGUoeyBhY3Rpb246IEFDVElPTlMuQ0xPU0UsIGluZGV4OiBpbmRleCArIDEsIG9yaWdpbiB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdvXCIsIChuZXh0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udHJvbGxlZCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoY29udHJvbGxlZCB8fCBzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXBzKClbbmV4dEluZGV4XTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAuLi50aGlzLmdldE5leHRTdGF0ZSh7IGFjdGlvbjogQUNUSU9OUy5HTywgaW5kZXg6IG5leHRJbmRleCB9KSxcbiAgICAgICAgc3RhdHVzOiBzdGVwID8gc3RhdHVzIDogU1RBVFVTLkZJTklTSEVEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5mb1wiLCAoKSA9PiB0aGlzLmdldFN0YXRlKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJuZXh0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5kZXgsIHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldE5leHRTdGF0ZSh7IGFjdGlvbjogQUNUSU9OUy5ORVhULCBpbmRleDogaW5kZXggKyAxIH0pKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3BlblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIC4uLnRoaXMuZ2V0TmV4dFN0YXRlKHsgYWN0aW9uOiBBQ1RJT05TLlVQREFURSwgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuVE9PTFRJUCB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZXZcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBTVEFUVVMuUlVOTklORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLi4udGhpcy5nZXROZXh0U3RhdGUoeyBhY3Rpb246IEFDVElPTlMuUFJFViwgaW5kZXg6IGluZGV4IC0gMSB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc2V0XCIsIChyZXN0YXJ0ID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udHJvbGxlZCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIC4uLnRoaXMuZ2V0TmV4dFN0YXRlKHsgYWN0aW9uOiBBQ1RJT05TLlJFU0VULCBpbmRleDogMCB9KSxcbiAgICAgICAgc3RhdHVzOiByZXN0YXJ0ID8gU1RBVFVTLlJVTk5JTkcgOiBTVEFUVVMuUkVBRFlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJza2lwXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBTVEFUVVMuUlVOTklORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlNLSVAsXG4gICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLklOSVQsXG4gICAgICAgIHN0YXR1czogU1RBVFVTLlNLSVBQRURcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFydFwiLCAobmV4dEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGluZGV4LCBzaXplIH0gPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLi4udGhpcy5nZXROZXh0U3RhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlNUQVJULFxuICAgICAgICAgICAgaW5kZXg6IGlzMy5udW1iZXIobmV4dEluZGV4KSA/IG5leHRJbmRleCA6IGluZGV4XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIHN0YXR1czogc2l6ZSA/IFNUQVRVUy5SVU5OSU5HIDogU1RBVFVTLldBSVRJTkdcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wXCIsIChhZHZhbmNlID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5kZXgsIHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKFtTVEFUVVMuRklOSVNIRUQsIFNUQVRVUy5TS0lQUEVEXS5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAuLi50aGlzLmdldE5leHRTdGF0ZSh7IGFjdGlvbjogQUNUSU9OUy5TVE9QLCBpbmRleDogaW5kZXggKyAoYWR2YW5jZSA/IDEgOiAwKSB9KSxcbiAgICAgICAgc3RhdHVzOiBTVEFUVVMuUEFVU0VEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBkYXRlXCIsIChzdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghaGFzVmFsaWRLZXlzKHN0YXRlLCB2YWxpZEtleXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgaXMgbm90IHZhbGlkLiBWYWxpZCBrZXlzOiAke3ZhbGlkS2V5cy5qb2luKFwiLCBcIil9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLi4udGhpcy5nZXROZXh0U3RhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBhY3Rpb246IChfYSA9IHN0YXRlLmFjdGlvbikgIT0gbnVsbCA/IF9hIDogQUNUSU9OUy5VUERBVEUsXG4gICAgICAgICAgICBvcmlnaW46IChfYiA9IHN0YXRlLm9yaWdpbikgIT0gbnVsbCA/IF9iIDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCB7IGNvbnRpbnVvdXMgPSBmYWxzZSwgc3RlcEluZGV4LCBzdGVwcyA9IFtdIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLklOSVQsXG4gICAgICAgIGNvbnRyb2xsZWQ6IGlzMy5udW1iZXIoc3RlcEluZGV4KSxcbiAgICAgICAgY29udGludW91cyxcbiAgICAgICAgaW5kZXg6IGlzMy5udW1iZXIoc3RlcEluZGV4KSA/IHN0ZXBJbmRleCA6IDAsXG4gICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLklOSVQsXG4gICAgICAgIG9yaWdpbjogbnVsbCxcbiAgICAgICAgc3RhdHVzOiBzdGVwcy5sZW5ndGggPyBTVEFUVVMuUkVBRFkgOiBTVEFUVVMuSURMRVxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHRoaXMuYmVhY29uUG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLnRvb2x0aXBQb3BwZXIgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgIHRoaXMuc2V0U3RlcHMoc3RlcHMpO1xuICB9XG4gIGdldFN0YXRlKCkge1xuICAgIGlmICghdGhpcy5zdG9yZS5zaXplKSB7XG4gICAgICByZXR1cm4geyAuLi5kZWZhdWx0U3RhdGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogdGhpcy5zdG9yZS5nZXQoXCJhY3Rpb25cIikgfHwgXCJcIixcbiAgICAgIGNvbnRyb2xsZWQ6IHRoaXMuc3RvcmUuZ2V0KFwiY29udHJvbGxlZFwiKSB8fCBmYWxzZSxcbiAgICAgIGluZGV4OiBwYXJzZUludCh0aGlzLnN0b3JlLmdldChcImluZGV4XCIpLCAxMCksXG4gICAgICBsaWZlY3ljbGU6IHRoaXMuc3RvcmUuZ2V0KFwibGlmZWN5Y2xlXCIpIHx8IFwiXCIsXG4gICAgICBvcmlnaW46IHRoaXMuc3RvcmUuZ2V0KFwib3JpZ2luXCIpIHx8IG51bGwsXG4gICAgICBzaXplOiB0aGlzLnN0b3JlLmdldChcInNpemVcIikgfHwgMCxcbiAgICAgIHN0YXR1czogdGhpcy5zdG9yZS5nZXQoXCJzdGF0dXNcIikgfHwgXCJcIlxuICAgIH07XG4gIH1cbiAgZ2V0TmV4dFN0YXRlKHN0YXRlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCB7IGFjdGlvbiwgY29udHJvbGxlZCwgaW5kZXgsIHNpemUsIHN0YXR1cyB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gaXMzLm51bWJlcihzdGF0ZS5pbmRleCkgPyBzdGF0ZS5pbmRleCA6IGluZGV4O1xuICAgIGNvbnN0IG5leHRJbmRleCA9IGNvbnRyb2xsZWQgJiYgIWZvcmNlID8gaW5kZXggOiBNYXRoLm1pbihNYXRoLm1heChuZXdJbmRleCwgMCksIHNpemUpO1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IChfYSA9IHN0YXRlLmFjdGlvbikgIT0gbnVsbCA/IF9hIDogYWN0aW9uLFxuICAgICAgY29udHJvbGxlZCxcbiAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICBsaWZlY3ljbGU6IChfYiA9IHN0YXRlLmxpZmVjeWNsZSkgIT0gbnVsbCA/IF9iIDogTElGRUNZQ0xFLklOSVQsXG4gICAgICBvcmlnaW46IChfYyA9IHN0YXRlLm9yaWdpbikgIT0gbnVsbCA/IF9jIDogbnVsbCxcbiAgICAgIHNpemU6IChfZCA9IHN0YXRlLnNpemUpICE9IG51bGwgPyBfZCA6IHNpemUsXG4gICAgICBzdGF0dXM6IG5leHRJbmRleCA9PT0gc2l6ZSA/IFNUQVRVUy5GSU5JU0hFRCA6IChfZSA9IHN0YXRlLnN0YXR1cykgIT0gbnVsbCA/IF9lIDogc3RhdHVzXG4gICAgfTtcbiAgfVxuICBnZXRTdGVwcygpIHtcbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuZGF0YS5nZXQoXCJzdGVwc1wiKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdGVwcykgPyBzdGVwcyA6IFtdO1xuICB9XG4gIGhhc1VwZGF0ZWRTdGF0ZShvbGRTdGF0ZSkge1xuICAgIGNvbnN0IGJlZm9yZSA9IEpTT04uc3RyaW5naWZ5KG9sZFN0YXRlKTtcbiAgICBjb25zdCBhZnRlciA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgcmV0dXJuIGJlZm9yZSAhPT0gYWZ0ZXI7XG4gIH1cbiAgc2V0U3RhdGUobmV4dFN0YXRlLCBpbml0aWFsID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBpbmRleCxcbiAgICAgIGxpZmVjeWNsZSxcbiAgICAgIG9yaWdpbiA9IG51bGwsXG4gICAgICBzaXplLFxuICAgICAgc3RhdHVzXG4gICAgfSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV4dFN0YXRlXG4gICAgfTtcbiAgICB0aGlzLnN0b3JlLnNldChcImFjdGlvblwiLCBhY3Rpb24pO1xuICAgIHRoaXMuc3RvcmUuc2V0KFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgIHRoaXMuc3RvcmUuc2V0KFwibGlmZWN5Y2xlXCIsIGxpZmVjeWNsZSk7XG4gICAgdGhpcy5zdG9yZS5zZXQoXCJvcmlnaW5cIiwgb3JpZ2luKTtcbiAgICB0aGlzLnN0b3JlLnNldChcInNpemVcIiwgc2l6ZSk7XG4gICAgdGhpcy5zdG9yZS5zZXQoXCJzdGF0dXNcIiwgc3RhdHVzKTtcbiAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgdGhpcy5zdG9yZS5zZXQoXCJjb250cm9sbGVkXCIsIG5leHRTdGF0ZS5jb250cm9sbGVkKTtcbiAgICAgIHRoaXMuc3RvcmUuc2V0KFwiY29udGludW91c1wiLCBuZXh0U3RhdGUuY29udGludW91cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpc3RlbmVyICYmIHRoaXMuaGFzVXBkYXRlZFN0YXRlKHN0YXRlKSkge1xuICAgICAgdGhpcy5saXN0ZW5lcih0aGlzLmdldFN0YXRlKCkpO1xuICAgIH1cbiAgfVxuICBnZXRIZWxwZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZTogdGhpcy5jbG9zZSxcbiAgICAgIGdvOiB0aGlzLmdvLFxuICAgICAgaW5mbzogdGhpcy5pbmZvLFxuICAgICAgbmV4dDogdGhpcy5uZXh0LFxuICAgICAgb3BlbjogdGhpcy5vcGVuLFxuICAgICAgcHJldjogdGhpcy5wcmV2LFxuICAgICAgcmVzZXQ6IHRoaXMucmVzZXQsXG4gICAgICBza2lwOiB0aGlzLnNraXBcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFN0b3JlKG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9PdmVybGF5LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHRyZWVDaGFuZ2VzIGZyb20gXCJ0cmVlLWNoYW5nZXNcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvU3BvdGxpZ2h0LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBKb3lyaWRlU3BvdGxpZ2h0KHsgc3R5bGVzIH0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAga2V5OiBcIkpveXJpZGVTcG90bGlnaHRcIixcbiAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX19zcG90bGlnaHRcIixcbiAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwic3BvdGxpZ2h0XCIsXG4gICAgICBzdHlsZTogc3R5bGVzXG4gICAgfVxuICApO1xufVxudmFyIFNwb3RsaWdodF9kZWZhdWx0ID0gSm95cmlkZVNwb3RsaWdodDtcblxuLy8gc3JjL2NvbXBvbmVudHMvT3ZlcmxheS50c3hcbnZhciBKb3lyaWRlT3ZlcmxheSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QyLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzQWN0aXZlXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzaXplVGltZW91dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Nyb2xsVGltZW91dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Nyb2xsUGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBpc1Njcm9sbGluZzogZmFsc2UsXG4gICAgICBtb3VzZU92ZXJTcG90bGlnaHQ6IGZhbHNlLFxuICAgICAgc2hvd1Nwb3RsaWdodDogdHJ1ZVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoaWRlU3BvdGxpZ2h0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGludW91cywgZGlzYWJsZU92ZXJsYXksIGxpZmVjeWNsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGhpZGRlbkxpZmVjeWNsZXMgPSBbXG4gICAgICAgIExJRkVDWUNMRS5JTklULFxuICAgICAgICBMSUZFQ1lDTEUuQkVBQ09OLFxuICAgICAgICBMSUZFQ1lDTEUuQ09NUExFVEUsXG4gICAgICAgIExJRkVDWUNMRS5FUlJPUlxuICAgICAgXTtcbiAgICAgIHJldHVybiBkaXNhYmxlT3ZlcmxheSB8fCAoY29udGludW91cyA/IGhpZGRlbkxpZmVjeWNsZXMuaW5jbHVkZXMobGlmZWN5Y2xlKSA6IGxpZmVjeWNsZSAhPT0gTElGRUNZQ0xFLlRPT0xUSVApO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVNb3VzZU1vdmVcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IG1vdXNlT3ZlclNwb3RsaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0LCBsZWZ0LCBwb3NpdGlvbiwgdG9wLCB3aWR0aCB9ID0gdGhpcy5zcG90bGlnaHRTdHlsZXM7XG4gICAgICBjb25zdCBvZmZzZXRZID0gcG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5wYWdlWTtcbiAgICAgIGNvbnN0IG9mZnNldFggPSBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LnBhZ2VYO1xuICAgICAgY29uc3QgaW5TcG90bGlnaHRIZWlnaHQgPSBvZmZzZXRZID49IHRvcCAmJiBvZmZzZXRZIDw9IHRvcCArIGhlaWdodDtcbiAgICAgIGNvbnN0IGluU3BvdGxpZ2h0V2lkdGggPSBvZmZzZXRYID49IGxlZnQgJiYgb2Zmc2V0WCA8PSBsZWZ0ICsgd2lkdGg7XG4gICAgICBjb25zdCBpblNwb3RsaWdodCA9IGluU3BvdGxpZ2h0V2lkdGggJiYgaW5TcG90bGlnaHRIZWlnaHQ7XG4gICAgICBpZiAoaW5TcG90bGlnaHQgIT09IG1vdXNlT3ZlclNwb3RsaWdodCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgbW91c2VPdmVyU3BvdGxpZ2h0OiBpblNwb3RsaWdodCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBpc1Njcm9sbGluZyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKCFpc1Njcm9sbGluZykge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBpc1Njcm9sbGluZzogdHJ1ZSwgc2hvd1Nwb3RsaWdodDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVGltZW91dCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgaXNTY3JvbGxpbmc6IGZhbHNlLCBzaG93U3BvdGxpZ2h0OiB0cnVlIH0pO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1Bvc2l0aW9uKGVsZW1lbnQsIFwic3RpY2t5XCIpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoe30pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVSZXNpemVcIiwgKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZGVidWcsIGRpc2FibGVTY3JvbGxpbmcsIGRpc2FibGVTY3JvbGxQYXJlbnRGaXggPSBmYWxzZSwgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gICAgdGhpcy5zY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCAhPSBudWxsID8gZWxlbWVudCA6IGRvY3VtZW50LmJvZHksIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgsIHRydWUpO1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghZGlzYWJsZVNjcm9sbGluZyAmJiBoYXNDdXN0b21TY3JvbGxQYXJlbnQoZWxlbWVudCwgdHJ1ZSkpIHtcbiAgICAgICAgbG9nKHtcbiAgICAgICAgICB0aXRsZTogXCJzdGVwIGhhcyBhIGN1c3RvbSBzY3JvbGwgcGFyZW50IGFuZCBjYW4gY2F1c2UgdHJvdWJsZSB3aXRoIHNjcm9sbGluZ1wiLFxuICAgICAgICAgIGRhdGE6IFt7IGtleTogXCJwYXJlbnRcIiwgdmFsdWU6IHRoaXMuc2Nyb2xsUGFyZW50IH1dLFxuICAgICAgICAgIGRlYnVnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4LCBsaWZlY3ljbGUsIHNwb3RsaWdodENsaWNrcywgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgY2hhbmdlZCB9ID0gdHJlZUNoYW5nZXMocHJldmlvdXNQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgaWYgKGNoYW5nZWQoXCJ0YXJnZXRcIikgfHwgY2hhbmdlZChcImRpc2FibGVTY3JvbGxQYXJlbnRGaXhcIikpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gICAgICB0aGlzLnNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50IDogZG9jdW1lbnQuYm9keSwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKFwibGlmZWN5Y2xlXCIsIExJRkVDWUNMRS5UT09MVElQKSkge1xuICAgICAgKF9hID0gdGhpcy5zY3JvbGxQYXJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBpc1Njcm9sbGluZyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKCFpc1Njcm9sbGluZykge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBzaG93U3BvdGxpZ2h0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZChcInNwb3RsaWdodENsaWNrc1wiKSB8fCBjaGFuZ2VkKFwiZGlzYWJsZU92ZXJsYXlcIikgfHwgY2hhbmdlZChcImxpZmVjeWNsZVwiKSkge1xuICAgICAgaWYgKHNwb3RsaWdodENsaWNrcyAmJiBsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5UT09MVElQKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGxpZmVjeWNsZSAhPT0gTElGRUNZQ0xFLlRPT0xUSVApIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVGltZW91dCk7XG4gICAgKF9hID0gdGhpcy5zY3JvbGxQYXJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxuICBnZXQgb3ZlcmxheVN0eWxlcygpIHtcbiAgICBjb25zdCB7IG1vdXNlT3ZlclNwb3RsaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGRpc2FibGVPdmVybGF5Q2xvc2UsIHBsYWNlbWVudCwgc3R5bGVzIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBiYXNlU3R5bGVzID0gc3R5bGVzLm92ZXJsYXk7XG4gICAgaWYgKGlzTGVnYWN5KCkpIHtcbiAgICAgIGJhc2VTdHlsZXMgPSBwbGFjZW1lbnQgPT09IFwiY2VudGVyXCIgPyBzdHlsZXMub3ZlcmxheUxlZ2FjeUNlbnRlciA6IHN0eWxlcy5vdmVybGF5TGVnYWN5O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY3Vyc29yOiBkaXNhYmxlT3ZlcmxheUNsb3NlID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIixcbiAgICAgIGhlaWdodDogZ2V0RG9jdW1lbnRIZWlnaHQoKSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IG1vdXNlT3ZlclNwb3RsaWdodCA/IFwibm9uZVwiIDogXCJhdXRvXCIsXG4gICAgICAuLi5iYXNlU3R5bGVzXG4gICAgfTtcbiAgfVxuICBnZXQgc3BvdGxpZ2h0U3R5bGVzKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgc2hvd1Nwb3RsaWdodCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4ID0gZmFsc2UsXG4gICAgICBzcG90bGlnaHRDbGlja3MsXG4gICAgICBzcG90bGlnaHRQYWRkaW5nID0gMCxcbiAgICAgIHN0eWxlcyxcbiAgICAgIHRhcmdldFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzRml4ZWRUYXJnZXQgPSBoYXNQb3NpdGlvbihlbGVtZW50KTtcbiAgICBjb25zdCB0b3AgPSBnZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgc3BvdGxpZ2h0UGFkZGluZywgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmlzTGVnYWN5KCkgPyBzdHlsZXMuc3BvdGxpZ2h0TGVnYWN5IDogc3R5bGVzLnNwb3RsaWdodCxcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZCgoKF9hID0gZWxlbWVudFJlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRSZWN0LmhlaWdodCkgIT0gbnVsbCA/IF9hIDogMCkgKyBzcG90bGlnaHRQYWRkaW5nICogMiksXG4gICAgICBsZWZ0OiBNYXRoLnJvdW5kKCgoX2IgPSBlbGVtZW50UmVjdCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlY3QubGVmdCkgIT0gbnVsbCA/IF9iIDogMCkgLSBzcG90bGlnaHRQYWRkaW5nKSxcbiAgICAgIG9wYWNpdHk6IHNob3dTcG90bGlnaHQgPyAxIDogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHNwb3RsaWdodENsaWNrcyA/IFwibm9uZVwiIDogXCJhdXRvXCIsXG4gICAgICBwb3NpdGlvbjogaXNGaXhlZFRhcmdldCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcCxcbiAgICAgIHRyYW5zaXRpb246IFwib3BhY2l0eSAwLjJzXCIsXG4gICAgICB3aWR0aDogTWF0aC5yb3VuZCgoKF9jID0gZWxlbWVudFJlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnRSZWN0LndpZHRoKSAhPSBudWxsID8gX2MgOiAwKSArIHNwb3RsaWdodFBhZGRpbmcgKiAyKVxuICAgIH07XG4gIH1cbiAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSgocHJldmlvdXNTdGF0ZSkgPT4gKHsgLi4ucHJldmlvdXNTdGF0ZSwgLi4uc3RhdGUgfSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHNob3dTcG90bGlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBvbkNsaWNrT3ZlcmxheSwgcGxhY2VtZW50IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaGlkZVNwb3RsaWdodCwgb3ZlcmxheVN0eWxlcywgc3BvdGxpZ2h0U3R5bGVzIH0gPSB0aGlzO1xuICAgIGlmIChoaWRlU3BvdGxpZ2h0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc3BvdGxpZ2h0MiA9IHBsYWNlbWVudCAhPT0gXCJjZW50ZXJcIiAmJiBzaG93U3BvdGxpZ2h0ICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChTcG90bGlnaHRfZGVmYXVsdCwgeyBzdHlsZXM6IHNwb3RsaWdodFN0eWxlcyB9KTtcbiAgICBpZiAoZ2V0QnJvd3NlcigpID09PSBcInNhZmFyaVwiKSB7XG4gICAgICBjb25zdCB7IG1peEJsZW5kTW9kZSwgekluZGV4LCAuLi5zYWZhcmlPdmVybGF5IH0gPSBvdmVybGF5U3R5bGVzO1xuICAgICAgc3BvdGxpZ2h0MiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IC4uLnNhZmFyaU92ZXJsYXkgfSB9LCBzcG90bGlnaHQyKTtcbiAgICAgIGRlbGV0ZSBvdmVybGF5U3R5bGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX19vdmVybGF5XCIsXG4gICAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwib3ZlcmxheVwiLFxuICAgICAgICBvbkNsaWNrOiBvbkNsaWNrT3ZlcmxheSxcbiAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgc3R5bGU6IG92ZXJsYXlTdHlsZXNcbiAgICAgIH0sXG4gICAgICBzcG90bGlnaHQyXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvUG9ydGFsLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xudmFyIEpveXJpZGVQb3J0YWwgPSBjbGFzcyBleHRlbmRzIFJlYWN0My5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJub2RlXCIsIG51bGwpO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgaWQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFjYW5Vc2VET00oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubm9kZS5pZCA9IGlkO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICBpZiAoIWlzUmVhY3QxNikge1xuICAgICAgdGhpcy5yZW5kZXJSZWFjdDE1KCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZiAoIWNhblVzZURPTSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNSZWFjdDE2KSB7XG4gICAgICB0aGlzLnJlbmRlclJlYWN0MTUoKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKCFjYW5Vc2VET00oKSB8fCAhdGhpcy5ub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNSZWFjdDE2KSB7XG4gICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVuZGVyUmVhY3QxNSgpIHtcbiAgICBpZiAoIWNhblVzZURPTSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgUmVhY3RET00udW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIodGhpcywgY2hpbGRyZW4sIHRoaXMubm9kZSk7XG4gICAgfVxuICB9XG4gIHJlbmRlclJlYWN0MTYoKSB7XG4gICAgaWYgKCFjYW5Vc2VET00oKSB8fCAhaXNSZWFjdDE2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXRoaXMubm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHRoaXMubm9kZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghaXNSZWFjdDE2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUmVhY3QxNigpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9TdGVwLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q4IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IEZsb2F0ZXIgZnJvbSBcInJlYWN0LWZsb2F0ZXJcIjtcbmltcG9ydCBpczUgZnJvbSBcImlzLWxpdGVcIjtcbmltcG9ydCB0cmVlQ2hhbmdlczIgZnJvbSBcInRyZWUtY2hhbmdlc1wiO1xuXG4vLyBzcmMvbW9kdWxlcy9zY29wZS50c1xudmFyIFNjb3BlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVsZW1lbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhbkJlVGFiYmVkXCIsIChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHRhYkluZGV4IH0gPSBlbGVtZW50O1xuICAgICAgaWYgKHRhYkluZGV4ID09PSBudWxsIHx8IHRhYkluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYW5IYXZlRm9jdXMoZWxlbWVudCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNhbkhhdmVGb2N1c1wiLCAoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRUYWJOb2RlcyA9IC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC87XG4gICAgICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZFRhYk5vZGVzLnRlc3Qobm9kZU5hbWUpICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpIHx8IG5vZGVOYW1lID09PSBcImFcIiAmJiAhIWVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIHJldHVybiBpc1ZhbGlkICYmIHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaW5kVmFsaWRUYWJFbGVtZW50c1wiLCAoKSA9PiBbXS5zbGljZS5jYWxsKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSwgMCkuZmlsdGVyKHRoaXMuY2FuQmVUYWJiZWQpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlS2V5RG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgY29kZSA9IFwiVGFiXCIgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChldmVudC5jb2RlID09PSBjb2RlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0VGFiKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW50ZXJjZXB0VGFiXCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5maW5kVmFsaWRUYWJFbGVtZW50cygpO1xuICAgICAgY29uc3QgeyBzaGlmdEtleSB9ID0gZXZlbnQ7XG4gICAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgeCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBlbGVtZW50cy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIDogMDtcbiAgICAgIGlmICh4ID09PSAtMSB8fCAhc2hpZnRLZXkgJiYgeCArIDEgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2hpZnRLZXkgJiYgeCA9PT0gMCkge1xuICAgICAgICB4ID0gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggKz0gc2hpZnRLZXkgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBlbGVtZW50c1t4XS5mb2N1cygpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzSGlkZGVuXCIsIChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBub1NpemUgPSBlbGVtZW50Lm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbWVudC5vZmZzZXRIZWlnaHQgPD0gMDtcbiAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICBpZiAobm9TaXplICYmICFlbGVtZW50LmlubmVySFRNTCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub1NpemUgJiYgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpICE9PSBcInZpc2libGVcIiB8fCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCI7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzVmlzaWJsZVwiLCAoZWxlbWVudCkgPT4ge1xuICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgd2hpbGUgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4ocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW92ZVNjb3BlXCIsICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjaGVja0ZvY3VzXCIsICh0YXJnZXQpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5jaGVja0ZvY3VzKHRhcmdldCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRGb2N1c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmNoZWNrRm9jdXModGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyOiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnRcIik7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gICAgdGhpcy5zZXRGb2N1cygpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9CZWFjb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdDQgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgaXM0IGZyb20gXCJpcy1saXRlXCI7XG52YXIgSm95cmlkZUJlYWNvbiA9IGNsYXNzIGV4dGVuZHMgUmVhY3Q0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJiZWFjb25cIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEJlYWNvblJlZlwiLCAoYykgPT4ge1xuICAgICAgdGhpcy5iZWFjb24gPSBjO1xuICAgIH0pO1xuICAgIGlmIChwcm9wcy5iZWFjb25Db21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIHN0eWxlLmlkID0gXCJqb3lyaWRlLWJlYWNvbi1hbmltYXRpb25cIjtcbiAgICBpZiAocHJvcHMubm9uY2UpIHtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHByb3BzLm5vbmNlKTtcbiAgICB9XG4gICAgY29uc3QgY3NzID0gYFxuICAgICAgICBAa2V5ZnJhbWVzIGpveXJpZGUtYmVhY29uLWlubmVyIHtcbiAgICAgICAgICAyMCUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC45O1xuICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgOTAlIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIEBrZXlmcmFtZXMgam95cmlkZS1iZWFjb24tb3V0ZXIge1xuICAgICAgICAgIDAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICA0NSUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC43O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcbiAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgIDEwMCUge1xuICAgICAgICAgICAgb3BhY2l0eTogMC45O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBzaG91bGRGb2N1cyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIWlzNC5kb21FbGVtZW50KHRoaXMuYmVhY29uKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJiZWFjb24gaXMgbm90IGEgdmFsaWQgRE9NIGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGlzNC5kb21FbGVtZW50KHRoaXMuYmVhY29uKSAmJiBzaG91bGRGb2N1cykge1xuICAgICAgICB0aGlzLmJlYWNvbi5mb2N1cygpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJqb3lyaWRlLWJlYWNvbi1hbmltYXRpb25cIik7XG4gICAgaWYgKHN0eWxlID09IG51bGwgPyB2b2lkIDAgOiBzdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJlYWNvbkNvbXBvbmVudCxcbiAgICAgIGNvbnRpbnVvdXMsXG4gICAgICBpbmRleCxcbiAgICAgIGlzTGFzdFN0ZXAsXG4gICAgICBsb2NhbGUsXG4gICAgICBvbkNsaWNrT3JIb3ZlcixcbiAgICAgIHNpemUsXG4gICAgICBzdGVwLFxuICAgICAgc3R5bGVzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgdGl0bGUgPSBnZXRSZWFjdE5vZGVUZXh0KGxvY2FsZS5vcGVuKTtcbiAgICBjb25zdCBzaGFyZWRQcm9wcyA9IHtcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aXRsZSxcbiAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tPckhvdmVyLFxuICAgICAgb25Nb3VzZUVudGVyOiBvbkNsaWNrT3JIb3ZlcixcbiAgICAgIHJlZjogdGhpcy5zZXRCZWFjb25SZWYsXG4gICAgICB0aXRsZVxuICAgIH07XG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBpZiAoYmVhY29uQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCBCZWFjb25Db21wb25lbnQgPSBiZWFjb25Db21wb25lbnQ7XG4gICAgICBjb21wb25lbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEJlYWNvbkNvbXBvbmVudCxcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgaXNMYXN0U3RlcCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgLi4uc2hhcmVkUHJvcHNcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICB7XG4gICAgICAgICAga2V5OiBcIkpveXJpZGVCZWFjb25cIixcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVhY3Qtam95cmlkZV9fYmVhY29uXCIsXG4gICAgICAgICAgXCJkYXRhLXRlc3QtaWRcIjogXCJidXR0b24tYmVhY29uXCIsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlcy5iZWFjb24sXG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAuLi5zaGFyZWRQcm9wc1xuICAgICAgICB9LFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgc3R5bGU6IHN0eWxlcy5iZWFjb25Jbm5lciB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHN0eWxlOiBzdHlsZXMuYmVhY29uT3V0ZXIgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL1Rvb2x0aXAvaW5kZXgudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDcgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Rvb2x0aXAvQ29udGFpbmVyLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Ub29sdGlwL0Nsb3NlQnV0dG9uLnRzeFxuaW1wb3J0IFJlYWN0NSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIEpveXJpZGVUb29sdGlwQ2xvc2VCdXR0b24oeyBzdHlsZXMsIC4uLnByb3BzIH0pIHtcbiAgY29uc3QgeyBjb2xvciwgaGVpZ2h0LCB3aWR0aCwgLi4uc3R5bGUgfSA9IHN0eWxlcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHN0eWxlLCB0eXBlOiBcImJ1dHRvblwiLCAuLi5wcm9wcyB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzdmdcIixcbiAgICB7XG4gICAgICBoZWlnaHQ6IHR5cGVvZiBoZWlnaHQgPT09IFwibnVtYmVyXCIgPyBgJHtoZWlnaHR9cHhgIDogaGVpZ2h0LFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZFwiLFxuICAgICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICAgIHZpZXdCb3g6IFwiMCAwIDE4IDE4XCIsXG4gICAgICB3aWR0aDogdHlwZW9mIHdpZHRoID09PSBcIm51bWJlclwiID8gYCR7d2lkdGh9cHhgIDogd2lkdGgsXG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICAgIFwicGF0aFwiLFxuICAgICAge1xuICAgICAgICBkOiBcIk04LjEzOTExMTI5LDkuMDAyNjgxOTEgTDAuMTcxNTIxODI3LDE3LjAyNTg0NjcgQy0wLjA0OTgwMjcwNDksMTcuMjQ4NzE1IC0wLjA0OTgwMjcwNDksMTcuNjA5ODM5NCAwLjE3MTUyMTgyNywxNy44MzI3NTQ1IEMwLjI4MjA0MzU0LDE3Ljk0NDM1MjYgMC40MjcxODgyMDYsMTcuOTk5ODcwNiAwLjU3MjA1MTc2NSwxNy45OTk4NzA2IEMwLjcxNzE0OTU4LDE3Ljk5OTg3MDYgMC44NjIwMTMxMzksMTcuOTQ0MzUyNiAwLjk3MjU4MTcwMywxNy44MzI3NTQ1IEw5LjAwMDA5MzcsOS43NDkyNDYxOCBMMTcuMDI3NjA1NywxNy44MzI3NTQ1IEMxNy4xMzg0MDg1LDE3Ljk0NDM1MjYgMTcuMjgzMjcyMSwxNy45OTk4NzA2IDE3LjQyODEzNTYsMTcuOTk5ODcwNiBDMTcuNTcyOTk5MiwxNy45OTk4NzA2IDE3LjcxODA5NywxNy45NDQzNTI2IDE3LjgyODY2NTYsMTcuODMyNzU0NSBDMTguMDQ5OTkwMSwxNy42MDk4ODYyIDE4LjA0OTk5MDEsMTcuMjQ4NzYxOCAxNy44Mjg2NjU2LDE3LjAyNTg0NjcgTDkuODYxMzU3MjIsOS4wMDI2ODE5MSBMMTcuODM0MDA2NiwwLjk3Mzg0ODIyNSBDMTguMDU1MzMxMSwwLjc1MDk3OTkzNCAxOC4wNTUzMzExLDAuMzg5ODU1NTMyIDE3LjgzNDAwNjYsMC4xNjY5NDAzOSBDMTcuNjEyNjgyMSwtMC4wNTU2NDY3OTY4IDE3LjI1NDAzNywtMC4wNTU2NDY3OTY4IDE3LjAzMjk0NjcsMC4xNjY5NDAzOSBMOS4wMDA0MjE2Niw4LjI1NjExNzY1IEwwLjk2NzAwNjQyNCwwLjE2NzI2ODM0NSBDMC43NDU2ODE4OTIsLTAuMDU1MzE4ODQyNiAwLjM4NzMxNzkzMSwtMC4wNTUzMTg4NDI2IDAuMTY1OTkzMzk5LDAuMTY3MjY4MzQ1IEMtMC4wNTUzMzExMzMxLDAuMzkwMTM2NjM1IC0wLjA1NTMzMTEzMzEsMC43NTEyNjEwMzggMC4xNjU5OTMzOTksMC45NzQxNzYxNzkgTDguMTM5MjA0OTksOS4wMDI2ODE5MSBMOC4xMzkxMTEyOSw5LjAwMjY4MTkxIFpcIixcbiAgICAgICAgZmlsbDogY29sb3JcbiAgICAgIH1cbiAgICApKVxuICApKTtcbn1cbnZhciBDbG9zZUJ1dHRvbl9kZWZhdWx0ID0gSm95cmlkZVRvb2x0aXBDbG9zZUJ1dHRvbjtcblxuLy8gc3JjL2NvbXBvbmVudHMvVG9vbHRpcC9Db250YWluZXIudHN4XG5mdW5jdGlvbiBKb3lyaWRlVG9vbHRpcENvbnRhaW5lcihwcm9wcykge1xuICBjb25zdCB7IGJhY2tQcm9wcywgY2xvc2VQcm9wcywgaW5kZXgsIGlzTGFzdFN0ZXAsIHByaW1hcnlQcm9wcywgc2tpcFByb3BzLCBzdGVwLCB0b29sdGlwUHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbnRlbnQsIGhpZGVCYWNrQnV0dG9uLCBoaWRlQ2xvc2VCdXR0b24sIGhpZGVGb290ZXIsIHNob3dTa2lwQnV0dG9uLCBzdHlsZXMsIHRpdGxlIH0gPSBzdGVwO1xuICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgb3V0cHV0LnByaW1hcnkgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJidXR0b25cIixcbiAgICB7XG4gICAgICBcImRhdGEtdGVzdC1pZFwiOiBcImJ1dHRvbi1wcmltYXJ5XCIsXG4gICAgICBzdHlsZTogc3R5bGVzLmJ1dHRvbk5leHQsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgLi4ucHJpbWFyeVByb3BzXG4gICAgfVxuICApO1xuICBpZiAoc2hvd1NraXBCdXR0b24gJiYgIWlzTGFzdFN0ZXApIHtcbiAgICBvdXRwdXQuc2tpcCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiYnV0dG9uXCIsXG4gICAgICB7XG4gICAgICAgIFwiYXJpYS1saXZlXCI6IFwib2ZmXCIsXG4gICAgICAgIFwiZGF0YS10ZXN0LWlkXCI6IFwiYnV0dG9uLXNraXBcIixcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5idXR0b25Ta2lwLFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAuLi5za2lwUHJvcHNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmICghaGlkZUJhY2tCdXR0b24gJiYgaW5kZXggPiAwKSB7XG4gICAgb3V0cHV0LmJhY2sgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBcImRhdGEtdGVzdC1pZFwiOiBcImJ1dHRvbi1iYWNrXCIsIHN0eWxlOiBzdHlsZXMuYnV0dG9uQmFjaywgdHlwZTogXCJidXR0b25cIiwgLi4uYmFja1Byb3BzIH0pO1xuICB9XG4gIG91dHB1dC5jbG9zZSA9ICFoaWRlQ2xvc2VCdXR0b24gJiYgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KENsb3NlQnV0dG9uX2RlZmF1bHQsIHsgXCJkYXRhLXRlc3QtaWRcIjogXCJidXR0b24tY2xvc2VcIiwgc3R5bGVzOiBzdHlsZXMuYnV0dG9uQ2xvc2UsIC4uLmNsb3NlUHJvcHMgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBrZXk6IFwiSm95cmlkZVRvb2x0aXBcIixcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBnZXRSZWFjdE5vZGVUZXh0KHRpdGxlICE9IG51bGwgPyB0aXRsZSA6IGNvbnRlbnQpLFxuICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVfX3Rvb2x0aXBcIixcbiAgICAgIHN0eWxlOiBzdHlsZXMudG9vbHRpcCxcbiAgICAgIC4uLnRvb2x0aXBQcm9wc1xuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlcy50b29sdGlwQ29udGFpbmVyIH0sIHRpdGxlICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgXCJhcmlhLWxhYmVsXCI6IGdldFJlYWN0Tm9kZVRleHQodGl0bGUpLCBzdHlsZTogc3R5bGVzLnRvb2x0aXBUaXRsZSB9LCB0aXRsZSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBzdHlsZXMudG9vbHRpcENvbnRlbnQgfSwgY29udGVudCkpLFxuICAgICFoaWRlRm9vdGVyICYmIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBzdHlsZXMudG9vbHRpcEZvb3RlciB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGVzLnRvb2x0aXBGb290ZXJTcGFjZXIgfSwgb3V0cHV0LnNraXApLCBvdXRwdXQuYmFjaywgb3V0cHV0LnByaW1hcnkpLFxuICAgIG91dHB1dC5jbG9zZVxuICApO1xufVxudmFyIENvbnRhaW5lcl9kZWZhdWx0ID0gSm95cmlkZVRvb2x0aXBDb250YWluZXI7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Rvb2x0aXAvaW5kZXgudHN4XG52YXIgSm95cmlkZVRvb2x0aXAgPSBjbGFzcyBleHRlbmRzIFJlYWN0Ny5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVDbGlja0JhY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgeyBoZWxwZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaGVscGVycy5wcmV2KCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZUNsaWNrQ2xvc2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgeyBoZWxwZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaGVscGVycy5jbG9zZShcImJ1dHRvbl9jbG9zZVwiKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlQ2xpY2tQcmltYXJ5XCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHsgY29udGludW91cywgaGVscGVycyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghY29udGludW91cykge1xuICAgICAgICBoZWxwZXJzLmNsb3NlKFwiYnV0dG9uX3ByaW1hcnlcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhlbHBlcnMubmV4dCgpO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVDbGlja1NraXBcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgeyBoZWxwZXJzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaGVscGVycy5za2lwKCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEVsZW1lbnRzUHJvcHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250aW51b3VzLCBpbmRleCwgaXNMYXN0U3RlcCwgc2V0VG9vbHRpcFJlZiwgc2l6ZSwgc3RlcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgYmFjaywgY2xvc2UsIGxhc3QsIG5leHQsIG5leHRMYWJlbFdpdGhQcm9ncmVzcywgc2tpcCB9ID0gc3RlcC5sb2NhbGU7XG4gICAgICBjb25zdCBiYWNrVGV4dCA9IGdldFJlYWN0Tm9kZVRleHQoYmFjayk7XG4gICAgICBjb25zdCBjbG9zZVRleHQgPSBnZXRSZWFjdE5vZGVUZXh0KGNsb3NlKTtcbiAgICAgIGNvbnN0IGxhc3RUZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChsYXN0KTtcbiAgICAgIGNvbnN0IG5leHRUZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChuZXh0KTtcbiAgICAgIGNvbnN0IHNraXBUZXh0ID0gZ2V0UmVhY3ROb2RlVGV4dChza2lwKTtcbiAgICAgIGxldCBwcmltYXJ5ID0gY2xvc2U7XG4gICAgICBsZXQgcHJpbWFyeVRleHQgPSBjbG9zZVRleHQ7XG4gICAgICBpZiAoY29udGludW91cykge1xuICAgICAgICBwcmltYXJ5ID0gbmV4dDtcbiAgICAgICAgcHJpbWFyeVRleHQgPSBuZXh0VGV4dDtcbiAgICAgICAgaWYgKHN0ZXAuc2hvd1Byb2dyZXNzICYmICFpc0xhc3RTdGVwKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaXRoUHJvZ3Jlc3MgPSBnZXRSZWFjdE5vZGVUZXh0KG5leHRMYWJlbFdpdGhQcm9ncmVzcywge1xuICAgICAgICAgICAgc3RlcDogaW5kZXggKyAxLFxuICAgICAgICAgICAgc3RlcHM6IHNpemVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmltYXJ5ID0gcmVwbGFjZUxvY2FsZUNvbnRlbnQobmV4dExhYmVsV2l0aFByb2dyZXNzLCBpbmRleCArIDEsIHNpemUpO1xuICAgICAgICAgIHByaW1hcnlUZXh0ID0gbGFiZWxXaXRoUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdFN0ZXApIHtcbiAgICAgICAgICBwcmltYXJ5ID0gbGFzdDtcbiAgICAgICAgICBwcmltYXJ5VGV4dCA9IGxhc3RUZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrUHJvcHM6IHtcbiAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYmFja1RleHQsXG4gICAgICAgICAgY2hpbGRyZW46IGJhY2ssXG4gICAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcImJhY2tcIixcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrQmFjayxcbiAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIHRpdGxlOiBiYWNrVGV4dFxuICAgICAgICB9LFxuICAgICAgICBjbG9zZVByb3BzOiB7XG4gICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGNsb3NlVGV4dCxcbiAgICAgICAgICBjaGlsZHJlbjogY2xvc2UsXG4gICAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcImNsb3NlXCIsXG4gICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja0Nsb3NlLFxuICAgICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgdGl0bGU6IGNsb3NlVGV4dFxuICAgICAgICB9LFxuICAgICAgICBwcmltYXJ5UHJvcHM6IHtcbiAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJpbWFyeVRleHQsXG4gICAgICAgICAgY2hpbGRyZW46IHByaW1hcnksXG4gICAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcInByaW1hcnlcIixcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrUHJpbWFyeSxcbiAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIHRpdGxlOiBwcmltYXJ5VGV4dFxuICAgICAgICB9LFxuICAgICAgICBza2lwUHJvcHM6IHtcbiAgICAgICAgICBcImFyaWEtbGFiZWxcIjogc2tpcFRleHQsXG4gICAgICAgICAgY2hpbGRyZW46IHNraXAsXG4gICAgICAgICAgXCJkYXRhLWFjdGlvblwiOiBcInNraXBcIixcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrU2tpcCxcbiAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIHRpdGxlOiBza2lwVGV4dFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwUHJvcHM6IHtcbiAgICAgICAgICBcImFyaWEtbW9kYWxcIjogdHJ1ZSxcbiAgICAgICAgICByZWY6IHNldFRvb2x0aXBSZWYsXG4gICAgICAgICAgcm9sZTogXCJhbGVydGRpYWxvZ1wiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY29udGludW91cywgaW5kZXgsIGlzTGFzdFN0ZXAsIHNldFRvb2x0aXBSZWYsIHNpemUsIHN0ZXAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBiZWFjb25Db21wb25lbnQsIHRvb2x0aXBDb21wb25lbnQsIC4uLmNsZWFuU3RlcCB9ID0gc3RlcDtcbiAgICBsZXQgY29tcG9uZW50O1xuICAgIGlmICh0b29sdGlwQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRFbGVtZW50c1Byb3BzKCksXG4gICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0xhc3RTdGVwLFxuICAgICAgICBzaXplLFxuICAgICAgICBzdGVwOiBjbGVhblN0ZXAsXG4gICAgICAgIHNldFRvb2x0aXBSZWZcbiAgICAgIH07XG4gICAgICBjb25zdCBUb29sdGlwQ29tcG9uZW50ID0gdG9vbHRpcENvbXBvbmVudDtcbiAgICAgIGNvbXBvbmVudCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChUb29sdGlwQ29tcG9uZW50LCB7IC4uLnJlbmRlclByb3BzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIENvbnRhaW5lcl9kZWZhdWx0LFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5nZXRFbGVtZW50c1Byb3BzKCksXG4gICAgICAgICAgY29udGludW91cyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBpc0xhc3RTdGVwLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgc3RlcFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9TdGVwLnRzeFxudmFyIEpveXJpZGVTdGVwID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDguQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2NvcGVcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvb2x0aXBcIiwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogQmVhY29uIGNsaWNrL2hvdmVyIGV2ZW50IGxpc3RlbmVyXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZUNsaWNrSG92ZXJCZWFjb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHN0ZXAsIHN0b3JlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibW91c2VlbnRlclwiICYmIHN0ZXAuZXZlbnQgIT09IFwiaG92ZXJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9yZS51cGRhdGUoeyBsaWZlY3ljbGU6IExJRkVDWUNMRS5UT09MVElQIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRUb29sdGlwUmVmXCIsIChlbGVtZW50KSA9PiB7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBlbGVtZW50O1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRQb3BwZXJcIiwgKHBvcHBlciwgdHlwZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBhY3Rpb24sIGxpZmVjeWNsZSwgc3RlcCwgc3RvcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ3cmFwcGVyXCIpIHtcbiAgICAgICAgc3RvcmUuc2V0UG9wcGVyKFwiYmVhY29uXCIsIHBvcHBlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5zZXRQb3BwZXIoXCJ0b29sdGlwXCIsIHBvcHBlcik7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcmUuZ2V0UG9wcGVyKFwiYmVhY29uXCIpICYmIChzdG9yZS5nZXRQb3BwZXIoXCJ0b29sdGlwXCIpIHx8IHN0ZXAucGxhY2VtZW50ID09PSBcImNlbnRlclwiKSAmJiBsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5JTklUKSB7XG4gICAgICAgIHN0b3JlLnVwZGF0ZSh7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLlJFQURZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKChfYSA9IHN0ZXAuZmxvYXRlclByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0UG9wcGVyKSB7XG4gICAgICAgIHN0ZXAuZmxvYXRlclByb3BzLmdldFBvcHBlcihwb3BwZXIsIHR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW5kZXJUb29sdGlwXCIsIChyZW5kZXJQcm9wcykgPT4ge1xuICAgICAgY29uc3QgeyBjb250aW51b3VzLCBoZWxwZXJzLCBpbmRleCwgc2l6ZSwgc3RlcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEpveXJpZGVUb29sdGlwLFxuICAgICAgICB7XG4gICAgICAgICAgY29udGludW91cyxcbiAgICAgICAgICBoZWxwZXJzLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGlzTGFzdFN0ZXA6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgICBzZXRUb29sdGlwUmVmOiB0aGlzLnNldFRvb2x0aXBSZWYsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIC4uLnJlbmRlclByb3BzXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBkZWJ1ZywgaW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBgc3RlcDoke2luZGV4fWAsXG4gICAgICBkYXRhOiBbeyBrZXk6IFwicHJvcHNcIiwgdmFsdWU6IHRoaXMucHJvcHMgfV0sXG4gICAgICBkZWJ1Z1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgY29udGludW91cyxcbiAgICAgIGNvbnRyb2xsZWQsXG4gICAgICBkZWJ1ZyxcbiAgICAgIGhlbHBlcnMsXG4gICAgICBpbmRleCxcbiAgICAgIGxpZmVjeWNsZSxcbiAgICAgIHNob3VsZFNjcm9sbDogc2hvdWxkU2Nyb2xsMixcbiAgICAgIHN0YXR1cyxcbiAgICAgIHN0ZXAsXG4gICAgICBzdG9yZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgY2hhbmdlZCwgY2hhbmdlZEZyb20gfSA9IHRyZWVDaGFuZ2VzMihwcmV2aW91c1Byb3BzLCB0aGlzLnByb3BzKTtcbiAgICBjb25zdCBzdGF0ZSA9IGhlbHBlcnMuaW5mbygpO1xuICAgIGNvbnN0IHNraXBCZWFjb24gPSBjb250aW51b3VzICYmIGFjdGlvbiAhPT0gQUNUSU9OUy5DTE9TRSAmJiAoaW5kZXggPiAwIHx8IGFjdGlvbiA9PT0gQUNUSU9OUy5QUkVWKTtcbiAgICBjb25zdCBoYXNTdG9yZUNoYW5nZWQgPSBjaGFuZ2VkKFwiYWN0aW9uXCIpIHx8IGNoYW5nZWQoXCJpbmRleFwiKSB8fCBjaGFuZ2VkKFwibGlmZWN5Y2xlXCIpIHx8IGNoYW5nZWQoXCJzdGF0dXNcIik7XG4gICAgY29uc3QgaXNJbml0aWFsID0gY2hhbmdlZEZyb20oXCJsaWZlY3ljbGVcIiwgW0xJRkVDWUNMRS5UT09MVElQLCBMSUZFQ1lDTEUuSU5JVF0sIExJRkVDWUNMRS5JTklUKTtcbiAgICBjb25zdCBpc0FmdGVyQWN0aW9uID0gY2hhbmdlZChcImFjdGlvblwiLCBbXG4gICAgICBBQ1RJT05TLk5FWFQsXG4gICAgICBBQ1RJT05TLlBSRVYsXG4gICAgICBBQ1RJT05TLlNLSVAsXG4gICAgICBBQ1RJT05TLkNMT1NFXG4gICAgXSk7XG4gICAgY29uc3QgaXNDb250cm9sbGVkID0gY29udHJvbGxlZCAmJiBpbmRleCA9PT0gcHJldmlvdXNQcm9wcy5pbmRleDtcbiAgICBpZiAoaXNBZnRlckFjdGlvbiAmJiAoaXNJbml0aWFsIHx8IGlzQ29udHJvbGxlZCkpIHtcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGluZGV4OiBwcmV2aW91c1Byb3BzLmluZGV4LFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgc3RlcDogcHJldmlvdXNQcm9wcy5zdGVwLFxuICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9BRlRFUlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVwLnBsYWNlbWVudCA9PT0gXCJjZW50ZXJcIiAmJiBzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HICYmIGNoYW5nZWQoXCJpbmRleFwiKSAmJiBhY3Rpb24gIT09IEFDVElPTlMuU1RBUlQgJiYgbGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuSU5JVCkge1xuICAgICAgc3RvcmUudXBkYXRlKHsgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuUkVBRFkgfSk7XG4gICAgfVxuICAgIGlmIChoYXNTdG9yZUNoYW5nZWQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KHN0ZXAudGFyZ2V0KTtcbiAgICAgIGNvbnN0IGVsZW1lbnRFeGlzdHMgPSAhIWVsZW1lbnQ7XG4gICAgICBjb25zdCBoYXNSZW5kZXJlZFRhcmdldCA9IGVsZW1lbnRFeGlzdHMgJiYgaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KTtcbiAgICAgIGlmIChoYXNSZW5kZXJlZFRhcmdldCkge1xuICAgICAgICBpZiAoY2hhbmdlZEZyb20oXCJzdGF0dXNcIiwgU1RBVFVTLlJFQURZLCBTVEFUVVMuUlVOTklORykgfHwgY2hhbmdlZEZyb20oXCJsaWZlY3ljbGVcIiwgTElGRUNZQ0xFLklOSVQsIExJRkVDWUNMRS5SRUFEWSkpIHtcbiAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9CRUZPUkVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGVsZW1lbnRFeGlzdHMgPyBcIlRhcmdldCBub3QgdmlzaWJsZVwiIDogXCJUYXJnZXQgbm90IG1vdW50ZWRcIiwgc3RlcCk7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICB0eXBlOiBFVkVOVFMuVEFSR0VUX05PVF9GT1VORCxcbiAgICAgICAgICBzdGVwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbnRyb2xsZWQpIHtcbiAgICAgICAgICBzdG9yZS51cGRhdGUoeyBpbmRleDogaW5kZXggKyAoYWN0aW9uID09PSBBQ1RJT05TLlBSRVYgPyAtMSA6IDEpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkRnJvbShcImxpZmVjeWNsZVwiLCBMSUZFQ1lDTEUuSU5JVCwgTElGRUNZQ0xFLlJFQURZKSkge1xuICAgICAgc3RvcmUudXBkYXRlKHtcbiAgICAgICAgbGlmZWN5Y2xlOiBoaWRlQmVhY29uKHN0ZXApIHx8IHNraXBCZWFjb24gPyBMSUZFQ1lDTEUuVE9PTFRJUCA6IExJRkVDWUNMRS5CRUFDT05cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZChcImluZGV4XCIpKSB7XG4gICAgICBsb2coe1xuICAgICAgICB0aXRsZTogYHN0ZXA6JHtsaWZlY3ljbGV9YCxcbiAgICAgICAgZGF0YTogW3sga2V5OiBcInByb3BzXCIsIHZhbHVlOiB0aGlzLnByb3BzIH1dLFxuICAgICAgICBkZWJ1Z1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKFwibGlmZWN5Y2xlXCIsIExJRkVDWUNMRS5CRUFDT04pKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0eXBlOiBFVkVOVFMuQkVBQ09OXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQoXCJsaWZlY3ljbGVcIiwgTElGRUNZQ0xFLlRPT0xUSVApKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0eXBlOiBFVkVOVFMuVE9PTFRJUFxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkU2Nyb2xsMiAmJiB0aGlzLnRvb2x0aXApIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZSh0aGlzLnRvb2x0aXAsIHsgc2VsZWN0b3I6IFwiW2RhdGEtYWN0aW9uPXByaW1hcnldXCIgfSk7XG4gICAgICAgIHRoaXMuc2NvcGUuc2V0Rm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZWRGcm9tKFwibGlmZWN5Y2xlXCIsIFtMSUZFQ1lDTEUuVE9PTFRJUCwgTElGRUNZQ0xFLklOSVRdLCBMSUZFQ1lDTEUuSU5JVCkpIHtcbiAgICAgIChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVTY29wZSgpO1xuICAgICAgc3RvcmUuY2xlYW51cFBvcHBlcnMoKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVTY29wZSgpO1xuICB9XG4gIGdldCBvcGVuKCkge1xuICAgIGNvbnN0IHsgbGlmZWN5Y2xlLCBzdGVwIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBoaWRlQmVhY29uKHN0ZXApIHx8IGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY29udGludW91cywgZGVidWcsIGluZGV4LCBub25jZSwgc2hvdWxkU2Nyb2xsOiBzaG91bGRTY3JvbGwyLCBzaXplLCBzdGVwIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnQoc3RlcC50YXJnZXQpO1xuICAgIGlmICghdmFsaWRhdGVTdGVwKHN0ZXApIHx8ICFpczUuZG9tRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYEpveXJpZGVTdGVwLSR7aW5kZXh9YCwgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVfX3N0ZXBcIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBGbG9hdGVyLFxuICAgICAge1xuICAgICAgICAuLi5zdGVwLmZsb2F0ZXJQcm9wcyxcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnJlbmRlclRvb2x0aXAsXG4gICAgICAgIGRlYnVnLFxuICAgICAgICBnZXRQb3BwZXI6IHRoaXMuc2V0UG9wcGVyLFxuICAgICAgICBpZDogYHJlYWN0LWpveXJpZGUtc3RlcC0ke2luZGV4fWAsXG4gICAgICAgIG9wZW46IHRoaXMub3BlbixcbiAgICAgICAgcGxhY2VtZW50OiBzdGVwLnBsYWNlbWVudCxcbiAgICAgICAgdGFyZ2V0OiBzdGVwLnRhcmdldFxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcbiAgICAgICAgSm95cmlkZUJlYWNvbixcbiAgICAgICAge1xuICAgICAgICAgIGJlYWNvbkNvbXBvbmVudDogc3RlcC5iZWFjb25Db21wb25lbnQsXG4gICAgICAgICAgY29udGludW91cyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBpc0xhc3RTdGVwOiBpbmRleCArIDEgPT09IHNpemUsXG4gICAgICAgICAgbG9jYWxlOiBzdGVwLmxvY2FsZSxcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBvbkNsaWNrT3JIb3ZlcjogdGhpcy5oYW5kbGVDbGlja0hvdmVyQmVhY29uLFxuICAgICAgICAgIHNob3VsZEZvY3VzOiBzaG91bGRTY3JvbGwyLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgc3RlcCxcbiAgICAgICAgICBzdHlsZXM6IHN0ZXAuc3R5bGVzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvaW5kZXgudHN4XG52YXIgSm95cmlkZSA9IGNsYXNzIGV4dGVuZHMgUmVhY3Q5LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWxwZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9yZVwiKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FsbGJhY2tcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoaXM2LmZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBLZXlkb3duIGV2ZW50IGxpc3RlbmVyXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZUtleWJvYXJkXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBpbmRleCwgbGlmZWN5Y2xlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgeyBzdGVwcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tpbmRleF07XG4gICAgICBpZiAobGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICBpZiAoZXZlbnQuY29kZSA9PT0gXCJFc2NhcGVcIiAmJiBzdGVwICYmICFzdGVwLmRpc2FibGVDbG9zZU9uRXNjKSB7XG4gICAgICAgICAgdGhpcy5zdG9yZS5jbG9zZShcImtleWJvYXJkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZUNsaWNrT3ZlcmxheVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGluZGV4IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgeyBzdGVwcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHN0ZXAgPSBnZXRNZXJnZWRTdGVwKHRoaXMucHJvcHMsIHN0ZXBzW2luZGV4XSk7XG4gICAgICBpZiAoIXN0ZXAuZGlzYWJsZU92ZXJsYXlDbG9zZSkge1xuICAgICAgICB0aGlzLmhlbHBlcnMuY2xvc2UoXCJvdmVybGF5XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFN5bmMgdGhlIHN0b3JlIHdpdGggdGhlIGNvbXBvbmVudCdzIHN0YXRlXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN5bmNTdGF0ZVwiLCAoc3RhdGUpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgZGVidWcsIGdldEhlbHBlcnMsIHJ1biA9IHRydWUsIHN0ZXBJbmRleCB9ID0gcHJvcHM7XG4gICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgY29udHJvbGxlZDogcnVuICYmIGlzNi5udW1iZXIoc3RlcEluZGV4KVxuICAgIH0pO1xuICAgIHRoaXMuaGVscGVycyA9IHRoaXMuc3RvcmUuZ2V0SGVscGVycygpO1xuICAgIGNvbnN0IHsgYWRkTGlzdGVuZXIgfSA9IHRoaXMuc3RvcmU7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiBcImluaXRcIixcbiAgICAgIGRhdGE6IFtcbiAgICAgICAgeyBrZXk6IFwicHJvcHNcIiwgdmFsdWU6IHRoaXMucHJvcHMgfSxcbiAgICAgICAgeyBrZXk6IFwic3RhdGVcIiwgdmFsdWU6IHRoaXMuc3RhdGUgfVxuICAgICAgXSxcbiAgICAgIGRlYnVnXG4gICAgfSk7XG4gICAgYWRkTGlzdGVuZXIodGhpcy5zeW5jU3RhdGUpO1xuICAgIGlmIChnZXRIZWxwZXJzKSB7XG4gICAgICBnZXRIZWxwZXJzKHRoaXMuaGVscGVycyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCFjYW5Vc2VET00oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRlYnVnLCBkaXNhYmxlQ2xvc2VPbkVzYywgcnVuLCBzdGVwcyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHN0YXJ0IH0gPSB0aGlzLnN0b3JlO1xuICAgIGlmICh2YWxpZGF0ZVN0ZXBzKHN0ZXBzLCBkZWJ1ZykgJiYgcnVuKSB7XG4gICAgICBzdGFydCgpO1xuICAgIH1cbiAgICBpZiAoIWRpc2FibGVDbG9zZU9uRXNjKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5Ym9hcmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHMsIHByZXZpb3VzU3RhdGUpIHtcbiAgICBpZiAoIWNhblVzZURPTSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgYWN0aW9uLCBjb250cm9sbGVkLCBpbmRleCwgc3RhdHVzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgZGVidWcsIHJ1biwgc3RlcEluZGV4LCBzdGVwcyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHN0ZXBJbmRleDogcHJldmlvdXNTdGVwSW5kZXgsIHN0ZXBzOiBwcmV2aW91c1N0ZXBzIH0gPSBwcmV2aW91c1Byb3BzO1xuICAgIGNvbnN0IHsgcmVzZXQsIHNldFN0ZXBzLCBzdGFydCwgc3RvcCwgdXBkYXRlIH0gPSB0aGlzLnN0b3JlO1xuICAgIGNvbnN0IHsgY2hhbmdlZDogY2hhbmdlZFByb3BzIH0gPSB0cmVlQ2hhbmdlczMocHJldmlvdXNQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgY29uc3QgeyBjaGFuZ2VkLCBjaGFuZ2VkRnJvbSB9ID0gdHJlZUNoYW5nZXMzKHByZXZpb3VzU3RhdGUsIHRoaXMuc3RhdGUpO1xuICAgIGNvbnN0IHN0ZXAgPSBnZXRNZXJnZWRTdGVwKHRoaXMucHJvcHMsIHN0ZXBzW2luZGV4XSk7XG4gICAgY29uc3Qgc3RlcHNDaGFuZ2VkID0gIWlzRXF1YWwocHJldmlvdXNTdGVwcywgc3RlcHMpO1xuICAgIGNvbnN0IHN0ZXBJbmRleENoYW5nZWQgPSBpczYubnVtYmVyKHN0ZXBJbmRleCkgJiYgY2hhbmdlZFByb3BzKFwic3RlcEluZGV4XCIpO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnQoc3RlcC50YXJnZXQpO1xuICAgIGlmIChzdGVwc0NoYW5nZWQpIHtcbiAgICAgIGlmICh2YWxpZGF0ZVN0ZXBzKHN0ZXBzLCBkZWJ1ZykpIHtcbiAgICAgICAgc2V0U3RlcHMoc3RlcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU3RlcHMgYXJlIG5vdCB2YWxpZFwiLCBzdGVwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkUHJvcHMoXCJydW5cIikpIHtcbiAgICAgIGlmIChydW4pIHtcbiAgICAgICAgc3RhcnQoc3RlcEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0ZXBJbmRleENoYW5nZWQpIHtcbiAgICAgIGxldCBuZXh0QWN0aW9uID0gaXM2Lm51bWJlcihwcmV2aW91c1N0ZXBJbmRleCkgJiYgcHJldmlvdXNTdGVwSW5kZXggPCBzdGVwSW5kZXggPyBBQ1RJT05TLk5FWFQgOiBBQ1RJT05TLlBSRVY7XG4gICAgICBpZiAoYWN0aW9uID09PSBBQ1RJT05TLlNUT1ApIHtcbiAgICAgICAgbmV4dEFjdGlvbiA9IEFDVElPTlMuU1RBUlQ7XG4gICAgICB9XG4gICAgICBpZiAoIVtTVEFUVVMuRklOSVNIRUQsIFNUQVRVUy5TS0lQUEVEXS5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgIHVwZGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24gPT09IEFDVElPTlMuQ0xPU0UgPyBBQ1RJT05TLkNMT1NFIDogbmV4dEFjdGlvbixcbiAgICAgICAgICBpbmRleDogc3RlcEluZGV4LFxuICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLklOSVRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29udHJvbGxlZCAmJiBzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HICYmIGluZGV4ID09PSAwICYmICF0YXJnZXQpIHtcbiAgICAgIHRoaXMuc3RvcmUudXBkYXRlKHsgaW5kZXg6IGluZGV4ICsgMSB9KTtcbiAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICB0eXBlOiBFVkVOVFMuVEFSR0VUX05PVF9GT1VORCxcbiAgICAgICAgc3RlcFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxiYWNrRGF0YSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBpbmRleCxcbiAgICAgIHN0ZXBcbiAgICB9O1xuICAgIGNvbnN0IGlzQWZ0ZXJBY3Rpb24gPSBjaGFuZ2VkKFwiYWN0aW9uXCIsIFtcbiAgICAgIEFDVElPTlMuTkVYVCxcbiAgICAgIEFDVElPTlMuUFJFVixcbiAgICAgIEFDVElPTlMuU0tJUCxcbiAgICAgIEFDVElPTlMuQ0xPU0VcbiAgICBdKTtcbiAgICBpZiAoaXNBZnRlckFjdGlvbiAmJiBjaGFuZ2VkKFwic3RhdHVzXCIsIFNUQVRVUy5QQVVTRUQpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0ZXAgPSBnZXRNZXJnZWRTdGVwKHRoaXMucHJvcHMsIHN0ZXBzW3ByZXZpb3VzU3RhdGUuaW5kZXhdKTtcbiAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAuLi5jYWxsYmFja0RhdGEsXG4gICAgICAgIGluZGV4OiBwcmV2aW91c1N0YXRlLmluZGV4LFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgc3RlcDogcHJldmlvdXNTdGVwLFxuICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9BRlRFUlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKFwic3RhdHVzXCIsIFtTVEFUVVMuRklOSVNIRUQsIFNUQVRVUy5TS0lQUEVEXSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RlcCA9IGdldE1lcmdlZFN0ZXAodGhpcy5wcm9wcywgc3RlcHNbcHJldmlvdXNTdGF0ZS5pbmRleF0pO1xuICAgICAgaWYgKCFjb250cm9sbGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIC4uLmNhbGxiYWNrRGF0YSxcbiAgICAgICAgICBpbmRleDogcHJldmlvdXNTdGF0ZS5pbmRleCxcbiAgICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgICBzdGVwOiBwcmV2aW91c1N0ZXAsXG4gICAgICAgICAgdHlwZTogRVZFTlRTLlNURVBfQUZURVJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxiYWNrKHtcbiAgICAgICAgLi4uY2FsbGJhY2tEYXRhLFxuICAgICAgICB0eXBlOiBFVkVOVFMuVE9VUl9FTkQsXG4gICAgICAgIC8vIFJldHVybiB0aGUgbGFzdCBzdGVwIHdoZW4gdGhlIHRvdXIgaXMgZmluaXNoZWRcbiAgICAgICAgc3RlcDogcHJldmlvdXNTdGVwLFxuICAgICAgICBpbmRleDogcHJldmlvdXNTdGF0ZS5pbmRleFxuICAgICAgfSk7XG4gICAgICByZXNldCgpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlZEZyb20oXCJzdGF0dXNcIiwgW1NUQVRVUy5JRExFLCBTVEFUVVMuUkVBRFldLCBTVEFUVVMuUlVOTklORykpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAuLi5jYWxsYmFja0RhdGEsXG4gICAgICAgIHR5cGU6IEVWRU5UUy5UT1VSX1NUQVJUXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZWQoXCJzdGF0dXNcIikgfHwgY2hhbmdlZChcImFjdGlvblwiLCBBQ1RJT05TLlJFU0VUKSkge1xuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIC4uLmNhbGxiYWNrRGF0YSxcbiAgICAgICAgdHlwZTogRVZFTlRTLlRPVVJfU1RBVFVTXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxUb1N0ZXAocHJldmlvdXNTdGF0ZSk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgeyBkaXNhYmxlQ2xvc2VPbkVzYyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWRpc2FibGVDbG9zZU9uRXNjKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5Ym9hcmQpO1xuICAgIH1cbiAgfVxuICBzY3JvbGxUb1N0ZXAocHJldmlvdXNTdGF0ZSkge1xuICAgIGNvbnN0IHsgaW5kZXgsIGxpZmVjeWNsZSwgc3RhdHVzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlYnVnLFxuICAgICAgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCA9IGZhbHNlLFxuICAgICAgc2Nyb2xsRHVyYXRpb24sXG4gICAgICBzY3JvbGxPZmZzZXQgPSAyMCxcbiAgICAgIHNjcm9sbFRvRmlyc3RTdGVwID0gZmFsc2UsXG4gICAgICBzdGVwc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHN0ZXAgPSBnZXRNZXJnZWRTdGVwKHRoaXMucHJvcHMsIHN0ZXBzW2luZGV4XSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudChzdGVwLnRhcmdldCk7XG4gICAgY29uc3Qgc2hvdWxkU2Nyb2xsVG9TdGVwID0gc2hvdWxkU2Nyb2xsKHtcbiAgICAgIGlzRmlyc3RTdGVwOiBpbmRleCA9PT0gMCxcbiAgICAgIGxpZmVjeWNsZSxcbiAgICAgIHByZXZpb3VzTGlmZWN5Y2xlOiBwcmV2aW91c1N0YXRlLmxpZmVjeWNsZSxcbiAgICAgIHNjcm9sbFRvRmlyc3RTdGVwLFxuICAgICAgc3RlcCxcbiAgICAgIHRhcmdldFxuICAgIH0pO1xuICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HICYmIHNob3VsZFNjcm9sbFRvU3RlcCkge1xuICAgICAgY29uc3QgaGFzQ3VzdG9tU2Nyb2xsID0gaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KHRhcmdldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgICBjb25zdCBzY3JvbGxQYXJlbnQyID0gZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgICBsZXQgc2Nyb2xsWSA9IE1hdGguZmxvb3IoZ2V0U2Nyb2xsVG8odGFyZ2V0LCBzY3JvbGxPZmZzZXQsIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgpKSB8fCAwO1xuICAgICAgbG9nKHtcbiAgICAgICAgdGl0bGU6IFwic2Nyb2xsVG9TdGVwXCIsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICB7IGtleTogXCJpbmRleFwiLCB2YWx1ZTogaW5kZXggfSxcbiAgICAgICAgICB7IGtleTogXCJsaWZlY3ljbGVcIiwgdmFsdWU6IGxpZmVjeWNsZSB9LFxuICAgICAgICAgIHsga2V5OiBcInN0YXR1c1wiLCB2YWx1ZTogc3RhdHVzIH1cbiAgICAgICAgXSxcbiAgICAgICAgZGVidWdcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYmVhY29uUG9wcGVyID0gdGhpcy5zdG9yZS5nZXRQb3BwZXIoXCJiZWFjb25cIik7XG4gICAgICBjb25zdCB0b29sdGlwUG9wcGVyID0gdGhpcy5zdG9yZS5nZXRQb3BwZXIoXCJ0b29sdGlwXCIpO1xuICAgICAgaWYgKGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLkJFQUNPTiAmJiBiZWFjb25Qb3BwZXIpIHtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRzLCBwbGFjZW1lbnQgfSA9IGJlYWNvblBvcHBlcjtcbiAgICAgICAgaWYgKCFbXCJib3R0b21cIl0uaW5jbHVkZXMocGxhY2VtZW50KSAmJiAhaGFzQ3VzdG9tU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsWSA9IE1hdGguZmxvb3Iob2Zmc2V0cy5wb3BwZXIudG9wIC0gc2Nyb2xsT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5UT09MVElQICYmIHRvb2x0aXBQb3BwZXIpIHtcbiAgICAgICAgY29uc3QgeyBmbGlwcGVkLCBvZmZzZXRzLCBwbGFjZW1lbnQgfSA9IHRvb2x0aXBQb3BwZXI7XG4gICAgICAgIGlmIChbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImxlZnRcIl0uaW5jbHVkZXMocGxhY2VtZW50KSAmJiAhZmxpcHBlZCAmJiAhaGFzQ3VzdG9tU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsWSA9IE1hdGguZmxvb3Iob2Zmc2V0cy5wb3BwZXIudG9wIC0gc2Nyb2xsT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxZIC09IHN0ZXAuc3BvdGxpZ2h0UGFkZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2Nyb2xsWSA9IHNjcm9sbFkgPj0gMCA/IHNjcm9sbFkgOiAwO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgc2Nyb2xsVG8oc2Nyb2xsWSwgeyBlbGVtZW50OiBzY3JvbGxQYXJlbnQyLCBkdXJhdGlvbjogc2Nyb2xsRHVyYXRpb24gfSkudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAoX2EgPSB0aGlzLnN0b3JlLmdldFBvcHBlcihcInRvb2x0aXBcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIWNhblVzZURPTSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBpbmRleCwgbGlmZWN5Y2xlLCBzdGF0dXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgY29udGludW91cyA9IGZhbHNlLFxuICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc2Nyb2xsVG9GaXJzdFN0ZXAgPSBmYWxzZSxcbiAgICAgIHN0ZXBzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaXNSdW5uaW5nID0gc3RhdHVzID09PSBTVEFUVVMuUlVOTklORztcbiAgICBjb25zdCBjb250ZW50ID0ge307XG4gICAgaWYgKGlzUnVubmluZyAmJiBzdGVwc1tpbmRleF0pIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBnZXRNZXJnZWRTdGVwKHRoaXMucHJvcHMsIHN0ZXBzW2luZGV4XSk7XG4gICAgICBjb250ZW50LnN0ZXAgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEpveXJpZGVTdGVwLFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgICBjYWxsYmFjazogdGhpcy5jYWxsYmFjayxcbiAgICAgICAgICBjb250aW51b3VzLFxuICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgIGhlbHBlcnM6IHRoaXMuaGVscGVycyxcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBzaG91bGRTY3JvbGw6ICFzdGVwLmRpc2FibGVTY3JvbGxpbmcgJiYgKGluZGV4ICE9PSAwIHx8IHNjcm9sbFRvRmlyc3RTdGVwKSxcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb250ZW50Lm92ZXJsYXkgPSAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoSm95cmlkZVBvcnRhbCwgeyBpZDogXCJyZWFjdC1qb3lyaWRlLXBvcnRhbFwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgICAgSm95cmlkZU92ZXJsYXksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5zdGVwLFxuICAgICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgICAgZGVidWcsXG4gICAgICAgICAgbGlmZWN5Y2xlLFxuICAgICAgICAgIG9uQ2xpY2tPdmVybGF5OiB0aGlzLmhhbmRsZUNsaWNrT3ZlcmxheVxuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlXCIgfSwgY29udGVudC5zdGVwLCBjb250ZW50Lm92ZXJsYXkpO1xuICB9XG59O1xuX19wdWJsaWNGaWVsZChKb3lyaWRlLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xudmFyIGNvbXBvbmVudHNfZGVmYXVsdCA9IEpveXJpZGU7XG5leHBvcnQge1xuICBBQ1RJT05TLFxuICBFVkVOVFMsXG4gIExJRkVDWUNMRSxcbiAgT1JJR0lOLFxuICBTVEFUVVMsXG4gIGNvbXBvbmVudHNfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-joyride/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tree-changes/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/tree-changes/dist/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ treeChanges; }\n/* harmony export */ });\n/* harmony import */ var _gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gilbarbara/deep-equal */ \"(app-pages-browser)/./node_modules/@gilbarbara/deep-equal/dist/index.mjs\");\n/* harmony import */ var is_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-lite */ \"(app-pages-browser)/./node_modules/is-lite/dist/index.mjs\");\n// src/index.ts\n\n\n\n// src/helpers.ts\n\n\nfunction canHaveLength(...arguments_) {\n  return arguments_.every((d) => is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(d));\n}\nfunction checkEquality(left, right, value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n  if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n  if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n    return !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value));\n  }\n  return right === value;\n}\nfunction compareNumbers(previousData, data, options) {\n  const { actual, key, previous, type } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  let changed = [left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number) && (type === \"increased\" ? left < right : left > right);\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].undefined(actual)) {\n    changed = changed && right === actual;\n  }\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].undefined(previous)) {\n    changed = changed && left === previous;\n  }\n  return changed;\n}\nfunction compareValues(previousData, data, options) {\n  const { key, type, value } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === \"added\" ? left : right;\n  const secondary = type === \"added\" ? right : left;\n  if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nullOrUndefined(value)) {\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(primary)) {\n      if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(primary) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(secondary, value);\n    }\n    return false;\n  }\n  if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n  if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n  return ![left, right].every((d) => is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].primitive(d) && is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(d)) && (type === \"added\" ? !is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(left) && is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(right) : is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(left) && !is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(right));\n}\nfunction getIterables(previousData, data, { key } = {}) {\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n  if (!isSameType(left, right)) {\n    throw new TypeError(\"Inputs have different types\");\n  }\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n  if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n  return [left, right];\n}\nfunction hasEntry(input) {\n  return ([key, value]) => {\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(input)) {\n      return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value) || input.some((d) => (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(value) && isEqualPredicate(value)(d));\n    }\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(input) && input[key]) {\n      return !!input[key] && (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input[key], value);\n    }\n    return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value);\n  };\n}\nfunction hasExtraKeys(left, right) {\n  return right.some((d) => !left.includes(d));\n}\nfunction hasValue(input) {\n  return (value) => {\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(input)) {\n      return input.some((d) => (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(value) && isEqualPredicate(value)(d));\n    }\n    return (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, value);\n  };\n}\nfunction includesOrEqualsTo(previousValue, value) {\n  return is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(previousValue) ? previousValue.some((d) => (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value)) : (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(previousValue, value);\n}\nfunction isEqualPredicate(data) {\n  return (value) => data.some((d) => (0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d, value));\n}\nfunction isSameType(...arguments_) {\n  return arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array) || arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number) || arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject) || arguments_.every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string);\n}\nfunction nested(data, property) {\n  if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(data) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(data)) {\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].string(property)) {\n      const props = property.split(\".\");\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n    if (is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(property)) {\n      return data[property];\n    }\n    return data;\n  }\n  return data;\n}\n\n// src/index.ts\nfunction treeChanges(previousData, data) {\n  if ([previousData, data].some(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].nullOrUndefined)) {\n    throw new Error(\"Missing required parameters\");\n  }\n  if (![previousData, data].every((d) => is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject(d) || is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array(d))) {\n    throw new Error(\"Expected plain objects or array\");\n  }\n  const added = (key, value) => {\n    try {\n      return compareValues(previousData, data, { key, type: \"added\", value });\n    } catch {\n      return false;\n    }\n  };\n  const changed = (key, actual, previous) => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(actual);\n      const hasPrevious = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(previous);\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious ? includesOrEqualsTo(previous, left) : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n        return leftComparator && rightComparator;\n      }\n      if ([left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].array) || [left, right].every(is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plainObject)) {\n        return !(0,_gilbarbara_deep_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(left, right);\n      }\n      return left !== right;\n    } catch {\n      return false;\n    }\n  };\n  const changedFrom = (key, previous, actual) => {\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n      return false;\n    }\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(actual);\n      return includesOrEqualsTo(previous, left) && (hasActual ? includesOrEqualsTo(actual, right) : !hasActual);\n    } catch {\n      return false;\n    }\n  };\n  const decreased = (key, actual, previous) => {\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, { key, actual, previous, type: \"decreased\" });\n    } catch {\n      return false;\n    }\n  };\n  const emptied = (key) => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n      return !!left.length && !right.length;\n    } catch {\n      return false;\n    }\n  };\n  const filled = (key) => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n      return !left.length && !!right.length;\n    } catch {\n      return false;\n    }\n  };\n  const increased = (key, actual, previous) => {\n    if (!is_lite__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, { key, actual, previous, type: \"increased\" });\n    } catch {\n      return false;\n    }\n  };\n  const removed = (key, value) => {\n    try {\n      return compareValues(previousData, data, { key, type: \"removed\", value });\n    } catch {\n      return false;\n    }\n  };\n  return { added, changed, changedFrom, decreased, emptied, filled, increased, removed };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cmVlLWNoYW5nZXMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDNEM7QUFDbEI7O0FBRTFCO0FBQzJDO0FBQ2xCO0FBQ3pCO0FBQ0EsaUNBQWlDLCtDQUFFLGNBQWMsK0NBQUUsYUFBYSwrQ0FBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFFO0FBQzVCO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQUU7QUFDdEMsT0FBTywrQ0FBRTtBQUNUO0FBQ0E7QUFDQSxPQUFPLCtDQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBRTtBQUNULFFBQVEsK0NBQUU7QUFDVixVQUFVLCtDQUFFLG1CQUFtQiwrQ0FBRTtBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsa0VBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFFO0FBQzVCO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUU7QUFDNUI7QUFDQTtBQUNBLHFDQUFxQywrQ0FBRSxpQkFBaUIsK0NBQUUscUNBQXFDLCtDQUFFLGtCQUFrQiwrQ0FBRSxrQkFBa0IsK0NBQUUsbUJBQW1CLCtDQUFFO0FBQzlKO0FBQ0EsNENBQTRDLE1BQU0sSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBRTtBQUNWLGFBQWEsa0VBQUssb0NBQW9DLGtFQUFLLGNBQWMsK0NBQUU7QUFDM0U7QUFDQSxRQUFRLCtDQUFFO0FBQ1YsNkJBQTZCLGtFQUFLO0FBQ2xDO0FBQ0EsV0FBVyxrRUFBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQUU7QUFDViwrQkFBK0Isa0VBQUssY0FBYywrQ0FBRTtBQUNwRDtBQUNBLFdBQVcsa0VBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBRSxrREFBa0Qsa0VBQUssY0FBYyxrRUFBSztBQUNyRjtBQUNBO0FBQ0EscUNBQXFDLGtFQUFLO0FBQzFDO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQUUsNEJBQTRCLCtDQUFFLDZCQUE2QiwrQ0FBRSxrQ0FBa0MsK0NBQUU7QUFDN0g7QUFDQTtBQUNBLE1BQU0sK0NBQUUsc0JBQXNCLCtDQUFFO0FBQ2hDLFFBQVEsK0NBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQUc7QUFDbkM7QUFDQTtBQUNBLHlDQUF5QywrQ0FBRyxtQkFBbUIsK0NBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBRztBQUMzQiwwQkFBMEIsK0NBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBRywrQkFBK0IsK0NBQUc7QUFDbkUsZ0JBQWdCLGtFQUFNO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBRztBQUMzQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMENBQTBDO0FBQzVGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQ0FBMEM7QUFDNUYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cmVlLWNoYW5nZXMvZGlzdC9pbmRleC5tanM/ZTk4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCBlcXVhbDIgZnJvbSBcIkBnaWxiYXJiYXJhL2RlZXAtZXF1YWxcIjtcbmltcG9ydCBpczIgZnJvbSBcImlzLWxpdGVcIjtcblxuLy8gc3JjL2hlbHBlcnMudHNcbmltcG9ydCBlcXVhbCBmcm9tIFwiQGdpbGJhcmJhcmEvZGVlcC1lcXVhbFwiO1xuaW1wb3J0IGlzIGZyb20gXCJpcy1saXRlXCI7XG5mdW5jdGlvbiBjYW5IYXZlTGVuZ3RoKC4uLmFyZ3VtZW50c18pIHtcbiAgcmV0dXJuIGFyZ3VtZW50c18uZXZlcnkoKGQpID0+IGlzLnN0cmluZyhkKSB8fCBpcy5hcnJheShkKSB8fCBpcy5wbGFpbk9iamVjdChkKSk7XG59XG5mdW5jdGlvbiBjaGVja0VxdWFsaXR5KGxlZnQsIHJpZ2h0LCB2YWx1ZSkge1xuICBpZiAoIWlzU2FtZVR5cGUobGVmdCwgcmlnaHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChbbGVmdCwgcmlnaHRdLmV2ZXJ5KGlzLmFycmF5KSkge1xuICAgIHJldHVybiAhbGVmdC5zb21lKGhhc1ZhbHVlKHZhbHVlKSkgJiYgcmlnaHQuc29tZShoYXNWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIGlmIChbbGVmdCwgcmlnaHRdLmV2ZXJ5KGlzLnBsYWluT2JqZWN0KSkge1xuICAgIHJldHVybiAhT2JqZWN0LmVudHJpZXMobGVmdCkuc29tZShoYXNFbnRyeSh2YWx1ZSkpICYmIE9iamVjdC5lbnRyaWVzKHJpZ2h0KS5zb21lKGhhc0VudHJ5KHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHJpZ2h0ID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKHByZXZpb3VzRGF0YSwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IGFjdHVhbCwga2V5LCBwcmV2aW91cywgdHlwZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGVmdCA9IG5lc3RlZChwcmV2aW91c0RhdGEsIGtleSk7XG4gIGNvbnN0IHJpZ2h0ID0gbmVzdGVkKGRhdGEsIGtleSk7XG4gIGxldCBjaGFuZ2VkID0gW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5udW1iZXIpICYmICh0eXBlID09PSBcImluY3JlYXNlZFwiID8gbGVmdCA8IHJpZ2h0IDogbGVmdCA+IHJpZ2h0KTtcbiAgaWYgKCFpcy51bmRlZmluZWQoYWN0dWFsKSkge1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkICYmIHJpZ2h0ID09PSBhY3R1YWw7XG4gIH1cbiAgaWYgKCFpcy51bmRlZmluZWQocHJldmlvdXMpKSB7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgJiYgbGVmdCA9PT0gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBjb21wYXJlVmFsdWVzKHByZXZpb3VzRGF0YSwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IGtleSwgdHlwZSwgdmFsdWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxlZnQgPSBuZXN0ZWQocHJldmlvdXNEYXRhLCBrZXkpO1xuICBjb25zdCByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICBjb25zdCBwcmltYXJ5ID0gdHlwZSA9PT0gXCJhZGRlZFwiID8gbGVmdCA6IHJpZ2h0O1xuICBjb25zdCBzZWNvbmRhcnkgPSB0eXBlID09PSBcImFkZGVkXCIgPyByaWdodCA6IGxlZnQ7XG4gIGlmICghaXMubnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIGlmIChpcy5kZWZpbmVkKHByaW1hcnkpKSB7XG4gICAgICBpZiAoaXMuYXJyYXkocHJpbWFyeSkgfHwgaXMucGxhaW5PYmplY3QocHJpbWFyeSkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrRXF1YWxpdHkocHJpbWFyeSwgc2Vjb25kYXJ5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlcXVhbChzZWNvbmRhcnksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChbbGVmdCwgcmlnaHRdLmV2ZXJ5KGlzLmFycmF5KSkge1xuICAgIHJldHVybiAhc2Vjb25kYXJ5LmV2ZXJ5KGlzRXF1YWxQcmVkaWNhdGUocHJpbWFyeSkpO1xuICB9XG4gIGlmIChbbGVmdCwgcmlnaHRdLmV2ZXJ5KGlzLnBsYWluT2JqZWN0KSkge1xuICAgIHJldHVybiBoYXNFeHRyYUtleXMoT2JqZWN0LmtleXMocHJpbWFyeSksIE9iamVjdC5rZXlzKHNlY29uZGFyeSkpO1xuICB9XG4gIHJldHVybiAhW2xlZnQsIHJpZ2h0XS5ldmVyeSgoZCkgPT4gaXMucHJpbWl0aXZlKGQpICYmIGlzLmRlZmluZWQoZCkpICYmICh0eXBlID09PSBcImFkZGVkXCIgPyAhaXMuZGVmaW5lZChsZWZ0KSAmJiBpcy5kZWZpbmVkKHJpZ2h0KSA6IGlzLmRlZmluZWQobGVmdCkgJiYgIWlzLmRlZmluZWQocmlnaHQpKTtcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhYmxlcyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5IH0gPSB7fSkge1xuICBsZXQgbGVmdCA9IG5lc3RlZChwcmV2aW91c0RhdGEsIGtleSk7XG4gIGxldCByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICBpZiAoIWlzU2FtZVR5cGUobGVmdCwgcmlnaHQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0cyBoYXZlIGRpZmZlcmVudCB0eXBlc1wiKTtcbiAgfVxuICBpZiAoIWNhbkhhdmVMZW5ndGgobGVmdCwgcmlnaHQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0cyBkb24ndCBoYXZlIGxlbmd0aFwiKTtcbiAgfVxuICBpZiAoW2xlZnQsIHJpZ2h0XS5ldmVyeShpcy5wbGFpbk9iamVjdCkpIHtcbiAgICBsZWZ0ID0gT2JqZWN0LmtleXMobGVmdCk7XG4gICAgcmlnaHQgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIH1cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG59XG5mdW5jdGlvbiBoYXNFbnRyeShpbnB1dCkge1xuICByZXR1cm4gKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChpcy5hcnJheShpbnB1dCkpIHtcbiAgICAgIHJldHVybiBlcXVhbChpbnB1dCwgdmFsdWUpIHx8IGlucHV0LnNvbWUoKGQpID0+IGVxdWFsKGQsIHZhbHVlKSB8fCBpcy5hcnJheSh2YWx1ZSkgJiYgaXNFcXVhbFByZWRpY2F0ZSh2YWx1ZSkoZCkpO1xuICAgIH1cbiAgICBpZiAoaXMucGxhaW5PYmplY3QoaW5wdXQpICYmIGlucHV0W2tleV0pIHtcbiAgICAgIHJldHVybiAhIWlucHV0W2tleV0gJiYgZXF1YWwoaW5wdXRba2V5XSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWwoaW5wdXQsIHZhbHVlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc0V4dHJhS2V5cyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gcmlnaHQuc29tZSgoZCkgPT4gIWxlZnQuaW5jbHVkZXMoZCkpO1xufVxuZnVuY3Rpb24gaGFzVmFsdWUoaW5wdXQpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgIGlmIChpcy5hcnJheShpbnB1dCkpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zb21lKChkKSA9PiBlcXVhbChkLCB2YWx1ZSkgfHwgaXMuYXJyYXkodmFsdWUpICYmIGlzRXF1YWxQcmVkaWNhdGUodmFsdWUpKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsKGlucHV0LCB2YWx1ZSk7XG4gIH07XG59XG5mdW5jdGlvbiBpbmNsdWRlc09yRXF1YWxzVG8ocHJldmlvdXNWYWx1ZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzLmFycmF5KHByZXZpb3VzVmFsdWUpID8gcHJldmlvdXNWYWx1ZS5zb21lKChkKSA9PiBlcXVhbChkLCB2YWx1ZSkpIDogZXF1YWwocHJldmlvdXNWYWx1ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcXVhbFByZWRpY2F0ZShkYXRhKSB7XG4gIHJldHVybiAodmFsdWUpID0+IGRhdGEuc29tZSgoZCkgPT4gZXF1YWwoZCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoLi4uYXJndW1lbnRzXykge1xuICByZXR1cm4gYXJndW1lbnRzXy5ldmVyeShpcy5hcnJheSkgfHwgYXJndW1lbnRzXy5ldmVyeShpcy5udW1iZXIpIHx8IGFyZ3VtZW50c18uZXZlcnkoaXMucGxhaW5PYmplY3QpIHx8IGFyZ3VtZW50c18uZXZlcnkoaXMuc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIG5lc3RlZChkYXRhLCBwcm9wZXJ0eSkge1xuICBpZiAoaXMucGxhaW5PYmplY3QoZGF0YSkgfHwgaXMuYXJyYXkoZGF0YSkpIHtcbiAgICBpZiAoaXMuc3RyaW5nKHByb3BlcnR5KSkge1xuICAgICAgY29uc3QgcHJvcHMgPSBwcm9wZXJ0eS5zcGxpdChcIi5cIik7XG4gICAgICByZXR1cm4gcHJvcHMucmVkdWNlKChhY2MsIGQpID0+IGFjYyAmJiBhY2NbZF0sIGRhdGEpO1xuICAgIH1cbiAgICBpZiAoaXMubnVtYmVyKHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIGRhdGFbcHJvcGVydHldO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiB0cmVlQ2hhbmdlcyhwcmV2aW91c0RhdGEsIGRhdGEpIHtcbiAgaWYgKFtwcmV2aW91c0RhdGEsIGRhdGFdLnNvbWUoaXMyLm51bGxPclVuZGVmaW5lZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcnNcIik7XG4gIH1cbiAgaWYgKCFbcHJldmlvdXNEYXRhLCBkYXRhXS5ldmVyeSgoZCkgPT4gaXMyLnBsYWluT2JqZWN0KGQpIHx8IGlzMi5hcnJheShkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwbGFpbiBvYmplY3RzIG9yIGFycmF5XCIpO1xuICB9XG4gIGNvbnN0IGFkZGVkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbXBhcmVWYWx1ZXMocHJldmlvdXNEYXRhLCBkYXRhLCB7IGtleSwgdHlwZTogXCJhZGRlZFwiLCB2YWx1ZSB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNoYW5nZWQgPSAoa2V5LCBhY3R1YWwsIHByZXZpb3VzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxlZnQgPSBuZXN0ZWQocHJldmlvdXNEYXRhLCBrZXkpO1xuICAgICAgY29uc3QgcmlnaHQgPSBuZXN0ZWQoZGF0YSwga2V5KTtcbiAgICAgIGNvbnN0IGhhc0FjdHVhbCA9IGlzMi5kZWZpbmVkKGFjdHVhbCk7XG4gICAgICBjb25zdCBoYXNQcmV2aW91cyA9IGlzMi5kZWZpbmVkKHByZXZpb3VzKTtcbiAgICAgIGlmIChoYXNBY3R1YWwgfHwgaGFzUHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgbGVmdENvbXBhcmF0b3IgPSBoYXNQcmV2aW91cyA/IGluY2x1ZGVzT3JFcXVhbHNUbyhwcmV2aW91cywgbGVmdCkgOiAhaW5jbHVkZXNPckVxdWFsc1RvKGFjdHVhbCwgbGVmdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Q29tcGFyYXRvciA9IGluY2x1ZGVzT3JFcXVhbHNUbyhhY3R1YWwsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGxlZnRDb21wYXJhdG9yICYmIHJpZ2h0Q29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICAgIGlmIChbbGVmdCwgcmlnaHRdLmV2ZXJ5KGlzMi5hcnJheSkgfHwgW2xlZnQsIHJpZ2h0XS5ldmVyeShpczIucGxhaW5PYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAhZXF1YWwyKGxlZnQsIHJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0ICE9PSByaWdodDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNoYW5nZWRGcm9tID0gKGtleSwgcHJldmlvdXMsIGFjdHVhbCkgPT4ge1xuICAgIGlmICghaXMyLmRlZmluZWQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgbGVmdCA9IG5lc3RlZChwcmV2aW91c0RhdGEsIGtleSk7XG4gICAgICBjb25zdCByaWdodCA9IG5lc3RlZChkYXRhLCBrZXkpO1xuICAgICAgY29uc3QgaGFzQWN0dWFsID0gaXMyLmRlZmluZWQoYWN0dWFsKTtcbiAgICAgIHJldHVybiBpbmNsdWRlc09yRXF1YWxzVG8ocHJldmlvdXMsIGxlZnQpICYmIChoYXNBY3R1YWwgPyBpbmNsdWRlc09yRXF1YWxzVG8oYWN0dWFsLCByaWdodCkgOiAhaGFzQWN0dWFsKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGRlY3JlYXNlZCA9IChrZXksIGFjdHVhbCwgcHJldmlvdXMpID0+IHtcbiAgICBpZiAoIWlzMi5kZWZpbmVkKGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb21wYXJlTnVtYmVycyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5LCBhY3R1YWwsIHByZXZpb3VzLCB0eXBlOiBcImRlY3JlYXNlZFwiIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZW1wdGllZCA9IChrZXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldEl0ZXJhYmxlcyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5IH0pO1xuICAgICAgcmV0dXJuICEhbGVmdC5sZW5ndGggJiYgIXJpZ2h0Lmxlbmd0aDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGZpbGxlZCA9IChrZXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldEl0ZXJhYmxlcyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5IH0pO1xuICAgICAgcmV0dXJuICFsZWZ0Lmxlbmd0aCAmJiAhIXJpZ2h0Lmxlbmd0aDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGluY3JlYXNlZCA9IChrZXksIGFjdHVhbCwgcHJldmlvdXMpID0+IHtcbiAgICBpZiAoIWlzMi5kZWZpbmVkKGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb21wYXJlTnVtYmVycyhwcmV2aW91c0RhdGEsIGRhdGEsIHsga2V5LCBhY3R1YWwsIHByZXZpb3VzLCB0eXBlOiBcImluY3JlYXNlZFwiIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb21wYXJlVmFsdWVzKHByZXZpb3VzRGF0YSwgZGF0YSwgeyBrZXksIHR5cGU6IFwicmVtb3ZlZFwiLCB2YWx1ZSB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7IGFkZGVkLCBjaGFuZ2VkLCBjaGFuZ2VkRnJvbSwgZGVjcmVhc2VkLCBlbXB0aWVkLCBmaWxsZWQsIGluY3JlYXNlZCwgcmVtb3ZlZCB9O1xufVxuZXhwb3J0IHtcbiAgdHJlZUNoYW5nZXMgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tree-changes/dist/index.mjs\n"));

/***/ })

});